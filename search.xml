<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[移动端事件基础]]></title>
    <url>%2F2019%2F03%2F28%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[PC端常用事件 click(点击)、mouseover（鼠标滑进）、mouseenter（鼠标进入）、mousedown（鼠标按下）、mouseup（鼠标抬起）、mouseout（鼠标移出）、mouseleave（鼠标离开）、mousemove（鼠标移动）、mousewheel（鼠标滑轮滚动）、keydown（键盘按下）、keyup（键盘抬起）、change（输入框内容改变）、scroll（浏览器滚动条滚动）、load（加载完成）、ready（准备就绪）、blur（文本框失去焦点）、focus（文本框得到焦点）… 移动端常用事件 click(点击)、load（加载完成）、scroll（滚动条滚动）、blur（文本框失去焦点）、focus（文本框失去焦点）、change（输入框内容发生改变 ）、input(文本框输入内容，代替keyup、keydown)… touch事件模型 处理单手指操作 touchstart：手指在屏幕中按下 touchmove：手指在屏幕中移动 touchend：手指离开屏幕 touchcancle：手指在屏幕中操作，设备突然故障（断电、程序闪退） 移动端的手指操作 点击、单击、长按、滑动、左滑、右滑、上滑、下滑… 单击和双击（当用户的手指在第一次点击屏幕之后，等待300ms还没有等到用户的第二次点击，则认为是单击，否则认为是双击） 点击和长按（当用户的手指停留在屏幕上的事件超过750ms，则认为是长按，否则认为是点击） 点击和滑动（当用户的手指在屏幕上操作时，轨迹的X/Y轴偏移的距离在30px以内，则认为是点击，否则认为是滑动） 左右滑动和上下滑动（当用户的手指在屏幕上操作时，轨迹的X轴的距离 &gt; Y轴偏移的距离，则认为是左右滑动，否则认为是上下滑动） 左滑和右滑（当用户的手指在屏幕上操作时，轨迹在X轴的偏移距离 &gt; 0，则认为是右滑，否则认为是左滑） 上滑和下滑（当用户的手指在屏幕上操作时，轨迹在Y轴的偏移距离 &gt; 0，则认为是下滑，否则认为是上滑） gesture事件模型 处理多手指操作 gesturestart gesturechange gestureend 移动端的click事件与PC端的click事件的区别移动端的click事件 属于单击事件，不是点击事件。在移动端的项目中，经常会区分单击做什么操作和双击做什么操作，所以移动端的浏览器在识别click的时候，只有确定是单击后才会执行对应的操作。因此，在移动端使用click会存在300ms的延迟；浏览器在第一次点击结束后，还需要等到300ms看是否触发了第二次点击，如果触发了第二次的点击，则当前事件就不属于单击事件了，只有没有触发第二次的点击才属于单击（click）。 移动端事件-Touch事件模型案例12345678910111213141516171819202122232425262728&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;移动端事件机制-touch事件模型&lt;/title&gt; &lt;style type="text/css"&gt; html,body&#123; height: 100%; overflow: hidden; &#125; .box&#123; /* 盒子水平垂直居中 */ position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto; width: 300px; height: 300px; background-color: lightcoral; /*为动画添加过渡效果*/ -webkit-transition: all 1s ease 0s; transition: all 1s ease 0s; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box"&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;script type="text/javascript"&gt; var box = document.querySelector('.box'); //移动端采用click有300ms的延迟 // box.addEventListener('click', function(e)&#123; // console.log(e); //e: MouseEvent // &#125;); /** * 使用touch事件模型实现点击操作（单击或双击） * @param curEle * @param evenType * @param fn */ function on(curEle, evenType, fn)&#123; curEle.addEventListener(evenType, fn); &#125; /** * TouchEvent： 事件对象除了拥有一些其他事件对象都有的属性外，还存在一些区别: * 新增加了changedTouches属性集合和touches属性集合 * 相同点： * changeTouches和touches都是手指操作的信息集合（TouchList）， * 集合中记录了每一根操作的手指的相关信息（包含触发点的坐标位置）。 * 不同点： * touches: 记录的信息只有手指在屏幕上才有，也就是手指离开屏幕的时候信息就消失了， * changedTouches: 本意上记录的是改变的值，即使手指离开，信息值也在 * 所以，想要在touchend事件中获取离开的瞬间坐标值，只能使用changeTouches * */ on(box, 'touchstart', function(ev)&#123; // console.log(ev); //ev: TouchEvent //获取手指的初始坐标值 var point = ev.touches[0]; this['strX'] = point.clientX; this['strY'] = point.clientY; //设置一个标识，表示当前手指是否在屏幕上进行移动 this.isMove = false; &#125;); on(box, 'touchmove', function(ev)&#123; //获取最新的手指坐标位置 var point = ev.touches[0], newX = point.clientX, newY = point.clientY; //如果手指的最新坐标位置与初始接触屏幕的坐标在一定的误差范围内超出预定值，则认为此处动作为滑动，并不是点击 if(Math.abs(newX - this['strX']) &gt; 30 || Math.abs(newY - this['strY']) &gt; 30)&#123; //改变标识的值 this.isMove = true; &#125; &#125;); on(box, 'touchend', function(ev)&#123; //手指没有移动 if(!this.isMove)&#123; changeStyle(this, 'webkitTransform', 'rotate(360deg)', 'rotate(0deg)'); // //盒子原地旋转360度 // this.style.webkitTransitionDuration = '1s'; // this.style.webkitTransform = 'rotate(360deg)'; // window.setTimeout(function()&#123; // //先将盒子的过渡效果去除掉 // this.style.webkitTransitionDuration = '0s'; // this.style.webkitTransform = 'rotate(0deg)'; // &#125;.bind(this), 1000); //这里可以使用bind的方法可以将this进行替换，且不用立即执行（移动端不考虑兼容问题） &#125;else&#123; //手指发生了移动（这里理解为滑动操作） //改变背景颜色 changeStyle(this, 'backgroundColor', 'lightblue', 'lightcoral'); // this.style.webkitTransitionDuration = '1s'; // this.style.backgroundColor = 'lightblue'; // window.setTimeout(function()&#123; // this.style.webkitTransitionDuration = '0s'; // this.style.backgroundColor = 'lightcoral'; // &#125;.bind(this), 1000); //这里可以使用bind的方法可以将this进行替换，且不用立即执行（移动端不考虑兼容问题） &#125; &#125;); function changeStyle (curEle, cssStyle, value1, value2)&#123; curEle.style.webkitTransitionDuration = '1s'; curEle.style[cssStyle] = value1; window.setTimeout(function()&#123; //先将盒子的过渡效果去除掉 this.style.webkitTransitionDuration = '0s'; this.style[cssStyle] = value2; &#125;.bind(curEle), 1000); //这里可以使用bind的方法可以将this进行替换，且不用立即执行（移动端不考虑兼容问题） &#125;&lt;/script&gt; 移动端的事件库 FastClick.js: 解决click事件的300ms的延迟Touch.js: 百度云手势事件库Hammer.jsZepto.js Touch.js GitHub地址 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;移动端事件机制-touch事件模型&lt;/title&gt; &lt;style type="text/css"&gt; html,body&#123; height: 100%; overflow: hidden; &#125; .box&#123; /* 盒子水平垂直居中 */ position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto; width: 300px; height: 300px; background-color: lightcoral; /*为动画添加过渡效果*/ -webkit-transition: all 1s ease 0s; transition: all 1s ease 0s; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box"&gt;&lt;/div&gt;&lt;script type="text/javascript" src="js/touch.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var oBox = document.querySelector('.box'); touch.on(oBox, 'tap', function(e)&#123; //点击事件 /** * detail: * fingersCount (手指数) * position(手指的位置) * position: &#123;x: 243, y: 282&#125; */ // console.log(1, e); //e: CustomEvent this.style.webkitTransitionDuration = '1s'; this.style.webkitTransform = 'rotate(360deg)'; var delaTimer = window.setTimeout(function()&#123; this.style.webkitTransitionDuration = '0s'; this.style.webkitTransform = 'rotate(0deg)'; &#125;.bind(this), 1000); &#125;); touch.on(oBox, 'doubletap', function(e)&#123; //双击 this.style.backgroundColor = 'lightblue'; &#125;); touch.on(oBox, 'hold', function(e)&#123; //长按 this.style.backgroundColor = 'lightgreen'; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Zepto.js 中文文档地址GitHub地址 zepto真正实现了让开发人员进行模块组合式开发 Zepto 模块 module default description zepto ✔ 核心模块；包含许多方法 event ✔ 通过on()&amp; off()处理事件 ajax ✔ XMLHttpRequest 和 JSONP 实用功能 form ✔ 序列化 &amp; 提交web表单 ie ✔ 增加支持桌面的Internet Explorer 10+和Windows Phone 8。 detect 提供\$.os和 $.browser消息 fx The animate()方法 fx_methods 以动画形式的 show, hide, toggle, 和 fade*()方法. assets 实验性支持从DOM中移除image元素后清理iOS的内存。 data 一个全面的 data()方法, 能够在内存中存储任意对象。 deferred 提供\$.Deferredpromises API.依赖”callbacks” 模块. 当包含这个模块时候, $ .ajax() 支持promise接口链式的回调。 callbacks 为”deferred”模块提供 $.Callbacks。 selector 实验性的支持 jQuery CSS 表达式 实用功能，比如 $(‘div:first’)和 el.is(‘:visible’)。 touch 在触摸设备上触发tap– 和 swipe– 相关事件。这适用于所有的touch(iOS, Android)和pointer事件(Windows Phone)。 gesture 在触摸设备上触发 pinch 手势事件。 stack 提供 andSelf&amp; end()链式调用方法 ios3 String.prototype.trim 和 Array.prototype.reduce 方法 (如果他们不存在) ，以兼容 iOS 3.x. 案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Zepto.js的使用方法&lt;/title&gt; &lt;style type="text/css"&gt; html,body&#123; height: 100%; overflow: hidden; &#125; .box&#123; /* 盒子水平垂直居中 */ position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto; width: 300px; height: 300px; background-color: lightcoral; /*为动画添加过渡效果*/ /*-webkit-transition: all 1s ease 0s;*/ /*transition: all 1s ease 0s;*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box"&gt;&lt;/div&gt;&lt;script type="text/javascript" src="js/zepto.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; /** * zepto.js中的事件有两种类型 * 1. 一种是提供用on方法绑定的事件，称为内置事件 * 2. 另外一种是zepto.js专门为移动端提供的事件方法，只能通过 $('').事件方法名(function()&#123;&#125;); 的方式调用 * * 注意：1. 不能用这种方式调用: $('xxx').事件方法名 = function()&#123;&#125;; * 2. 只有用原生js获取的对象才能用这种方式调用touch事件，jq对象和zepto对象都是不可以的 * oBox.ontouchstart = function(e)&#123; * console.log(e); * &#125; * @type &#123;jQuery.fn.init|jQuery|HTMLElement&#125; */ var $box = $('.box'); //singleTap //单击 $box.doubleTap = function(e)&#123; //双击 console.log(e); &#125;; $box.longTap(function(e)&#123; //长按 console.log(e); &#125;); $box.tap(function(e)&#123; //点击, 当手指抬起的时候，才会执行绑定的方法 //e: Event，不能获取具体的手指点击的位置 $(this).animate(&#123; /** *Zpeto.js支持css3动画 * translate(X|Y|Z|3d) * rotate(X|Y|Z|3d) * scale(X|Y|Z) * matrix(3d) * perspective * skew(X|Y) */ rotate: '360deg' //rotate &lt;=&gt; rotateZ &#125;, 1000, 'linear', function()&#123; //this: div.box this.style.webkitTransform = 'rotate(0deg)'; &#125;); &#125;).on('touchstart', function()&#123; //zepto.js支持链式写法 this.style.backgroundColor = 'lightblue'; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; zepto.js 与 jquery的区别 zepto.js被誉为移动端的小型JQ库JQ由于是在PC端使用的，所以代码中包含了大量的对于IE低版本浏览器的兼容处理，二zepto.js应用于移动端的开发，所以在JQ的基础上没有对于低版本的IE进行支持JQ中提供了很多的选择器类型及DOM操作的方法，但是zepto中只是实现了部分常用的选择器和方法，例如：JQ中的动画方法有animate、hide、show、toggle、fadeIn、fadeOut、fadeToggle、slideUp、slideDown、slideToggle。。。但是在zepto中只实现了animate（但是在zepto的其他模块中实现了touch、show、hide、fade系列）所以总体来说，zepto比JQ小的多，所以它更适合移动端的开发zepto的特性： zepto的animate动画方法支持了css3动画的操作 zepto专门准备了移动端常用的事件操作：tap、singleTap、doubleTap、longTap、swip、swipeUp、swipeDown、seipeLeft、swipeRight。。。]]></content>
      <categories>
        <category>移动端事件</category>
      </categories>
      <tags>
        <tag>移动端事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hybrid App开发模式]]></title>
    <url>%2F2019%2F03%2F10%2FHybrid%20App%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Hybrid App（混合模式移动应用）是指介于web-app、native-app这两者之间的app，兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”。 Native App 移动互联网刚开始兴起的时候，我们手机上的应用(App)都是通过Native App开发而成的。Native App的开发具备很多的优势： 开发出来的产品具备良好的用户体验，动画和运行的速度非常的流畅。 能够对手机的内部软件或者硬件进行直接的操作，例如：可以调取用户的通讯论、读取用户的短信(当然需要用户同意)，可以调取用户的摄像头，调取手机的重力感应等… 但是Native App的开发也存在自己的很多不足： 首先是不能跨平台，针对目前最常用的IOS和安卓平台，需要用不同的技术来开发：IOS一般使用的是Object-c，而安卓平台使用的一般是Java-Native，这样就导致了开发一款App需要两队人马去做，随之而来的问题也会很多，比如：开发成本高，开发周期长，有的功能IOS有但是安卓没有(手Q就是这样的)等。 开发出来的产品需要用户自主性比较强：首先需要客户到应用商店安装，后期如果版本升级，用户想要看到最新的版本还需要重新的进行下载安装升级等。 在IOS平台上，开发出一款App上传到苹果App Store需要7天的审核期，在此期间如果审核失败，在此上传还需要七天，这样就有可能导致产品不能按时发布等。 … Web App 而HTML5的出现让Web App露出曙光。HTML5基本上不需要考虑是IOS还是安卓，两个平台一套代码基本上都是支持的；更新版本只需要在自己的服务器上更新了即可，这样用户再次访问的时候看到的就已经是最新版本的了；不需要经过漫长审核…这些优势让开发者们大为心动。 但是HTML5的本质是运行在浏览器中的页面(App是直接运行在操作系统中的)，由于浏览器的差异以及对一些特殊功能支持力度的不够，导致HTML5开发存在一些局限性问题： 开发出来的产品性能和运行速度没有App的好，用户体验不是很好。 虽然安卓和IOS平台上的浏览器大部分都是webkit内核的，但是浏览器厂商为了自己的特殊化，移动设备上的浏览器兼容也不少，甚至一些兼容问题是无法解决的(例如:position:fixed的支持非常的不好)。 由于HTML5的本质是运行在浏览器中的，所以想要操作系统中的软件或者硬件都需要所在的浏览器支持，很遗憾大部分浏览器对于这方面的操作都支持的不好，所以也就导致了，H5的产品在调取通讯录、摄像头、读取短信等方面存在了很大的短板，基本上很少用H5去做这些事情的。 … Hybrid App 正是在这样是机缘巧合下，基于HTML5低成本跨平台开发优势又兼具Native App特质的Hybrid App技术杀入混战，并且很快吸引了众人的目光。Hybrid App是把Native App和Web App混合在一起的新兴模式（目前市场上的大部分App都是混合模式开发的）。利用各自的优势，去开发一款低成本、跨平台、更新快、性能好、功能丰富的App。 Hybrid App按网页语言与程序语言的混合，通常分为三种类型： 多View混合型 单View混合型 Web主体型 多View混合型(目前常用的) 即Native View和Web View独立展示，交替出现。2012年常见的Hybrid App是Native View与WebView交替的场景出现。这种应用混合逻辑相对简单。即在需要的时候，将WebView当成一个独立的View（Activity）运行起来，在WebView内完成相关的展示操作。这种移动应用主体通常是Native App，Web技术只是起到补充作用。开发难度和Native App基本相当。 单View混合型 即在同一个View内，同时包括Native View和Web View。互相之间是覆盖（层叠）的关系。这种Hybrid App的开发成本较高，开发难度较大，但是体验较好。如百度搜索为代表的单View混合型移动应用，既可以实现充分的灵活性，又能实现较好的用户体验。 Web主体型(目前比较新颖流行的方式) 即移动应用的主体是Web View，主要以网页语言编写，穿插Native功能的Hybrid App开发类型。这种类型开发的移动应用体验相对而言存在缺陷，但整体开发难度大幅降低，并且基本可以实现跨平台。通俗来说，就是App中的页面基本上都是H5完成的，我们使用一些技术框架封装一个App的壳子，框架中还提供一些操作系统级别功能的API供H5的调取，一般来说，都是由JS编写代码来完成App壳子搭建的，这样开发的App也就不会在使用JAVA或者Object-c了。 目前市面上比较流行的框架有：React Native、phoneGap、appcan、APICloud、ionicframework、appMobi、WeX5… 接下来我们分享一下，关于多View混合型中的H5和Native App是如何的实现交互与通信的。 在这之前，我们首先需要知道，在多View混合型中，我们的HTML5页面主要运行在Native App提供的Web View中（你也可以把web view理解成为一个浏览器，因为他和浏览器基本上差不多）。但是我们知道H5是存在一些局限性的，比如我们想调取用户的摄像头拍照，这个H5解决不了，这样的话我们需要先用App把这个功能实现了，然后由H5在调取App的相关功能。这样就需要实现H5和App之间的通信交互。 ####第一种常用方式：jsBridge(微信平台的JS SDK就是基于这个开发的)WebView有一个方法，叫setWebChromeClient，可以设置WebChromeClient对象，而这个对象中有三个方法，分别是onJsAlert,onJsConfirm,onJsPrompt，当js调用window对象的对应的方法，即window.alert，window.confirm，window.prompt，WebChromeClient对象中的三个方法对应的就会被触发，利用这个机制我们就可以做一些特殊的处理。但是在项目中我们一般对于alert和confirm使用的频率较高，如果我们使用onJsAlert,onJsConfirm，那么我们普通的弹框也会受到影响，所以目前市场上最长使用的是onJsPrompt。 以上的操作基本上都需要由App那边进行开发，我们主要讲的是H5，所以此处不对App的机制做过多的描述。大家只需要知道，只要App那边做了特殊的处理（就是在webView中注入一个对象，对象中包含了我们需要调取的方法），那么在H5的js中，我们就可以调取WebView中提供的方法。一般来说需要我们给方法传递一个callback进去，这样App就会在具体的某个阶段，把我们的callback执行，从而实现对应的通信效果。下面是我们使用JS调取微信接口的DEMO： 1234567891011121314151617181920212223242526 //-&gt;首先需要引入微信提供好的一个JS：http://res.wx.qq.com/open/js/jweixin-1.0.0.js (其实App就是把这个JS中提供的方法注入到了web view中，所以我们只要引入这个JS进来就可以调用App的一些方法了) wx.config(&#123; debug: false, appId: "你的AppID", timestamp: '时间戳(需要后台生成)', nonceStr: '字符串(需要后台生成)', signature: '签名(需要后台生成)', jsApiList: ['onMenuShareTimeline', 'onMenuShareAppMessage']//-&gt;功能列表，我们要使用JS-SDK的什么功能&#125;); //-&gt;首先调取ready方法，这里说明一下，web view中注入的对象其实就是wx，read就是提供的一个方法，此处的匿名函数就是我们传递进去的callback，当微信检测到已经准备就绪的时候就会把我们的callback执行 wx.ready(function () &#123; //获取“分享到朋友圈”按钮点击状态及自定义分享内容接口 wx.onMenuShareTimeline(&#123; title: '分享标题', link: "分享的url,以http或https开头", imgUrl: "分享图标的url,以http或https开头" &#125;); //获取“分享给朋友”按钮点击状态及自定义分享内容接口 wx.onMenuShareAppMessage(&#123; title: '分享标题', desc: "分享描述", link: "分享的url,以http或https开头", imgUrl: "分享图标的url,以http或https开头", type: 'link' &#125;); &#125;); 第二种常用方式：伪装的URL或者伪装的协议相对于第一种jsBridge，第二种方式就比较的简单了。首先H5开发人员和App人员协商一套协议或者伪装的URL地址（也有可能是一放制定好，双方都按照执行即可）。然后App开发者开始实现对应的功能：第一个是实现具体业务操作的功能，例如调取摄像头拍照；第二个是劫持H5中所有发送的URL地址，然后把符合事先制定的规则的URL拦截下来，通过解析URL后面的参数值等调取对应的功能实现需求即可。下面是H5部分的代码样本：1234567function fn(img)&#123; //-&gt;打开摄像头拍照后执行的后续操作 img是拍下来的照片 &#125; window.location.href="zhufeng://phone?callback=fn"; //-&gt;zhufeng: 就是我们事先制定的一个假协议，所有这种协议的都代表需要调取App的某个功能 //-&gt;phone 这个标识就是事先制定的需要调取拍照功能 //-&gt;callback=fn 把自己JS中的某一个方法传递给App，App可以在拍照完成后执行这个方法，并且把保存的照片传递给这个方法(类似于JSONP)]]></content>
      <categories>
        <category>移动端开发</category>
      </categories>
      <tags>
        <tag>移动端</tag>
        <tag>Hybrid模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端响应式布局开发常用知识]]></title>
    <url>%2F2019%2F03%2F10%2F%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[响应式布局开发基础 什么是响应式布局开发? 把我们开发完成的产品，能够让其适配不同的设备屏幕：PC端（电脑）、PAD、PHONE（手机端） 当别人和你聊H5，他们想要聊的是什么? 现在H5已经成为移动端开发（响应式布局）的标准代名词 移动端发展史智能生活（互联网+）离不开各种APP（应用），这些应用离不开一代又一代的IT工程师很久以前，APP开发和H5没什么太大的关系，都是由专业的APP开发团队开发的 安卓系统：JAVA（java-native） IOS系统：C（object-c / swift） 我们把使用上述语言开发的APP称之为 native app（原生APP） native app的特点： 本地开发，打包成安装包，上传到应用商店（App Store 是有审核期的[7天]），用户从应用商店下载安装相关的APP：把当前APP的源文件（原代码安装在手机上了，类似于在电脑上安装WS） 。 native app可以操作手机内部的软件或者硬件（例如：通讯录、摄像头、相册、重力感应器等等），因为它是直接运行在操作系统中的程序 。 做一些操作和交互，性能是比较不错的。 手机操作系统不一样，使用的技术也不一样，所以需要两个不同的开发团队，开发不同版本的APP（问题：有的版本升级快，有的版本升级慢）。 目前我们开发一款APP需要H5的介入：在native-app中嵌入H5页面(web-app)，运行在原生APP（Native App）的webView中的，我们把这种模式称之为Hybrid混合APP开发 由H5开发的web-app的特点： 其实就是个HTML页面，需要基于浏览器运行（PC或者移动端浏览器再或者V8内核的工具也可以），如果想要操作手机内部的软件或者硬件，需要浏览器的支持 相比于native-app来说，性能不好 所有的请求访问都必须基于连网的状态（除了有些是native-app把h5特殊处理了），虽然h5中支持manifest离线缓存，但是这个技术不咋好用 原因：native-app不需要，是因为所有的代码文件都在手机上，一些需要连网访问的，native-app都可以做离线缓存（缓存视频）；H5页面部署到了自己的服务器上，源文件都在服务器上呢，用户想要看页面，必须从服务器上重新的拉取代码才可以； 更新比较及时：H5只需要把服务器上的文件更新，用户每次访问看到的都是最新版本，这个比native-app好 微信是最为经典的Hybrid混合开发模式，它支持我们的H5页面在微信这个native-app中运行，而且还可以调取微信提供的一些方法实现相关的操作（例如：微信的二次分享）微信公众号开发地址 手机常用尺寸[苹果]iphone 5s及以前：320pxiphone4 : 320480iphone5 : 320568iphone6：375px * 667iphone6plus：414px[安卓]320、360、480、540、640、720 … 做H5页面开发之前，需要先从设计师手里索要UI设计图（PSD格式的或者sketch设计稿） 设计师提供的专门做移动端项目的设计稿尺寸 640*960 640*1136 750*1334 高清屏 媒体查询 媒体查询：@media媒体设备： all: 所有设备 screen: 所有屏幕设备（pc+移动端） print：打印机 … 媒体条件：指定在什么条件下执行对应的样式格式： @media [媒体设备] and [媒体条件] and [媒体条件]。。。 不同的宽度不同的样式12345678910@media all and(max-width: 319px)&#123; //宽度小于320px .box&#123; height: 320px; &#125;&#125;@media all and(min-width: 320px) and (max-width: 359px)&#123; //宽度大于320px，小于360px .box&#123; height: 360px; &#125;&#125; 不同的显示屏不同的样式12345678910@media all and(-webkit-device-pixel-ratio: 2)&#123; //2倍屏幕 .box&#123; background: url('banner@2x.jpg'); &#125;&#125;@media all and(-webkit-device-pixel-ratio: 3)&#123; //3倍屏幕 .box&#123; background: url('banner@3x.jpg'); &#125;&#125; 常见的项目类型 PC端和移动端公用一套项目（同一个地址），我们也要保持良好的展示性，例如：猎豹浏览器、华为官网等简单的展示网站(需要做响应式) PC端和移动端用的是不同的项目，例如：京东、淘宝等… PC端固定布局即可 移动端需要考虑响应式开发 1）放在浏览器中运行 2）放在第三方平台中运行（微信） 3）放在自己公司的native-app中运行 如何做响应式布局开发? 只要当前页面需要在移动端访问，必然加123&lt;!--meta:vp [tab]--&gt;&lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; 不加VP，不管手机设备有多宽，我们HTML页面的宽度都是980（如果在320的手机上观看HTML页面，为了保证保证把页面呈现全，需要HTML缩小大概三倍左右，所有内容都变小了），为了不让页面缩放，我们需要保证手机的宽度和HTML的宽度一致 。 viewport:视口 width:可视区域的宽度，值可为数字或关键词device-width width=device-width：设置视口的宽度等于设备的宽度，如果不设置的话，默认视口的宽度是980px，通俗理解：我们这个操作其实就是告诉当前的浏览器按照多少宽度来渲染页面，换句话说就是展示当前这个页面的区域有多宽（浏览器的宽度） height:同width intial-scale:页面首次被显示是可视区域的缩放级别，取值1.0则页面按实际尺寸显示，无任何缩放 maximum-scale=1.0, minimum-scale=1.0;可视区域的缩放级别， maximum-scale用户可将页面放大的程序，1.0将禁止用户放大到实际尺寸之上。 user-scalable:是否可对页面进行缩放，no 禁止缩放[没有加VP的效果：全体缩小了，需要手动缩放看]12345//=&gt;JS中动态设置vpvar vp=document.createElement('meta');vp.name='viewport';vp.content='width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0';document.head.appendChild(vp); [加入vp后就不在变小了] ####1. 基于@MEDIA来处理（麻烦一些） ####2. 固定布局(viewport =&gt; width=320px) 按照设计稿把320尺寸的写好即可（所有的尺寸都可以固定，而且都是设计稿的一半 [因为设计稿是大一倍的]），在其它的设备上，让320的页面居中展示即可 4. SCALE等比缩放布局 （严格按照设计稿的尺寸来写样式[没有啥自适应宽度，都是固定值]，在其它设备上，首先获取设备的宽度，让其除以设计稿的宽度，然后让原始写好的页面按照这个比例整体缩小即可） =&gt;会导致一些问题例如字体变模糊…[案例]123456789101112131415161718192021222324252627282930313233&lt;style&gt; .container &#123; margin: 0 auto; width: 750px; transform-origin: left top; /*控制最终缩放的时候：不是从中新点缩放，而是从左上角缩放*/ &#125; .headerBox &#123; height: 200px; border: 2px solid lightcoral; &#125; .headerBox h1 &#123; float: left; width: 300px; height: 100%; line-height: 200px; text-align: center; font-size: 36px; &#125; .headerBox ul &#123; float: right; &#125; .headerBox ul li &#123; float: left; padding: 0 20px; height: 200px; line-height: 200px; font-size: 28px; &#125; &lt;/style&gt; 1234567&lt;script&gt; window.addEventListener('load', () =&gt; &#123; let container = document.querySelector('.container'), winW = document.documentElement.clientWidth; container.style.transform = `scale($&#123;winW / 750&#125;)`; &#125;);&lt;/script&gt; 12345678910&lt;div class="container"&gt; &lt;header class="headerBox"&gt; &lt;h1&gt;珠峰培训&lt;/h1&gt; &lt;ul class="menu clear"&gt; &lt;li&gt;首页&lt;/li&gt; &lt;li&gt;团购&lt;/li&gt; &lt;li&gt;海外&lt;/li&gt; &lt;/ul&gt; &lt;/header&gt;&lt;/div&gt; ####3. 流式布局 容器或者盒子的宽度一般都不写固定值，而是使用百分比（相对于视口区域的百分比）。 其余的样式：字体、高度、margin、padding等等都是按照设计稿上标注的尺寸的一半来设置。 对于有些屏幕尺寸下，我们设置的固定值看起来不是特别的好看的话，使用@media（媒体查询）进行微调整。 例如，实现一个div，距离左右两边都为10px123456789101112/*传统写法*/.box&#123; margin: 0 auto; width: 300px; height: 100px;&#125;/*流式布局写法*/.box&#123; margin: 0 10px; width: 100%; /*可以不写，省略*/ height: 100px;&#125; 特殊情况：设计师的设计稿是640px，我们的素材图也是640px，这样的话，在iphone6/inphone6 plus 展示的时候，图片不够大，对于这种情况，我们需要单独找设计师要一张更大的图，在腾讯的时候，一般向设计师要一张280px的大图。123456789101112 /*在（最小为2倍高清屏和设备的宽度大于320px）的时候的样式*/@media all and (-webkit-min-device-pixel-ratio: 2) and (min-width: 321px)&#123; .box&#123; background: url("banner@big.png"); &#125;&#125;/*在(设备的宽度大于640px)的时候的样式*/@media all and (min-width: 641px)&#123; .box&#123; background: url("banner@big.png"); &#125;&#125; REM响应式布局开发 和px像素一样，它是一个CSS样式单位 PX：固定单位 REM：相对单位（相对于页面根元素[HTML]字体大小设定的单位 真实项目中如何利用REM的这个特性实现响应式呢？ 严格按照设计稿中提供的尺寸进行样式编写（不管是宽高、还是MARGIN、还是字体等），例如：设计稿是7501336的，设计稿中有一个300150的图片，我们布局的时候依然按照300*150布局… 我们在编写样式的时候，不要使用PX单位，所有的单位都统一换算为REM（此时我们需要让HTML的FONT-SIZE=100PX） 上述完成后，在750的手机上是没有任何问题的，但是在375的手机上肯定存在问题了（页面太大了），此时我们需要让页面中的所有样式，都整体缩小，才能达到响应式适配的目的 此时只需要把HTML的字体大小修改，那么之前所有以REM为单位的样式自动会跟着重新计算： 750设计稿：1REM=100PX 375的手机：375/750100 就是最新HTML的字体大小，也是最新REM和PX的换算比例**当前设备的宽度/设计稿宽度*100=“当前手机下REM和PX的换算比例[HTML的字体大小]”*** REM等比缩放响应式布局 目前市场上，如果单独做移动端项目（项目只在移动端访问，PC端有单独的项目），我们选择响应式适配的最佳方案就是REM布局（当然细节处理可能会用到flex或者@media） 移动端常用类库Zepto 一个小型的，专门针对于移动端开发的JS类库，它的开发原理以及使用方式都非常接近于JQ，所以很多人也把它称之为小型的JQ ZEPTO VS JQUERY zepto不支持IE6~8，有一些方法连IE的高版本也不支持，是专门为安卓和IOS系统所在的移动端准备的；JQ的第一代版本兼容所有的浏览器(最常用的版本)，第二代和第三代不在兼容IE低版本浏览器； zepto只实现了部分JQ中常用的方法，有一些方法在zepto中无法使用，例如：JQ支持animate、hide、show、slideDown、slideUp…这些动画，但是zepto中只有animate，其它快捷动画不支持 zepto类库的体积比jquery小很多，它属于轻量级的JS类库，更适合移动端的使用 zepto中提供了移动端专用的事件操作方法，而jquery中没有； tap：点击 singleTap：单击 doubleTap：双击 longTap：长按 swipe：滑动 swipeUp/Down/Left/Right：四个方向滑动 pinchIn/Out：放大缩小 …12345&gt;$(‘selector’).tap(function(e)&#123; &gt;//=&gt;实现点击要做什么 &gt;//=&gt;e：手指事件对象 this:当前操作的元素 &gt;&#125;)&gt; zepto中的animate支持transform变形，jquery中是不支持的1234567&gt;$('selector').animate(&#123;&gt; top:100,&gt; rotate:'360deg'&gt;&#125;,1000,'linear',function()&#123;&gt; //=&gt;回调函数，动画完成后触发执行&gt;&#125;);&gt; zepto官网 HTML5中的audio 音频播放标签，通过它可以播放音频文件（支持格式：mp3、ogg、wav） [使用]12345678&lt;audio src='xxx.mp3'&gt;&lt;/audio&gt;&lt;audio&gt; &lt;source src='xxx.mp3' type='audio/mpeg'&gt; &lt;source src='xxx.ogg' type='audio/ogg'&gt; &lt;source src='xxx.wav' type='audio/wav'&gt; 您的浏览器不支持AUDIO，请升级浏览器 &lt;/audio&gt; AUDIO中的一些内置属性 属性名 解释 controls 是否使用内置的播放器播放，默认是不显示浏览器自带播放器的，加上这个属性显示 autoplay 自动播放（这个属性一般不用，我们一般都是在JS中控制播放和暂停） preload 设置当前音频文件预先加载的模式，默认值auto，代表开始加载页面的时候就把音频文件进行加载，metadata代表开始加载页面我们只加载一些最基础的信息，主体音频信息需要播放后才开始加载，none开始什么都不加载，都是等到播放后在开始加载（最常用） loop 播放完成后循环播放 Swiper插件的使用 swiper其实一个UI组件（也可以理解为JS插件），目的就是解决移动端滑屏操作的，例如：轮播图、屏幕滑动切换的场景应用等swiper官网]]></content>
      <categories>
        <category>移动端开发</category>
      </categories>
      <tags>
        <tag>移动端</tag>
        <tag>响应式布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LESS学习(一)——了解LESS+编译LESS]]></title>
    <url>%2F2019%2F02%2F25%2FLESS%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LESS的出现我们大家都知道HTML和CSS不属于编程语言而是属于标记语言，所以很难像JS一样定义变量、编写方法、实现模块化开发等。而目前的CSS编写模式中，都是定义一些公共的样式类名，哪一块的HTML需要这个样式，就去增加对应的样式类名，所以我们经常看到一个标签上存在很多样式类名，在这种模式中我们要时常关注CSS的优先级，避免样式的重叠覆盖... 为了解决CSS的这一困境，CSS预处理预编译的思想脱颖而出，比较具有代表性的有LESS、SASS、Stylus。它们在传统的CSS基础上增加了大量的新的语法，编写方式，常用的函数等，可以让我们的CSS像JS一样成为一门编程语言。基于LESS我么可以把一些经常用到的样式定义成变量或者函数，以后需要直接的调取使用即可，这样不仅有利于增加我们的开发速度，也有利于项目的后期维护与可复用性。 什么是LESS LESS是一门CSS预处理语言，它扩展了CSS语言，增加了变量、Mixin、函数等特性，使CSS更易维护和扩展。使用LESS基本上按照这样的步骤：编写LESS代码，使用NODE、JS或者是其他的工具把编写的LESS代码编译成我们平时看到的CSS代码(因为浏览器是无法解析LESS的语法的，所以编写完成的LESS代码需要进行编译)。 来看一个简单的案例： 在传统的CSS编写中，我们事先为一个盒子.box编写了一套样式，当鼠标滑过的时候，让盒子在原有样式的部分颜色值上发生改变，里面的DIV标签的阴影颜色变重，这样的话我们需要把之前的样式拿过来写一遍，只是调整一下透明度或者颜色值而已，页面中的冗余代码比较的多，也不方便后期的维护。 1234567891011121314151617.box&#123; color: #f938ab; border-color: #f938ab;&#125;.box div&#123; -webkit-box-shadow: 0 0 5px rgba(0, 0, 0, 0.3); box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);&#125;//-&gt;在:hover触发的时候需要把上述的样式copy一份,在原来的基础上改变部分颜色值和透明度.box:hover&#123; color: #fe33ac; border-color: #fe33ac;&#125;.box:hover div&#123; -webkit-box-shadow: 0 0 5px rgba(0, 0, 0, 0.5); box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);&#125; 如果我们使用的是LESS，那么我们可以节省很多的工作，也可以实现可扩展性和通用性，看下面的LESS代码：123456789101112131415161718192021222324252627282930313233343536//定义一个变量存储颜色值@color: #f938ab;/***你可以将它理解为JS中的一个函数*@style：表示一个形参*@alpha: 50% 表示一个形参，不传参时，默认是值50%**/.box-shadow(@style, @alpha: 50%)&#123; -webkit-box-shadow: @style rgba(0, 0, 0, @alpha); -moz-box-shadow: @style rgba(0, 0, 0, @alpha); -ms-box-shadow: @style rgba(0, 0, 0, @alpha); -o-box-shadow: @style rgba(0, 0, 0, @alpha); box-shadow: @style rgba(0, 0, 0, @alpha);&#125; .box&#123; color: @color; //使用变量 border-color: @color; //-&gt;嵌套:代表是 .box div div&#123; //调用方法 //0 0 5px为第一个参数赋值 //30%为第二个参数赋值 //参数之间用逗号隔开 box-shadow: box-shadow(0 0 5px, 30%); &#125; //-&gt;代表的是 .box:hover &amp;:hover&#123; //-&gt;saturate:LESS提供的颜色处理方法(还有很多其它的方法),用来调整颜色的饱和度变化 color: saturate(@color, 5%); border-color: saturate(@color, 5%); //-&gt;嵌套:代表是 .box:hover div div&#123; box-shadow: box-shadow(0 0 5px); &#125; &#125;&#125; 通过NODE编译后的结果为：12345678910111213141516171819202122.box&#123; color: #f938ab; border-color: #f938ab;&#125;.box div&#123; -webkit-box-shadow: 0 0 5px rgba(0, 0, 0, 0.3); -moz-box-shadow: 0 0 5px rgba(0, 0, 0, 0.3); -ms-box-shadow: 0 0 5px rgba(0, 0, 0, 0.3); -o-box-shadow: 0 0 5px rgba(0, 0, 0, 0.3); box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);&#125;.box:hover&#123; color: #fe33ac; border-color: #fe33ac;&#125;.box:hover div&#123; -webkit-box-shadow: 0 0 5px rgba(0, 0, 0, 0.5); -moz-box-shadow: 0 0 5px rgba(0, 0, 0, 0.5); -ms-box-shadow: 0 0 5px rgba(0, 0, 0, 0.5); -o-box-shadow: 0 0 5px rgba(0, 0, 0, 0.5); box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);&#125; 大家感受一下，是不是感觉LESS很强大，一方面不仅仅让我们少些了很多的代码，而且我们定义的变量或者“函数”具有很强的公用性，以后其他的结构需要这样的样式，我们直接的调取就好了。既然认识到了LESS的强大，那么我们接下来就一步步的学会LESS的使用 LESS的编译 上述我们提到，编写完成的LESS代码是不能直接在浏览器中运行的，需要编译成正常的CSS代码。那么我们首先就来学习一下常用的LESS编译方式。 1. 在浏览器中调用LESS.JS LESS只支持在现代浏览器中运行（最新版本的Chrome, Firefox, Safari 和 IE）。我们不建议在生产环境中使用LESS客户端，因为在将LESS编译成CSS的时候，用户会看到加载延迟的现象，即便在浏览器中有不足一秒的加载延迟，但也会降低性能. 首先引入我们设置样式的LESS文件，注意：这里的rel=&#39;stylesheet/less&#39;1&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet/less&quot; href=&quot;1.less&quot;/&gt; 其次为了方便开发过程中的调试(上线后我们也可以配置一些必要的参数)，我们可以在引入LESS.JS之前设置一些配置的参数。我们一般都把所有的配置参数放在全局变量less中。1234567891011121314151617181920212223242526//-&gt;在引入LESS之前设置一个全局的变量less,配置一些参数值(根据情况自行选择需要配置的项)var less = &#123; //-&gt;evn:设置运行的环境(生产模式还是开发模式) //production:编译后的CSS缓存到本地localStorage中 //development:没有把编译后的CSS缓存到本地,在URL不是标准的格式下(例如:file://...),自动设置为development env: "development", //-&gt;logLevel:javascript控制台日志量 logLevel: 2, //-&gt;async:同步或者异步导入文件,默认是false代表同步 async: false, //-&gt;fileAsync:使用文件协议访问页面时异步加载导入的文件,默认是false,如有需要设置为true fileAsync: false, //-&gt;poll:在监视模式下，每两次请求之间的时间间隔(ms),即不需要刷新页面，在到达指定的时间间隔之后，就可以在页面上看到最新的样式 poll: 1000, //-&gt;dumpLineNumbers:当设置dumpLineNumbers直接输出源行信息到编译好的CSS的文件中时，有利于你调试指定行。comments参数用于输出用户可以理解的内容，而mediaQuery使用Firefox一个扩展来解析CSS和抽取信息。 dumpLineNumbers: "comments", //-&gt;relativeUrls：是否调整相对路径。如果为false，则url已经是相对于入口的LESS文件。 relativeUrls: false&#125;;//-&gt;还有其它的参数,自己下去后可以再进行扩展 然后引入我们的less.js1&lt;script type=&quot;text/javascript&quot; src=&quot;less.js&quot;&gt; &lt;/script&gt; 最后开启监视模式后,只要我们的LESS改变，在一定时间内，浏览器就会重新的编译，我们可以看到想要的效果12//-&gt;启用监视模式(env必须要设置成development) less.watch(); ####2、使用NODE命令编译LESS 这种方式是目前项目中最常用的方式，也是我推荐大家使用的方式，它是把我们的LESS文件编译成CSS文件，我们项目中直接的引入CSS文件即可，基本步骤：安装-&gt;编译/压缩编译-&gt;或者使用NODE代码实现批量编译等 把LESS模块安装到全局NODE环境中1npm install less -g 使用命令进行编译12345//-&gt;把styles.less文件编译成styles.css文件(如果没有这个CSS文件自己会创建) lessc styles.less styles.css //-&gt;编译完成的CSS文件是经过压缩的 lessc styles.less styles.min.css -x或者--compress 如果你想要更牛X的压缩,还可以自己单独的设定,下面我们使用–clean-css。这个需要提前的安装less-plugin-clean-css模块才可以。12345 //-&gt;安装less-plugin-clean-cssnpm install -g less-plugin-clean-css //-&gt;安装成功后就可以使用它压缩了 lessc --clean-css styles.less styles.min.css 3、在NODE环境中编写批量编译的代码 我们在上述用NODE命令编译的时候，一次只能编译一个文件，这样，如果页面中有多个LESS，每一次编译都是比较耗费时间的，所以我们结合NODE的FS文件读写操作，可以写一套批量编译的代码。12345678910111213141516171819202122//-&gt;定义编译文件目录和目标导出目录 var dirPath = "./less/", tarPath = "./css/"; //-&gt;导入NODE中需要使用的模块 var fs = require("fs"), less = require("less"); //-&gt;读取dirPath中的所有文件,检查文件的类型,只有LESS文件我们才进行存储 var ary = [], files = fs.readdirSync(dirPath); files.forEach(function (file, index) &#123; /\.(LESS)/i.test(file) ? ary.push(file) : null; &#125;); //-&gt;把目录下的所有文件进行编译,把编译完成的结果保存在指定的目录中 ary.forEach(function (file) &#123; var newFile = file.replace(".less", ".css"), conFile = fs.readFileSync(dirPath + file, "utf-8"); less.render(conFile, &#123;compress: true&#125;, function (error, output) &#123; fs.writeFileSync(tarPath + newFile, output.css, "utf-8"); &#125;); &#125;); 4、使用工具编译LESS 目前常用的编译工具有：Koala(据说目前最流行的)、在线编译(http://tool.oschina.net/less)、SimpLESS等。关于工具的使用，自己下去下载研究即可，非常的简单，本篇文章不做过多的说明。 Koala下载链接]]></content>
      <categories>
        <category>移动端开发</category>
      </categories>
      <tags>
        <tag>less学习</tag>
        <tag>less基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LESS学习(二)——LESS的基础语法]]></title>
    <url>%2F2019%2F02%2F25%2FLESS%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[我们一起来学习一下LESS的基础语法，LESS的基础语法基本上分为以下几个方面：变量、混合(Mixins)、嵌套规则、运算、函数、作用域等。这些基础语法需要我们先牢牢的掌握住，然后才可以灵活的在项目中进行实战。 ###注释 //注释 注释的内容不会编译到css文件里面（编译时会自动过滤掉） /**/注释 注释的内容会编译到css文件里面 变量 和JS中的变量一样，只是LESS的变量定义不是使用VAR而是使用@。123456789101112//-&gt;LESS代码@link-color: #428bca;@link-color-hover: darken(@link-color, 10%);a &#123; color: @link-color; &amp;:hover &#123; color: @link-color-hover; &#125;&#125;.box &#123; color: @link-color;&#125; 12345678910//-&gt;编译为CSS的结果a &#123; color: #428bca;&#125;a:hover &#123; color: #3071a9;&#125;.box &#123; color: #428bca;&#125; 除了上述用变量存储公用的属性值，我们还可以用变量存储公用的URL、选择器等等12345678910111213141516//-&gt;LESS代码.@&#123;selector&#125; &#123; width: 100px; height: 100px; @&#123;property&#125;: #000; background: url("@&#123;bgImg&#125;/test.png"); &amp;:after &#123; display: block; content: @@var; &#125;&#125;@selector: box;@bgImg: "../img";@property: color;@name: "珠峰培训";@var: "name"; 1234567891011//-&gt;编译为CSS的结果.box &#123; width: 100px; height: 100px; color: #000; background: url("../img/test.png");&#125;.box:after &#123; display: block; content: "珠峰培训";&#125; 在上述的代码中我们发现，变量存储的值可以作为选择器，也可以作为样式属性名，同样也可以像类似于JS中字符串拼接的方式把变量值的和另外一个字符串进行拼接，而且@@var是把var变量存储的值作为另外一个变量的名从而获取对应的值。还有一点值的我们注意的是，变量可以定在使用代码的下面，这个有点类似于JS中的预解释，不管写在上面还是下面，都是相当于全局的变量，并且都可以把存储值获取到(但是建议大家把变量都统一在最上面定义)。 Mixin混合1、基本使用 从字面意思上理解，所谓的混合其实应该是把很多的样式混合在一起，这样理解不准确，个人的理解，所谓的混合其实是把某个选择器中的样式拿过来使用，我们看下面的代码。123456789//-&gt;LESS代码 .public &#123; width: 100px; height: 100px; &#125; nav ul &#123; .public; list-style: none; &#125; 12345678910//-&gt;编译为CSS的结果.public &#123; width: 100px; height: 100px;&#125;nav ul &#123; width: 100px; height: 100px; list-style: none;&#125; 观察上述的代码，我们发现其实nav ul是把public中设定的样式属性值copy了一份到自己的样式中。如果你想在编译完成的结果中不输出public这个样式的结果，只需要按照下述的代码编写即可：123456789//-&gt;LESS代码 .public() &#123;//-&gt;在选择器后面加上()就可以不编译这个样式了 width: 100px; height: 100px; &#125; nav ul &#123; .public; list-style: none; &#125; 123456//-&gt;编译为CSS的结果nav ul &#123; width: 100px; height: 100px; list-style: none;&#125; 2、Extend 虽然在上述的案例中，nav ul把public中的样式继承了过来，但是原理却是把代码copy一份过来，这样编译后的CSS中依然会存留大量的冗余CSS代码，为了避免这一点，我们可以使用extend伪类来实现样式的继承使用。123456789//-&gt;LESS代码.public &#123; width: 100px; height: 100px;&#125;nav ul &#123; &amp;:extend(.public); list-style: none;&#125; 12345678//-&gt;编译为CSS的结果.public, nav ul &#123; width: 100px; height: 100px;&#125;nav ul &#123; list-style: none;&#125; 或者：123456789//-&gt;LESS代码 .public &#123; width: 100px; height: 100px; &#125; nav ul:extend(.public) &#123; list-style: none; &#125; //-&gt;编译为CSS的结果和第一种写法一样 3、命名空间和作用域 在LESS的语法中，我们可以指定命名空间，实现在一个盒子中层级嵌套式的编写。下面案例中，.box就是命名空间，里面的img、.gray都是这个空间下的样式，调取的话需要.box &gt; .gray,&amp;代表它的上一层选择器。123456789101112131415161718192021//-&gt;LESS代码.box &#123; width: 100px; height: 100px; img &#123; width: 100%; height: 100%; &#125; .gray &#123; color: #eee; &#125; &amp;:hover &#123; background: green; &#125;&#125;#nav &#123; .box; //这里将.box的拿过来用，会将.box命名空间下的所有代码都拿过来用&#125;#header &#123; .box &gt; .gray; //调取.box下面的.gray样式&#125; 12345678910111213141516171819202122232425262728293031323334353637383940//-&gt;编译为CSS的结果.box &#123; width: 100px; height: 100px;&#125;.box img &#123; width: 100%; height: 100%;&#125;.box .gray &#123; color: #eee;&#125;.box:hover &#123; background: green;&#125;#nav &#123; width: 100px; height: 100px;&#125;#nav img &#123; width: 100%; height: 100%;&#125;#nav .gray &#123; color: #eee;&#125;#nav:hover &#123; background: green;&#125;#header &#123; color: #eee;&#125; 在LESS中定义了命名空间就创建了一个私有的作用域，在这个私有作用域中使用的变量都是先看一下自己作用域中有没有，没有的话，在向上一级查找（类似于JS的作用域链）。 1234567891011121314//-&gt;LESS代码@color: #ccc;.box &#123; @color: #eee; .gray &#123; color: @color; &#125;&#125;.box2 &#123; .gray &#123; color: @color; &#125;&#125; 12345678//-&gt;编译为CSS的结果.box .gray &#123; color: #eee;&#125;.box2 .gray &#123; color: #ccc;&#125; 4、!important 在调用的混合集后面追加 !important 关键字，可以使混合集里面的所有属性都继承 !important;123456789101112//-&gt;LESS代码 @color: #ccc; .box &#123; @color: #eee; .gray &#123; color: @color; &#125; &#125; nav ul &#123; .box !important; &#125; 12345678//-&gt;编译为CSS的结果.box .gray &#123; color: #eee;&#125;nav ul .gray &#123; color: #eee !important;&#125; 5、Parametric Mixins 如同JS一样，LESS也可以向函数一样设定形参数，这个技巧在我们的项目中会被经常的使用到，例如：处理CSS3的兼容问题123456789101112131415161718192021//-&gt;LESS代码//形参之间用分号隔开.transition(@property:all;@duration:1s;@function:linear;@delay:0s;) &#123; -webkit-transition: @property @duration @function @delay; -moz-transition: @property @duration @function @delay; -ms-transition: @property @duration @function @delay; -o-transition: @property @duration @function @delay; transition: @property @duration @function @delay;&#125;.box1 &#123; .transition;&#125;.box2 &#123; .transition(@duration: 2s); //给指定的形参赋值，可以不按照形参的顺序进行赋值&#125;.box3 &#123; .transition(@duration: 2s; @property: width;); //实参之间用分号隔开&#125; 123456789101112131415161718192021222324//-&gt;编译为CSS的结果.box1 &#123; -webkit-transition: all 1s linear 0s; -moz-transition: all 1s linear 0s; -ms-transition: all 1s linear 0s; -o-transition: all 1s linear 0s; transition: all 1s linear 0s;&#125;.box2 &#123; -webkit-transition: all 2s linear 0s; -moz-transition: all 2s linear 0s; -ms-transition: all 2s linear 0s; -o-transition: all 2s linear 0s; transition: all 2s linear 0s;&#125;.box3 &#123; -webkit-transition: width 2s linear 0s; -moz-transition: width 2s linear 0s; -ms-transition: width 2s linear 0s; -o-transition: width 2s linear 0s; transition: width 2s linear 0s;&#125; 此外我们需要值得注意的是，LESS中也有arguments。 123456789//-&gt;LESS代码 .transition(@property:all;@duration:1s;@function:linear;@delay:0s;) &#123;-webkit-transition: @arguments; //@arguments： arguments transition: @arguments;&#125;.box1 &#123; .transition;&#125; 12345//-&gt;编译为CSS的结果.box1 &#123; -webkit-transition: all 1s linear 0s; transition: all 1s linear 0s;&#125; 我们还可以把我们的变量像JS的函数一样操作，不仅仅有参数，还有返回值。 123456789//-&gt;LESS代码.average(@x, @y) &#123; @result: ((@x + @y) / 2); //这里将返回值赋值给变量@result&#125;div &#123; .average(16px, 50px); //调用方法 padding: @result; //使用返回值，必须先调用方法才可以使用它的返回值&#125; 1234//-&gt;编译为CSS的结果div &#123; padding: 33px;&#125; 6、Mixin Guards 我们可以在mixin中设置条件；常用的条件运算符：&gt;、&gt;=、&lt;、&lt;=、=；我们设定的条件还可以使用IS函数：iscolor、isnumber、isstring、iskeyword、isurl、ispixel、ispercentage…12345678910111213141516//-&gt;LESS代码.mixin (@a) when (lightness(@a) &gt;= 50%) &#123; //这里的when相当于js中的if,lightness还LESS内置方法 background-color: black;&#125;.mixin (@a) when (lightness(@a) &lt; 50%) &#123; background-color: white;&#125;.box1&#123; .mixin(#ddd);&#125;.box2&#123; .mixin(#555);&#125; 12345678//-&gt;编译为CSS的结果.box1 &#123; background-color: black;&#125;.box2 &#123; background-color: white;&#125; when是在设置条件，除了像上面的写法外，我们还可以通过when设置多个条件，而且条件中可以使用is函数。1234567//-&gt;LESS代码:使用IS函数.mixin (@a; @b: 0) when (isnumber(@b)) &#123; ... &#125;.mixin (@a; @b: black) when (iscolor(@b)) &#123; ... &#125;//-&gt;LESS代码:多条件，可以使用and或者逗号间隔.mixin (@a) when (isnumber(@a)) and (@a &gt; 0) &#123; ... &#125;.mixin (@a) when (isnumber(@a)) , (@a &gt; 0) &#123; ... &#125; 条件判断的另一种形式123456789101112131415161718192021222324252627282930313233//三角形案例//@_相当于一个通配符，不管传入的形参是什么，都会被匹配；//如果方法不止这一个参数，还是要保证该方法其他的参数满足条件才可.triangle(@_, @width, @color: red)&#123; width: 0; height: 0; overflow: hidden;&#125;//下面方法的第一个参数直接使用值做形参，可以不使用变量.triangle(top, @width, @color: red)&#123; //三角形朝上 border-width: @width; border-color: transparent transparent @color transparent; border-style: dashed dashed solid dashed;&#125;.triangle(bottom, @width, @color: red)&#123;//三角形朝下 border-width: @width; border-color: @color transparent transparent transparent; border-style: solid dashed dashed dashed;&#125;.triangle(left, @width, @color: red)&#123;//三角形朝左 border-width: @width; border-color: transparent @color transparent transparent; border-style: dashed solid dashed dashed;&#125;.triangle(right, @width, @color: red)&#123;//三角形朝右 border-width: @width; border-color: transparent transparent transparent @color; border-style: dashed dashed dashed solid;&#125;.box&#123; .triangle(top, 50px);&#125; 12345678.box &#123; width: 0; height: 0; overflow: hidden; border-width: 50px; border-color: transparent transparent #ff0000 transparent; border-style: dashed dashed solid dashed;&#125; 我们还可以通过与&amp;特性结合实现’if’类型的语句。123456//-&gt;LESS代码:这里的意思是如果为true,.box的文字颜色才是白色 @my-option: true; &amp; when (@my-option = true) &#123; .box &#123; color: white; &#125; 7、运算 任何数字、颜色或者变量都可以参与运算，运算应该被包裹在括号中，例如：+-*/1234@font_size: 12px;span&#123; font-size: @font_size + 2; //这里的数值2可以不带单位，只要两个运算数中有一个带单位，运算的结果会自动带上单位&#125; 8、避免编译 有时候我们需要输出一些不正确的css语法或者使用一些less不认识的我的专有语法，要输出这样的值，我们可以在字符串前加上一个~&#39;不需要编译的代码&#39;或者~&quot;不需要编译的代码&quot;123.box&#123; width: ~'calc(300px - 20px)';&#125; 编译之后的结果:123.box &#123; width: calc(280px);&#125; 避免编译之后的结果:123.box &#123; width: calc(300px - 20px);&#125; Loops(循环) 在Less中，混合可以调用它自身。这样，当一个混合递归调用自己，再结合Guard条件表达式，就可以写出循环结构。使用递归循环最常见的情况就是生成栅格系统的CSS：123456789//-&gt;LESS代码.generate-columns(4); //相当于在调用方法.generate-columns(@n, @i: 1) when (@i &lt;= @n) &#123; //循环体 .column-@&#123;i&#125; &#123; width: (@i * 100% / @n); &#125; .generate-columns(@n, (@i + 1)); //递归调用自身，改变@i&#125; 12345678910111213141516//-&gt;输出的CSS.column-1 &#123; width: 25%;&#125;.column-2 &#123; width: 50%;&#125;.column-3 &#123; width: 75%;&#125;.column-4 &#123; width: 100%;&#125; Merge(合并) Merge特性可以从多个属性中将值集合到某一个样式属性的列表中（也就是多样式效果）。在编写的时候，+代表以逗号分隔，+_代表多个之前以空格分隔。123456789101112131415161718//-&gt;LESS代码.mixin() &#123; box-shadow+: inset 0 0 10px #555;&#125;.myclass &#123; .mixin; box-shadow+: 0 0 20px black;&#125;.mixin2() &#123; transform+_: scale(2);&#125;.myclass2 &#123; .mixin2; transform+_: rotate(45deg);&#125; 12345678//-&gt;输出的CSS.myclass &#123; box-shadow: inset 0 0 10px #555, 0 0 20px black;&#125;.myclass2 &#123; transform: scale(2) rotate(45deg);&#125; Parent Selectors(父选择器) &amp;运算符其实就是让当前的选择器和父级选择器按照特定的规则进行连接，看下面的案例：1234567891011121314151617181920212223242526272829303132//-&gt;LESS代码.box &#123; color: blue; &amp;:hover &#123; color: green; &#125; &amp;-top &#123; height: 30px; &#125; &amp;-center &#123; height: 500px; &#125; //-&gt;多个&amp;&amp; &amp; + &amp;-top &#123; color: red; &#125; &amp; &amp;-top &#123; color: grey; &#125; &amp;&amp;-top &#123; color: black; &#125; &amp;, &amp;-top &#123; color: orange; &#125;&#125; 1234567891011121314151617181920212223242526272829303132//-&gt;输出的CSS.box &#123; color: blue;&#125;.box:hover &#123; color: green;&#125;.box-top &#123; height: 30px;&#125;.box-center &#123; height: 500px;&#125;.box + .box-top &#123; color: red;&#125;.box .box-top &#123; color: grey;&#125;.box.box-top &#123; color: black;&#125;.box, .box-top &#123; color: orange;&#125; 改变选择器顺序，下面的案例中，选择器.no-border-radius &amp;会前置插入它的父选择器.header .menu，最后变成.no-border-radius .header .menu形式输出：123456789//-&gt;LESS代码.header &#123; .menu &#123; border-radius: 5px; .no-border-radius &amp; &#123; background-image: url('images/button-background.png'); &#125; &#125;&#125; 1234567//-&gt;输出的CSS.header .menu &#123; border-radius: 5px;&#125;.no-border-radius .header .menu &#123; background-image: url('images/button-background.png'); Import Directives(导入指令) 从其他样式表中导入样式。12345678//-&gt;LESS代码@import "public.less"; //导入外部less文件.box &#123; &amp;:after &#123; .clear; &#125;&#125; 123456789101112131415//-&gt;输出的CSS:会把public中的样式也输出.clear &#123; display: block; height: 0; content: ""; clear: both; zoom: 1;&#125;.box:after &#123; display: block; height: 0; content: ""; clear: both; zoom: 1; 我们发现上述的操作虽然实现了调取使用，但是会把public中的less也编译到了自己的这个css中，如果不想编译的话，我们需要配置一些参数：12345678//-&gt;LESS代码 @import (reference) "public.less"; //不编译引入的less文件 .box &#123; &amp;:after &#123; .clear; &#125; &#125; 12345678//-&gt;输出的CSS:.box:after &#123; display: block; height: 0; content: ""; clear: both; zoom: 1;&#125; 除了reference以外我们还可以配置一些其他的参数值： inline：在输出中包含源文件但不加工它 less：将文件作为Less文件对象，无论是什么文件扩展名 css：将文件作为CSS文件对象，无论是什么文件扩展名 once：只包含文件一次（默认行为） multiple：包含文件多次]]></content>
      <categories>
        <category>移动端开发</category>
      </categories>
      <tags>
        <tag>less学习</tag>
        <tag>less基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LESS学习(三)——LESS中常用的方法]]></title>
    <url>%2F2019%2F02%2F25%2FLESS%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[杂项函数color 解析颜色，因此表示颜色的字符串变为颜色。 参数： string 指定颜色的字符串返回： color例：1color("#aaa"); 输出：1#aaa image-size 从文件中获取图像尺寸。 参数： string获取维度的文件。返回： dimension例：1image-size("file.png"); 输出：110px 10px 注意：此功能需要由每个环境实现。它目前仅在节点环境中可用。添加于：v2.2.0 image-width 从文件中获取图像宽度。 参数： string获取维度的文件。返回： dimension例：1image-width("file.png"); 输出： &gt;110px 注意：此功能需要由每个环境实现。它目前仅在节点环境中可用。添加于：v2.2.0 image-height 从文件中获取图像高度。 参数： string获取维度的文件。返回： dimension例：1image-height("file.png"); 输出： &gt;110px 注意：此功能需要由每个环境实现。它目前仅在节点环境中可用。添加于：v2.2.0 convert 将数字从一个单位转换为另一个单位。 第一个参数包含带有单位的数字，第二个参数包含单位。如果单位兼容，则转换该数字。如果它们不兼容，则第一个参数将不加修改地返回。兼容的单位组： 长度：m，cm，mm，in，pt和pc， 时间：s和ms， 角度：rad，deg，grad和turn。 参数： number：带单位的浮点数。 identifier，string或escaped value：单位 返回： number例：123convert(9s, "ms")convert(14cm, mm)convert(8, mm) // incompatible unit types 输出：1239000ms140mm8 data-uri url()如果ieCompat选项打开且资源太大，或者在浏览器中使用该函数，则内联资源并回退。如果未给出MIME类型，则node使用mime包来确定正确的mime类型。把我们需要使用的素材图片转换成BASE64编码，项目中尤其是移动端的项目，节省了图片的加载时间，是图片优化的一个手段；LESS对于大图片是不能转码的，我们可以使用BASE64工具进行转码(网站地址)，项目中慎用BASE64，当你在移动项目中，有一些大图实在是没有办法处理了的情况下，再使用BASE64； 参数： mimetype:(可选）MIME类型字符串。 url：要内联的文件的URL。 如果没有mimetype，data-uri函数会从文件名后缀中猜出它。文本和svg文件编码为utf-8，其他任何编码为base64。 如果用户提供了mimetype，则如果mimetype参数以; base64结尾，则该函数使用base64。例如，image/jpeg;base64编码为base64，同时text/html编码为utf-8。例：1data-uri('../data/image.jpg'); 输出：1url(&apos;data:image/jpeg;base64,bm90IGFjdHVhbGx5IGEganBlZyBmaWxlCg==&apos;); 浏览器输出：1url(&apos;../data/image.jpg&apos;); 例：1data-uri('image/jpeg;base64', '../data/image.jpg'); 输出：1url(&apos;data:image/jpeg;base64,bm90IGFjdHVhbGx5IGEganBlZyBmaWxlCg==&apos;); 例：1data-uri('image/svg+xml;charset=UTF-8', 'image.svg'); 输出：1url(&quot;data:image/svg+xml;charset=UTF-8,%3Csvg%3E%3Ccircle%20r%3D%229%22%2F%3E%3C%2Fsvg%3E&quot;); default 仅在保护条件内可用，并且true仅在没有其他mixin匹配时返回，false否则返回。例：1234567891011.mixin(1) &#123;x: 11&#125;.mixin(2) &#123;y: 22&#125;.mixin(@x) when (default()) &#123;z: @x&#125;div &#123; .mixin(3);&#125;div.special &#123; .mixin(1);&#125; 输出：123456div &#123; z: 3;&#125;div.special &#123; x: 11;&#125; 可以使用default保护运算符返回的值。例如，.mixin() when not(default()) {}只有在至少有一个匹配.mixin()调用的mixin定义时才会匹配：例:1234567891011.mixin(@value) when (ispixel(@value)) &#123;width: @value&#125;.mixin(@value) when not(default()) &#123;padding: (@value / 5)&#125;div-1 &#123; .mixin(100px);&#125;div-2 &#123; /* ... */ .mixin(100%);&#125; 结果：1234567div-1 &#123; width: 100px; padding: 20px;&#125;div-2 &#123; /* ... */&#125; 允许default()在相同的保护条件下或在具有相同名称的mixin的不同条件下进行多次调用：123456div &#123; .m(@x) when (default()), not(default()) &#123;always: @x&#125; .m(@x) when (default()) and not(default()) &#123;never: @x&#125; .m(1); // OK&#125; 但是，如果使用以下方法检测到多个mixin定义之间可能存在冲突，Less会抛出错误default()：123456div &#123; .m(@x) when (default()) &#123;&#125; .m(@x) when not(default()) &#123;&#125; .m(1); // Error&#125; 在上面的例子中，不可能确定每个default()调用应该返回什么值，因为它们递归地相互依赖。 高级多用途default()：12345678910111213.x &#123; .m(red) &#123;case-1: darkred&#125; .m(blue) &#123;case-2: darkblue&#125; .m(@x) when (iscolor(@x)) and (default()) &#123;default-color: @x&#125; .m('foo') &#123;case-1: I am 'foo'&#125; .m('bar') &#123;case-2: I am 'bar'&#125; .m(@x) when (isstring(@x)) and (default()) &#123;default-string: and I am the default&#125; &amp;-blue &#123;.m(blue)&#125; &amp;-green &#123;.m(green)&#125; &amp;-foo &#123;.m('foo')&#125; &amp;-baz &#123;.m('baz')&#125;&#125; 结果：123456789101112.x-blue &#123; case-2: #00008b;&#125;.x-green &#123; default-color: #008000;&#125;.x-foo &#123; case-1: I am 'foo';&#125;.x-baz &#123; default-string: and I am the default;&#125; 该default功能仅在保护表达式内作为Less内置函数提供。如果在mixin保护条件之外使用，则将其解释为常规CSS值： 例1234div &#123; foo: default(); bar: default(42);&#125; 结果：1234div &#123; foo: default(); bar: default(42);&#125; unit 删除或更改维度的单位 参数： dimension：一个数字，有或没有维度。 unit:(可选）要更改的单位，或者如果省略则删除单位。 例：1unit(5, px) 输出：15px 例：1unit(5em) 输出：15 get-unit 返回数字的单位。 如果参数包含带单位的数字，则函数返回其单位。没有单位的参数会导致返回空值。参数： number：带或不带单位的数字。 例：1get-unit(5px) 输出：1px 例：1get-unit(5) 输出：1//nothing 字符串函数escape 将URL编码应用于输入字符串中的特殊字符 这些字符不编码：,，/，?，@，&amp;，+，&#39;，~，!和$。最常见的编码的字符：\&lt;space\&gt;，#，^，(，)，{，}，|，:，&gt;，&lt;，;，]，[和=。参数： string要转义的字符串。 返回： string没有引号的转义内容。 例：1escape('a=1') 输出：1a%3D1 注意：如果参数不是字符串，则不定义输出。当前实现返回undefined任何其他类型的参数的颜色和未更改的输入。不应依赖此行为，并且可能在将来更改。 e CSS转义，替换为~”value”语法。 它期望string作为参数并按原样返回其内容，但不带引号。它可以用于输出CSS值，该值不是有效的CSS语法，或者使用Less无法识别的专有语法。 参数： string- 要转义的字符串。 返回： string- 转义字符串，不带引号。 例：1filter: e("ms:alwaysHasItsOwnSyntax.For.Stuff()"); 输出：1filter: ms:alwaysHasItsOwnSyntax.For.Stuff(); 注意：该函数还接受~&quot;&quot;转义值和数字作为参数。其他任何东西都会返回错误。 % format 该函数%(string, arguments …)格式化一个字符串。 第一个参数是带占位符的字符串。所有占位符与百分号开始%，然后字母s，S，d，D，a，或A。剩余的参数包含替换占位符的表达式。如果您需要打印百分比符号，请将其转义另一个百​​分比%%。 如果需要将特殊字符转义为其utf-8转义码，请使用大写占位符。该函数转义除了以外的所有特殊字符()&#39;~!。空间编码为%20。小写占位符保留特殊字符。 占位符： d，D，a，A-可以通过任何类型的参数来代替（颜色，号码，转义值，表达，…）。如果将它们与字符串结合使用，将使用整个字符串 - 包括其引号。但是，引号按原样放入字符串中，它们不会被“/”转义，也不会被类似的转义。 s，S- 可以被任何表达式替换。如果将它与字符串一起使用，则仅使用字符串值 - 省略引号。 参数： string：带有占位符的格式字符串， anything*：替换占位符的值。 返回： 格式化string。 例：1234format-a-d: %("repetitions: %a file: %d", 1 + 2, "directory/file.less");format-a-d-upper: %('repetitions: %A file: %D', 1 + 2, "directory/file.less");format-s: %("repetitions: %s file: %s", 1 + 2, "directory/file.less");format-s-upper: %('repetitions: %S file: %S', 1 + 2, "directory/file.less"); 输出：1234format-a-d: "repetitions: 3 file: "directory/file.less"";format-a-d-upper: "repetitions: 3 file: %22directory%2Ffile.less%22";format-s: "repetitions: 3 file: directory/file.less";format-s-upper: "repetitions: 3 file: directory%2Ffile.less"; replace 替换字符串中的文本。 参数： string：要搜索和替换的字符串。 pattern：要搜索的字符串或正则表达式模式。 replacement：用于替换匹配模式的字符串。 flags:(可选）正则表达式标志。 返回： 包含替换值的字符串。 例：1234replace("Hello, Mars?", "Mars\?", "Earth!");replace("One + one = 4", "one", "2", "gi");replace('This is a string.', "(string)\.$", "new $1.");replace(~"bar-1", '1', '2'); 结果：1234&quot;Hello, Earth!&quot;;&quot;2 + 2 = 4&quot;;&apos;This is a new string.&apos;;bar-2; 列表函数length 返回值列表中的元素数 参数： list- 以逗号或空格分隔的值列表。 返回： 列表中的整数个元素 例：1length(1px solid #0080ff); 输出：13 例：12@list: "banana", "tomato", "potato", "peach";n: length(@list); 输出：1n: 4; extract 返回列表中指定位置的值。 参数： list- 以逗号或空格分隔的值列表。 index - 一个整数，指定要返回的列表元素的位置[从1开始]。 返回： 列表中指定位置的值。 例：1extract(8px dotted red, 2); 输出：1dotted 例：12@list: apple, pear, coconut, orange;value: extract(@list, 3); 输出：1value: coconut; 数学函数ceil 上升到下一个最高整数，向上取整。 参数： number- 浮点数。 返回： integer 例：1ceil(2.4) 输出：13 floor 向下舍入到下一个最小整数，向下取整。 参数： number- 浮点数。 返回： integer 例：1floor(2.6) 输出：12 percentage 将浮点数转换为百分比字符串。 参数： number- 浮点数。 返回： string 例：1percentage(0.5) 输出：150% round 适用四舍五入。 参数： number：浮点数。 decimalPlaces：可选：要舍入的小数位数。默认为0。 返回： number 例：1round(1.67) 输出：12 例：1round(1.67, 1) 输出：11.7 sqrt 计算数字的平方根。保持单位不变。 参数： number- 浮点数。 返回： number 例：1sqrt(25cm) 输出：15cm 例：1sqrt(18.6%) 输出：14.312771730569565%; abs 计算数字的绝对值。保持单位不变。 参数： number- 浮点数。 返回： number 例：1abs(25cm) 输出：125cm 例：1abs(-18.6%) 输出：118.6%; sin 计算正弦函数。 假设没有单位的数字的弧度。 参数： number- 浮点数。 返回： number 例：123sin(1); // sine of 1 radiansin(1deg); // sine of 1 degreesin(1grad); // sine of 1 gradian 输出：1230.8414709848078965; // sine of 1 radian0.01745240643728351; // sine of 1 degree0.015707317311820675; // sine of 1 gradian asin 计算反正弦（正弦反函数）函数。 以弧度为单位返回数字，例如-π/2和之间的数字π/2。 参数： number- [-1, 1]间隔的浮点数。 返回： number 例：123asin(-0.8414709848078965)asin(0)asin(2) 输出：123-1rad0radNaNrad cos 计算余弦函数。 假设没有单位的数字的弧度。 参数： number- 浮点数。 返回： number 例：123cos(1) // cosine of 1 radiancos(1deg) // cosine of 1 degreecos(1grad) // cosine of 1 gradian 输出：1230.5403023058681398 // cosine of 1 radian0.9998476951563913 // cosine of 1 degree0.9998766324816606 // cosine of 1 gradian acos 计算反余弦（余弦的倒数）函数。 以弧度为单位返回数字，例如0到π之间的数字。 参数： number- [-1,1]间隔的浮点数。 返回： number 例：123acos(0.5403023058681398)acos(1)acos(2) 输出：1231rad0radNaNrad tan 计算切线函数。 假设没有单位的数字的弧度。 参数： number- 浮点数。 返回： number 例：123tan(1) // tangent of 1 radiantan(1deg) // tangent of 1 degreetan(1grad) // tangent of 1 gradian 输出：1231.5574077246549023 // tangent of 1 radian0.017455064928217585 // tangent of 1 degree0.015709255323664916 // tangent of 1 gradian atan 计算反正切（反正切）函数。 以弧度为单位返回数字，例如-π/2和之间的数字π/2。 参数： number- 浮点数。 返回： number 例：123atan(-1.5574077246549023)atan(0)round(atan(22), 6) // arctangent of 22 rounded to 6 decimal places 输出：123-1rad0rad1.525373rad; pi 返回π（pi）; 参数： none 返回： number 例：1pi() 输出：13.141592653589793 pow 返回第一个参数的值，该值是第二个参数的幂。 返回值与第一个参数具有相同的维度，并忽略第二个参数的维度。 参数： number：base -a浮点数。 number：exponent - 浮点数。 返回： number 例：12345pow(0cm, 0px)pow(25, -2)pow(25, 0.5)pow(-25, 0.5)pow(-25%, -0.5) 输出：123451cm0.00165NaNNaN% mod 返回第一个参数模数第二个参数的值。 返回值与第一个参数具有相同的维度，忽略第二个参数的维度。该函数还能够处理负点和浮点数。 参数： number：浮点数。 number：浮点数。 返回： number 例：123mod(0cm, 0px)mod(11cm, 6px);mod(-26%, -5); 输出：123NaNcm;5cm-1%; min 返回一个或多个值中的最小值。 参数： value1, ..., valueN- 要比较的一个或多个值。 返回： 最低值。 例：1min(5, 10); 输出：15 例：1min(3px, 42px, 1px, 16px); 输出：11px max 返回一个或多个值中的最高值。 参数： value1, ..., valueN- 要比较的一个或多个值。 返回： 最高值。 例：1max(5, 10); 输出：110 例：1max(3%, 42%, 1%, 16%); 输出：142% 类型函数isnumber 如果值是数字则返回true，否则返回false。 参数： value- 要评估的值或变量。 返回： 如果值是数字则返回true，否则返回false。 例：12345678isnumber(#ff0); // falseisnumber(blue); // falseisnumber("string"); // falseisnumber(1234); // trueisnumber(56px); // trueisnumber(7.8%); // trueisnumber(keyword); // falseisnumber(url(...)); // false isstring 如果值是字符串则返回true，否则返回false。 参数： value- 要评估的值或变量。 返回： 如果值是字符串则返回true，否则返回false。 例：12345678isstring(#ff0); // falseisstring(blue); // falseisstring("string"); // trueisstring(1234); // falseisstring(56px); // falseisstring(7.8%); // falseisstring(keyword); // falseisstring(url(...)); // false iscolor 如果值是颜色则返回true，否则返回false。 参数： value- 要评估的值或变量。 返回： 如果值是颜色则返回true，否则返回false。 例：12345678iscolor(#ff0); // trueiscolor(blue); // trueiscolor("string"); // falseiscolor(1234); // falseiscolor(56px); // falseiscolor(7.8%); // falseiscolor(keyword); // falseiscolor(url(...)); // false iskeyword 如果值是关键字则返回true，否则返回false。 参数： value- 要评估的值或变量。 返回： 如果值是关键字则返回true，否则返回false。 例：12345678iskeyword(#ff0); // falseiskeyword(blue); // falseiskeyword("string"); // falseiskeyword(1234); // falseiskeyword(56px); // falseiskeyword(7.8%); // falseiskeyword(keyword); // trueiskeyword(url(...)); // false isurl 如果值是url则返回true，否则返回false。 参数： value- 要评估的值或变量。 返回： 如果值是url则返回true，否则返回false。 例：12345678isurl(#ff0); // falseisurl(blue); // falseisurl("string"); // falseisurl(1234); // falseisurl(56px); // falseisurl(7.8%); // falseisurl(keyword); // falseisurl(url(...)); // true ispixel 如果值是以像素为单位的数字则返回true，否则返回false。 参数： value- 要评估的值或变量。 返回： 如果值是像素则返回true，否则返回false。 例：12345678ispixel(#ff0); // falseispixel(blue); // falseispixel("string"); // falseispixel(1234); // falseispixel(56px); // trueispixel(7.8%); // falseispixel(keyword); // falseispixel(url(...)); // false isem 如果值是em值则返回true，否则返回false。 参数： value- 要评估的值或变量。 返回： 如果值是em值则返回true，否则返回false。 例：12345678isem(#ff0); // falseisem(blue); // falseisem("string"); // falseisem(1234); // falseisem(56px); // falseisem(7.8em); // trueisem(keyword); // falseisem(url(...)); // fal ispercentage 如果值是百分比值则返回true，否则返回false。 参数： value- 要评估的值或变量。 返回： 如果值是百分比值字则返回true，否则返回false。 例：12345678ispercentage(#ff0); // falseispercentage(blue); // falseispercentage("string"); // falseispercentage(1234); // falseispercentage(56px); // falseispercentage(7.8%); // trueispercentage(keyword); // falseispercentage(url(...)); // false isunit 如果值是指定单位的数字则返回true，否则返回false。 参数： value- 要评估的值或变量。 unit - 要测试的单位标识符（可选择引用）。 返回： 如果值是指定单位的数字则返回true，否则返回false。 例：123456789isunit(11px, px); // trueisunit(2.2%, px); // falseisunit(33px, rem); // falseisunit(4rem, rem); // trueisunit(56px, "%"); // falseisunit(7.8%, '%'); // trueisunit(1234, em); // falseisunit(#ff0, pt); // falseisunit("mm", mm); // false isruleset 如果值是规则集则返回true，否则返回false。 参数： value- 要评估的值或变量。 返回： 如果值是规则集则返回true，否则返回false。 例：12345678910111213@rules: &#123; color: red;&#125;isruleset(@rules); // trueisruleset(#ff0); // falseisruleset(blue); // falseisruleset("string"); // falseisruleset(1234); // falseisruleset(56px); // falseisruleset(7.8%); // falseisruleset(keyword); // falseisruleset(url(...)); // false 颜色定义函数rgb 从十进制红色，绿色和蓝色（RGB）值创建不透明的颜色对象。 例如，标准HTML / CSS格式的文字颜色值也可用于定义颜色#ff0000。 参数： red：整数0-255或百分比0-100％。 green：整数0-255或百分比0-100％。 blue：整数0-255或百分比0-100％。 返回： color 例：1rgb(90, 129, 32) 输出：1#5a8120 rgba 从十进制红色，绿色，蓝色和alpha（RGBA）值创建透明颜色对象。 参数： red：整数0-255或百分比0-100％。 green：整数0-255或百分比0-100％。 blue：整数0-255或百分比0-100％。 alpha：数字0-1或百分比0-100％。 返回： color 例：1rgba(90, 129, 32, 0.5) 输出：1rgba(90, 129, 32, 0.5) argb 以#AARRGGBB格式（不是 #RRGGBBAA！）创建颜色的十六进制表示。 参数： color：颜色对象。 返回： string 例：1argb(rgba(90, 23, 148, 0.5)); 输出：1#805a1794 hsl 根据色调，饱和度和亮度（HSL）值创建不透明的颜色对象。 参数： hue：表示度数的0-360整数。 saturation：百分比0-100％或数字0-1。 lightness：百分比0-100％或数字0-1。 返回： color 例：1hsl(90, 100%, 50%) 输出：1#80ff00 如果您想基于另一种颜色的通道创建新颜色，这非常有用，例如： @new: hsl(hue(@old), 45%, 90%); @new会有自己@old的色调，还有自己的饱和感和轻盈感。 hsla 根据色调，饱和度，亮度和alpha（HSLA）值创建透明颜色对象。 参数： hue：表示度数的0-360整数。 saturation：百分比0-100％或数字0-1。 lightness：百分比0-100％或数字0-1。 alpha：百分比0-100％或数字0-1。返回： color 例：1hsl(90, 100%, 50%, 0.5) 输出：1rgba(128, 255, 0, 0.5) hsv 根据色调，饱和度和值（HSV）值创建不透明的颜色对象。 请注意，这是Photoshop中可用的颜色空间，与…不同hsl。 参数： hue：表示度数的0-360整数。 saturation：百分比0-100％或数字0-1。 value：百分比0-100％或数字0-1。返回： color 例：1hsv(90, 100%, 50%) 输出：1#408000 hsva 根据色调，饱和度，值和alpha（HSVA）值创建透明颜色对象。 参数： hue：表示度数的0-360整数。 saturation：百分比0-100％或数字0-1。 value：百分比0-100％或数字0-1。 alpha：百分比0-100％或数字0-1。返回： color 例：1hsva(90, 100%, 50%, 0.5) 输出：1rgba(64, 128, 0, 0.5) 颜色操作函数颜色操作通常采用与其更改值相同的单位参数，百分比作为绝对值处理，因此将10％值增加10％会产生20％。将选项方法参数设置为相对百分比的相对值。当使用相对百分比时，10％的值增加10％，结果为11％。值被限制在允许的范围内; 他们没有环绕。在显示返回值的地方，除了通常使用的十六进制版本之外，我们还使用了能够清楚地表明每个函数已完成的内容的格式。 saturate 以绝对量增加HSL颜色空间中颜色的饱和度。 参数： color：一个颜色对象。 amount：百分比0-100％。 method：可选，设置relative为使调整相对于当前值。 返回： color 例：1saturate(hsl(90, 80%, 50%), 20%) 输出：1#80ff00 // hsl(90, 100%, 50%) desaturate 降低HSL颜色空间中颜色的饱和度绝对量。 参数： color：一个颜色对象。 amount：百分比0-100％。 method：可选，设置relative为使调整相对于当前值。 返回： color 例：1desaturate(hsl(90, 80%, 50%), 20%) 输出：1#80cc33 // hsl(90, 60%, 50%) lighten 以绝对量增加HSL颜色空间中颜色的亮度。 参数： color：一个颜色对象。 amount：百分比0-100％。 method：可选，设置relative为使调整相对于当前值。 返回： color 例：1lighten(hsl(90, 80%, 50%), 20%) 输出：1#b3f075 // hsl(90, 80%, 70%) darken 以绝对量减少HSL颜色空间中颜色的亮度。 参数： color：一个颜色对象。 amount：百分比0-100％。 method：可选，设置relative为使调整相对于当前值。 返回： color 例：1darken(hsl(90, 80%, 50%), 20%) 输出：1#4d8a0f // hsl(90, 80%, 30%) fadein 降低颜色的透明度（或增加不透明度），使其更不透明。 对不透明的颜色没有影响。要在另一个方向淡出使用fadeout。 参数： color：一个颜色对象。 amount：百分比0-100％。 method：可选，设置relative为使调整相对于当前值。 返回： color 例：1fadein(hsla(90, 90%, 50%, 0.5), 10%) 输出：1rgba(128, 242, 13, 0.6) // hsla(90, 90%, 50%, 0.6) fadeout 增加颜色的透明度（或降低不透明度），使其不透明。要在另一个方向淡出使用fadein。 参数： color：一个颜色对象。 amount：百分比0-100％。 method：可选，设置relative为使调整相对于当前值。 返回： color 例：1fadeout(hsla(90, 90%, 50%, 0.5), 10%) 输出：1rgba(128, 242, 13, 0.4) // hsla(90, 90%, 50%, 0.4) fade 设置颜色的绝对透明度。可以应用于颜色，无论它们是否已具有不透明度值。 参数： color：一个颜色对象。 amount：百分比0-100％。 返回： color 例：1fade(hsl(90, 90%, 50%), 10%) 输出：1rgba(128, 242, 13, 0.1) //hsla(90, 90%, 50%, 0.1)]]></content>
      <categories>
        <category>移动端开发</category>
      </categories>
      <tags>
        <tag>less学习</tag>
        <tag>less基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String原型上的方法以及属性详细讲解(一)]]></title>
    <url>%2F2019%2F02%2F18%2FString%E5%8E%9F%E5%9E%8B%E4%B8%8A%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[属性constructor: ƒ String() { [native code] } 属性： 是一个属性含义： 返回创建实例对象的 ==String ==构造函数的引用备注： 每一个对象所属类的原型上都有一个constructor属性，属性值是当前对象所属类（函数）的本身 此属性的值是当前对象所属类（函数）本身的引用，而不是一个包含函数名称的字符串。 返回值： 当前对象所属类（函数）[String]的本身 运用：1console.log("hello".constructor); =&gt; ƒ String() &#123; [native code] &#125; length: 属性：是一个属性含义: 表示原始字符串的长度备注： 如果原始字符串为空字符串，则==length==的值为0 静态属性的length为1 返回值：原始字符串的长度运用：123console.log("hello".length); =&gt; 5console.log("".length); =&gt; 0console.log(String.length); =&gt; 1 为原始字符串包裹一个标签（并添加某个属性）anchor: f anchor(name) 属性： 是一个方法含义： 在字符串的外面包裹一个&lt;a&gt;标签，并为&lt;a&gt;标签添加==name==属性参数： 0到多个任意类型的值 含义：&lt;a&gt;标签的name属性值 备注： 该方法会自动将参数装换为string类型，利用toString()方法，因此它接收任意类型的参数 如果没有为该方法传参，则&lt;a&gt;标签的name属性就为undefined 备注： 当方法有多个参数时，只有第一参数才是有效参数，后面的参数都是无效的返回值： 一个&lt;a&gt;标签字符串，只含有name属性，中间包裹的文字是原始字符串 “&lt;a name=&quot;参数&quot;&gt;原始字符串&lt;/a&gt;“: 原始字符串 运用：123console.log(typeof "zhuxiaolu".anchor("tempA") === "string"); -&gt; trueconsole.log("zhuxiaolu".anchor()); -&gt; &lt;a name="undefined"&gt;zhuxiaolu&lt;/a&gt;console.log("zhuxiaolu".anchor("tempA")); -&gt; &lt;a name="tempA"&gt;zhuxiaolu&lt;/a&gt; link: f link(url) 属性： 是一个方法含义： 在字符串的外面包裹一个&lt;a&gt;标签，并为&lt;a&gt;标签添加==href==属性参数： 指向另一个 URL 的超链接, 即&lt;a&gt;标签的href属性值 注意： 任何能够指定 &lt;a&gt;标签的 href 属性的字符串；它应当是有效的 URL（相对或绝对）； 任何 &amp; 字符将会被转义为 &amp;amp;，任何 “ 字符将会被转义为 &amp;quot;。 如果没有为该方法传参，则&lt;a&gt;标签的href属性就为undefined 该方法会自动将参数装换为string类型，利用toString()方法，因此它接收任意类型的参数 备注： 当方法有多个参数时，只有第一参数才是有效参数，后面的参数都是无效的返回值： 一个标签字符串，只含有href属性，中间包裹的文字是原始字符串 “&lt;a href=&quot;参数&quot;&gt;原始字符串&lt;/a&gt;“：原始字符串运用：123console.log(typeof "hello".link("www.baidu.com") === "string"); -&gt; true console.log("hello".link()); -&gt; &lt;a href="undefined"&gt;hello&lt;/a&gt; console.log("hello".link("www.baidu.com")); -&gt; &lt;a href="www.baidu.com"&gt;hello&lt;/a&gt; big: f big() 属性： 是一个方法含义： 在字符串的外面包裹一个&lt;big&gt;标签参数： 无备注： &lt;big&gt;标签呈现大号字体效果返回值： 一个big标签字符串，中间包裹的文字是原始字符串 “&lt;big&gt;原始字符串&lt;/big&gt;“：原始字符串 运用：12console.log(typeof "hello".big() === "string"); -&gt; trueconsole.log("hello".big()); -&gt; &lt;big&gt;hello&lt;/big&gt; small: f small) 属性： 是一个方法含义： 在字符串的外面包裹一个&lt;small&gt;标签参数： 无备注： &lt;small&gt;标签呈现小号字体效果返回值： 一个标签字符串，中间包裹的文字是原始字符串 “&lt;small&gt;原始字符串&lt;/small&gt;“：原始字符串 运用：12console.log(typeof "hello".small() === "string"); -&gt; trueconsole.log("hello".small()); -&gt; &lt;small&gt;hello&lt;/small&gt; blink: f blink() 属性： 是一个方法含义： 在字符串的外面包裹一个&lt;blink&gt;标签参数： 无返回值： 一个blink标签字符串，中间包裹的文字是原始字符串 “&lt;blink&gt;原始字符串&lt;/blink&gt;“：原始字符串 备注： blink标签的语义：定义在浏览器显示闪烁的文本。html5不再支持，此标签被废弃。运用：12console.log(typeof "hello".blink() === "string"); -&gt; trueconsole.log("hello".blink()); -&gt; &lt;blink&gt;hello&lt;/blink&gt; bold: f bold() 属性： 是一个方法含义： 在字符串的外面包裹一个&lt;b&gt;标签参数： 无备注： 标签是一个加粗文本返回值： 一个&lt;b&gt;标签字符串，中间包裹的文字是原始字符串 “&lt;b&gt;原始字符串&lt;/b&gt;“：原始字符串运用：12console.log(typeof "hello".bold() === "string"); -&gt; trueconsole.log("hello".bold()); -&gt; &lt;b&gt;hello&lt;/b&gt; fixed: f fixed() 属性： 是一个方法含义： 创建了一个&lt;tt&gt;标签元素将字符串包裹起来, 从而让这个字符串里面的内容具有固定间距。参数： 无备注： &lt;tt&gt;标签定义打字机文本，HTML5不支持&lt;tt&gt;标签。请用CSS代替。返回值： 一个&lt;tt&gt;标签字符串，中间包裹的文字是原始字符串 “&lt;tt&gt;原始字符串&lt;/tt&gt;“：原始字符串运用：12console.log(typeof "hello".fixed() === "string"); -&gt; trueconsole.log("hello".fixed()); =&gt; &lt;tt&gt;hello&lt;/tt&gt; strike: f strike() 属性： 是一个方法含义： 创建了一个&lt;strike&gt;标签元素将字符串包裹起来, 从而让这个字符串里面的内容具有固定间距。参数： 无备注： &lt;strike&gt;使字符串展示为被删除的文本。HTML5不支持&lt;strike&gt;标签。请用CSS代替。返回值： 一个&lt;strike&gt;标签字符串，中间包裹的文字是原始字符串 “&lt;strike&gt;原始字符串&lt;/strike&gt;“: 原始字符串运用：12console.log(typeof "hello".strike() === "string"); -&gt; trueconsole.log("hello".strike()); =&gt; &lt;strike&gt;hello&lt;/strike&gt; sub: f sub() 属性： 是一个方法含义： 创建了一个&lt;sub&gt;标签元素将字符串包裹起来, 从而让这个字符串里面的内容具有固定间距。参数： 无备注： &lt;sub&gt;使字符串展示为下标。HTML5不支持&lt;sub&gt;标签。请用CSS代替。返回值： 一个&lt;sub&gt;标签字符串，中间包裹的文字是原始字符串 “&lt;sub&gt;原始字符串&lt;/sub&gt;“: 原始字符串运用：12console.log(typeof "hello".sub() === "string"); -&gt; trueconsole.log("hello".sub()); =&gt; &lt;sub&gt;hello&lt;/sub&gt; sub: f sup() 属性： 是一个方法含义： 创建了一个&lt;sub&gt;标签元素将字符串包裹起来, 从而让这个字符串里面的内容具有固定间距。参数： 无备注： &lt;sub&gt;使字符串展示为下标。HTML5不支持&lt;sub&gt;标签。请用CSS代替。返回值： 一个&lt;sub&gt;标签字符串，中间包裹的文字是原始字符串 “&lt;sub&gt;原始字符串&lt;/sub&gt;“: 原始字符串运用：12console.log(typeof "hello".sub() === "string"); -&gt; trueconsole.log("hello".sub()); =&gt; &lt;sub&gt;hello&lt;/sub&gt; fontcolor: f fontcolor(color) 属性： 是一个方法含义： 在字符串的外面包裹一个&lt;font&gt;标签，并为&lt;font&gt;标签添加==color==属性参数： 0到多个任意类型的值 含义：&lt;font&gt;标签的color属性值 备注： 该方法会自动将参数装换为string类型，利用toString()方法，因此它接收任意类型的参数 如果没有为该方法传参，则&lt;font&gt;标签的color属性就为undefined 备注： 当方法有多个参数时，只有第一参数才是有效参数，后面的参数都是无效的返回值： 一个&lt;font&gt;标签字符串，只含有color属性，中间包裹的文字是原始字符串 “&lt;font color=&quot;参数&quot;&gt;原始字符串&lt;/font&gt;“ 运用：1234console.log(typeof "hello".fontcolor("font") === "string"); =&gt; true console.log("hello".fontcolor()); =&gt; &lt;font color="undefined"&gt;hello&lt;/font&gt; console.log("hello".fontcolor("font1 font2")); =&gt; &lt;font color="font1 font2"&gt;hello&lt;/font&gt; console.log("hello".fontcolor("font1", " font2")); =&gt; &lt;font color="font1"&gt;hello&lt;/font&gt; fontsize: f fontsize(size) 属性： 是一个方法含义： 在字符串的外面包裹一个&lt;font&gt;标签，并为&lt;font&gt;标签添加==size==属性参数： 0到多个任意类型的值 含义：&lt;font&gt;标签的size属性值 备注： 该方法会自动将参数装换为string类型，利用toString()方法，因此它接收任意类型的参数 如果没有为该方法传参，则&lt;font&gt;标签的size属性就为undefined 备注： 当方法有多个参数时，只有第一参数才是有效参数，后面的参数都是无效的返回值： 一个&lt;font&gt;标签字符串，只含有size属性，中间包裹的文字是原始字符串 “&lt;font size=&quot;参数&quot;&gt;原始字符串&lt;/font&gt;“ 运用：1234console.log(typeof "hello".fontsize("font") === "string"); =&gt; trueconsole.log("hello".fontsize()); =&gt; &lt;font szie="undefined"&gt;hello&lt;/font&gt;console.log("hello".fontsize("font1 font2")); =&gt; &lt;font szie="font1 font2"&gt;hello&lt;/font&gt;console.log("hello".fontsize("font1", " font2")); =&gt; &lt;font szie="font1"&gt;hello&lt;/font&gt; italics: f italics() 属性： 是一个方法含义： 创建了一个&lt;i&gt;标签元素将字符串包裹起来, 从而让这个字符串为斜体参数： 无备注： 在 HTML4.01中，&lt;i&gt;标签呈现斜体的文本。然而，在 HTML5中没有必要这么做，可以使用样式表来格式化&lt;i&gt;元素中的文本。返回值： 一个i标签字符串，中间包裹的文字是原始字符串 “&lt;i&gt;原始字符串&lt;/i&gt;“运用：12console.log(typeof "hello".italics() === "string"); -&gt; true console.log("hello".italics()); =&gt; &lt;i&gt;hello&lt;/i&gt; 根据位置索引，返回对应字符 | 以Unicode编码表示的方法charAt: f charAt(pos) 属性： 是一个方法含义： 根据参数索引，获取指定位置的字符参数： 0到多个任意类型的值 含义: 指定的位置的索引 备注： 该方法会自动将参数装换为Number类型，利用==Number()==方法，因此它接收任意类型的参数 如果参数为普通对象、正则和函数类型，则默认是获取索引为0对应的字符 如果索引为小数，则默认向下取整（利用==Match.floor()==方法） 如果索引大于最大索引值或小于最小索引值，则结果为空字符 如果没有为该方法传参，则默认是获取索引为0对应的字符 备注： 当方法有多个参数时，只有第一参数才是有效参数，后面的参数都是无效的返回值： 根据指定位置索引值获取到的字符 运用：12345678910console.log("hello".charAt()); =&gt; "h" console.log("hello".charAt("0")); =&gt; "h" console.log("hello".charAt(false)); =&gt; "h" console.log("hello".charAt([0])); =&gt; "h" console.log("hello".charAt(5)); =&gt; "" console.log("hello".charAt(-1)); =&gt; "" console.log("hello".charAt(1.6)); =&gt; "e" console.log("hello".charAt(&#123;age: 1&#125;)); =&gt; "h" console.log("hello".charAt(/^\d$/)); =&gt; "h" console.log("hello".charAt(function()&#123;&#125;)); =&gt; "h" charCodeAt: f charCodeAt(index) 属性： 是一个方法含义： 根据参数索引，获取指定位置的字符,将该字符用==Unicode==码表示参数： 0到多个任意类型的值 含义: 指定的位置的索引 备注： 该方法会自动将参数装换为Number类型，利用==Number()==方法，因此它接收任意类型的参数 如果参数为普通对象、正则和函数类型，则默认是获取索引为0对应的字符 如果没有为该方法传参，则默认是获取索引为0对应的字符 如果索引为小数，则默认向下取整（利用==Match.floor()==方法） 如果索引大于最大索引值或小于最小索引值，则返回的结果为==NaN== 备注： 当方法有多个参数时，只有第一参数才是有效参数，后面的参数都是无效的返回值： 根据指定位置索引值获取到的字符的Unicode表示形式, 返回0到65535之间的整数 运用：12345678910console.log("hello".charCodeAt()); =&gt; "104"console.log("hello".charCodeAt("0")); =&gt; "104"console.log("hello".charCodeAt(false)); =&gt; "104"console.log("hello".charCodeAt([0])); =&gt; "104"console.log("hello".charCodeAt(5)); =&gt; "NaN"console.log("hello".charCodeAt(-1)); =&gt; "NaN"console.log("hello".charCodeAt(1.6)); =&gt; "101"console.log("hello".charCodeAt(&#123;age: 1&#125;)); =&gt; "104"console.log("hello".charCodeAt(/^\d$/)); =&gt; "104"console.log("hello".charCodeAt(function()&#123;&#125;)); =&gt; "104" codePointAt: f codePointAt(pos) 属性： 是一个方法含义： 根据参数索引，获取指定位置的字符,将该字符用==Unicode==码表示（运用在将字符装换为ASCII码表示）参数： 0到多个任意类型的值 含义: 指定的位置的索引 备注： 该方法会自动将参数装换为Number类型，利用==Number()==方法，因此它接收任意类型的参数 如果参数为普通对象、正则和函数类型，则默认是获取索引为0对应的字符 如果没有为该方法传参，则默认是获取索引为0对应的字符 如果索引为小数，则默认向下取整（利用==Match.floor()==方法） 如果索引大于最大索引值或小于最小索引值，则返回的结果为==undefined== 备注： 当方法有多个参数时，只有第一参数才是有效参数，后面的参数都是无效的返回值： 根据指定位置索引值获取到的字符的Unicode表示形式, 返回0到65535之间的整数 运用：12345678910console.log("hello".codePointAt()); =&gt; "104"console.log("hello".codePointAt("0")); =&gt; "104"console.log("hello".codePointAt(false)); =&gt; "104"console.log("hello".codePointAt([0])); =&gt; "104"console.log("hello".codePointAt(5)); =&gt; "undefined"console.log("hello".codePointAt(-1)); =&gt; "undefined"console.log("hello".coePointAt(1.6)); =&gt; "101"console.log("hello".codePointAt(&#123;age: 1&#125;)); =&gt; "104"console.log("hello".codePointAt(/^\d$/)); =&gt; "104"console.log("hello".codePointAt(function()&#123;&#125;)); =&gt; "104" 判断是否以某一个字符串开头（结尾）的方法startsWith: f startsWith(searchString [, position]) 属性： 是一个方法含义： 用来判断当前字符串是否是以另外一个给定的子字符串==开头==的，根据判断结果返回 true 或 false。 加上第二个参数之后，表示判断在字符串中的首字符（第一个参数）是否出现在原始字符串的指定位置上（第二个参数） 参数： searchString ：需要判断的子字符串（可以是一个字符，也可以是一个空字符） position：可以不填，需要判断的字符串中（第一个参数）的==首个字符==否出现在原始字符串的指定位置上（第二个参数）（以0开头） 备注： 如果第一个参数为空字符则默认返回结果为true，不管第二个参数存不存在 第一个参数可以是其它数据类型，该方法会自动将其转换为String类型（利用toString方法）。 第二个参数不填时，该方法默认它的值为0 如果第二个参数小于0（为负数）， 该方法会重新设置它的值为0 第二个参数可以是其它数据类型，该方法会自动会将其转换为Number类型（利用Number方法） 大小写敏感 返回值： true： 如果传入的子字符串在搜索字符串的首部; 如果第一个参数字符串的首字符个字符在指定位置上（第二个参数） false: 如果传入的子字符串不在搜索字符串的首部; 如果第一个参数字符串的首字符不在指定位置上（第二个参数） 运用：1234567891011console.log("hello".startsWith("")); =&gt; trueconsole.log("hello".startsWith("h")); =&gt; trueconsole.log("hello".startsWith("llo")); =&gt; falseconsole.log("hello".startsWith("h", 0)); =&gt; trueconsole.log("hello".startsWith("e", 2)); =&gt; falseconsole.log("hello".startsWith("l", 8)); =&gt; falseconsole.log("hello".startsWith("l", 2)); =&gt; trueconsole.log("hello".startsWith("h", -9)); =&gt; trueconsole.log("hello1".startsWith(1, 5)); =&gt; trueconsole.log("hello1".startsWith(1, "5")); =&gt; trueconsole.log("Hello".startsWith("h", 0)); =&gt; false startsWith方法的实现原理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*! http://mths.be/startswith v0.2.0 by @mathias */if (!String.prototype.startsWith) &#123; (function() &#123; 'use strict'; // needed to support `apply`/`call` with `undefined`/`null` var defineProperty = (function() &#123; // IE 8 only supports `Object.defineProperty` on DOM elements try &#123; var object = &#123;&#125;; var $defineProperty = Object.defineProperty; var result = $defineProperty(object, object, object) &amp;&amp; $defineProperty; &#125; catch(error) &#123;&#125; return result; &#125;()); var toString = &#123;&#125;.toString; var startsWith = function(search) &#123; if (this == null) &#123; throw TypeError(); &#125; var string = String(this); if (search &amp;&amp; toString.call(search) == '[object RegExp]') &#123; throw TypeError(); &#125; var stringLength = string.length; var searchString = String(search); var searchLength = searchString.length; var position = arguments.length &gt; 1 ? arguments[1] : undefined; // `ToInteger` var pos = position ? Number(position) : 0; if (pos != pos) &#123; // better `isNaN` pos = 0; &#125; var start = Math.min(Math.max(pos, 0), stringLength); // Avoid the `indexOf` call if no match is possible if (searchLength + start &gt; stringLength) &#123; return false; &#125; var index = -1; while (++index &lt; searchLength) &#123; if (string.charCodeAt(start + index) != searchString.charCodeAt(index)) &#123; return false; &#125; &#125; return true; &#125;; if (defineProperty) &#123; defineProperty(String.prototype, 'startsWith', &#123; 'value': startsWith, 'configurable': true, 'writable': true &#125;); &#125; else &#123; String.prototype.startsWith = startsWith; &#125; &#125;());&#125; endsWith: f endsWith(searchString, ?endPosition) 属性： 是一个方法含义： 用来判断当前字符串是否是以另外一个给定的子字符串==结尾==的，根据判断结果返回 true 或 false。 加上第二个参数之后，表示判断在字符串中的==最后一个字符==（第一个参数）是否出现在指定位置上（第二个参数） 参数： 参数一：需要判断的子字符串（可以是一个字符，也可以是一个空字符） 参数二：可以不填，需要判断的字符串中（第一个参数）的最后一个字符是否出现在原始字符串的指定位置上（第二个参数）（以1开头，而不是以0开头） 备注： 如果第一个参数为空字符则默认返回结果为true，不管第二个参数存不存在 第一个参数可以是其它数据类型，该方法会自动将其转换为String类型（利用toString方法）。 第二个参数不填时，该方法默认它的值为==原始字符串的长度== 如果第二个参数超出原始字符串的长度，则重新设第二个参数为原始字符串的长度 第二个参数可以是其它数据类型，该方法会自动会将其转换为Number类型（利用Number方法） 大小写敏感 返回值： true： 如果传入的子字符串在搜索字符串的末尾; 如果第一个参数字符串的最后一个字符在指定位置上（第二个参数） false: 如果传入的子字符串不在搜索字符串的末尾; 如果第一个参数字符串的最后一个字符不在指定位置上（第二个参数） 运用：12345678910console.log("hello".endsWith("h")); =&gt; falseconsole.log("hello".endsWith("llo")); =&gt; trueconsole.log("hello".endsWith("to")); =&gt; falseconsole.log("hello".endsWith("h", 1)); =&gt; trueconsole.log("hello".endsWith("e", 1)); =&gt; falseconsole.log("hello".endsWith("lo", 8)); =&gt; trueconsole.log("hello".endsWith("h", -1)); =&gt; falseconsole.log("hello1".endsWith(1, 6)); =&gt; trueconsole.log("hello1".endsWith(1, "6")); =&gt; trueconsole.log("Hello".endsWith("h", 1)); =&gt; false endsWith方法的实现原理12345678 if (!String.prototype.endsWith) &#123; String.prototype.endsWith = function(search, this_len) &#123; if (this_len === undefined || this_len &gt; this.length) &#123; this_len = this.length; &#125; return this.substring(this_len - search.length, this_len) === search; &#125;;&#125; 按照指定字符来填充原始字符串的方法padEnd: f padEnd(maxLength, ?fillString) 属性： 是一个方法含义： 用一个字符串填充当前字符串（如果需要的话则重复填充）,从当前字符串的==末尾（右侧）==开始填充。参数： maxLength: 当前字符串需要填充到的目标长度。 如果这个数值小于当前字符串的长度，则返回当前字符串本身。 fillString: 可选, 用来填充的字符串。当参数不是Number类型的数据时，该方法会用toString()方法将参数转换为字符串类型 备注： 如果fillString字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断。此参数的缺省值为 “ “（U+0020）空格。 返回值： 在原字符串末尾填充指定的填充字符串直到目标长度所形成的新字符串。 运用：1234console.log("hello".padEnd(-1)); =&gt; "hello"console.log("hello".padEnd(8)); =&gt; "hello "console.log("hello".padEnd(8, "a")); =&gt; "helloaaa"console.log("hello".padEnd(8, 2)); =&gt; "hello222" padStart: f padStart(maxLength, ?fillString) 属性： 是一个方法含义： 用一个字符串填充当前字符串（如果需要的话则重复填充）,从当前字符串的==首部（左侧）==开始填充。参数： maxLength: 当前字符串需要填充到的目标长度。 如果这个数值小于当前字符串的长度，则返回当前字符串本身。 fillString: 可选, 用来填充的字符串。当参数不是Number类型的数据时，该方法会用toString()方法将参数转换为字符串类型 备注： 如果fillString字符串太长，使填充后的字符串长度超过了目标长度，则只保留最右侧的部分（从后往前开始计算），其他部分会被截断。此参数的缺省值为 “ “（U+0020）空格。 返回值： 在原字符串末尾填充指定的填充字符串直到目标长度所形成的新字符串。 运用：1234console.log("hello".padStart(-1)); =&gt; "hello"console.log("hello".padStart(8)); =&gt; " hello"console.log("hello".padStart(8, "a")); =&gt; "aaahello"console.log("hello".padStart(8, 2)); =&gt; "222hello" 其它常用的方法concat: f concat(string2, string3[, ..., stringN]) 属性： 是一个方法含义： 将原始字符串和参数字符串拼接成为一个新的字符串参数： 0到多个任意类型的值 含义: 指定的位置的索引 备注： 该方法会自动将参数装换为String类型，利用==toString()==方法，因此它接收任意类型的参数 如果没有传递参数，则返回的新字符串为原始字符串（可以用于复制字符串） 备注：原始字符串不会被改变, 将拼接好的新字符串返回返回值： 返回新拼接好的字符串 运用：1234567console.log("hello".concat()); =&gt; "hello"console.log("hello".concat(" world")); =&gt; "hello world"console.log("hello".concat(2)); =&gt; "hello2"console.log("hello".concat([1])); =&gt; "hello1"console.log("hello".concat(&#123;age: 20&#125;)); =&gt; "hello[object Object]"console.log("hello".concat(/^\d$/)); =&gt; "hello/^\d$/"console.log("hello".concat(function()&#123;&#125;)); =&gt; "hellofunction()&#123;&#125;" match: ƒ match(regexp) 属性： 是一个方法含义：返回原始字符串匹配正则表达式的的结果参数： regexp: 正则表达式 备注： 如果传入一个非正则表达式对象，则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp 如果没有给出任何参数并直接使用match() 方法 ，将会得到一 个包含空字符串的[&quot;&quot;, index: 0, input: &quot;hello&quot;, groups: undefined]。 如果参数是一个有正号的正数，RegExp() 方法将忽略正号。 返回值： 如果正则表达式使用g标志，则将返回与完整正则表达式匹配的所有结果（Array），但不会返回捕获组，或者未匹配 null。 如果正则表达式未使用g标志，则仅返回第一个完整匹配及其相关的捕获组（Array）。 在这种情况下，返回的项目将具有如下所述的其他属性，或者未匹配 null。 0：正则表达式第一个完整匹配的字符串 …: 如果有分组捕获，就会依次列出每一个分组捕获的内容 groups: 一个捕获组数组 或 undefined（如果没有定义命名捕获组）。 index: 匹配的结果的开始位置 input: 搜索的字符串. 一个Array，其内容取决于global（g）标志的存在与否，如果未找到匹配则为==null==。 如果正则表达式不包含 g 标志，将返回与 RegExp.exec(). 相同的结果。 注意： 如果你需要知道一个字符串是否与一个正则表达式匹配 RegExp ，可使用 test() 。 如果你只是需要第一个匹配结果，也可以使用 RegExp.exec() 。 如果你想要获得捕获组，并且设置了全局标志，只能用 RegExp.exec() 。 运用：12345678910console.log('For more information, see Chapter 3.4.5.1'.match(/see (chapter \d+(\.\d) )/i));=&gt; 分组捕获 0: "see Chapter 3.4.5.1" =&gt; 匹配的完整内容 1: "Chapter 3.4.5.1" =&gt; 被'(chapter \d+(\.\d) )'捕获 2: ".1" =&gt; 是被'(\.\d)'捕获的最后一个值 groups: undefined index: 22 =&gt; 属性(22) 是整个匹配从零开始的索引。 input: "For more information, see Chapter 3.4.5.1" =&gt; 属性是被解析的原始字符串。 length: 3 =&gt; 匹配的内容的数组长度，包括分组 __proto__: Array(0) 1234567891011console.log('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.match(/[A-E]/gi)); =&gt; 分组捕获 ["A", "B", "C", "D", "E", "a", "b", "c", "d", "e"] console.log('hello'.match()); =&gt; 分组捕获 0: "" groups: undefined index: 0 input: "hello" length: 1 __proto__: Array(0) 12345678910111213141516171819var str = "hello world 12345", str2 = "NaN means not a number. Infinity contains -Infinity and +Infinity in JavaScript";console.log(str.match("hello")); //=&gt; ["hello", index: 0, input: "hello world 12345", groups: undefined]console.log(str2.match(NaN)); //=&gt; ["NaN", index: 0, input: "NaN means not a number. Infinity contains -Infinity and +Infinity in JavaScript", groups: undefined]console.log(str2.match(Infinity)); //=&gt; ["Infinity", index: 24, input: "NaN means not a number. Infinity contains -Infinity and +Infinity in JavaScript", groups: undefined]console.log(str2.match(+Infinity)); //=&gt; ["Infinity", index: 24, input: "NaN means not a number. Infinity contains -Infinity and +Infinity in JavaScript", groups: undefined]console.log(str2.match(-Infinity)); //=&gt; ["-Infinity", index: 42, input: "NaN means not a number. Infinity contains -Infinity and +Infinity in JavaScript", groups: undefined]console.log(str.match(12345)); //=&gt; ["12345", index: 12, input: "hello world 12345", groups: undefined]console.log(str.match(+12345)); //=&gt; ["12345", index: 12, input: "hello world 12345", groups: undefined]console.log(str.match(-12345));//=&gt; nullconsole.log(str.match(null)); //=&gt; null repeat: f repeat(count) 属性： 是一个方法含义： 构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的原始字符串的副本参数： count: 介于0和正无穷大之间的整数 : [0, +∞) 。表示在新构造的字符串中重复了多少遍原始字符串 备注： count &lt; 0, 则方法报错：Uncaught RangeError: Invalid count value count = 0 || count的值不是一个数字，则该方法的返回值为空字符串 当count为小数的时候，该方法会用Math.floor()方法向下取整数 count必须小于 infinity，且长度不会大于最长的字符串。 该方法会默认使用Number()方法，将count参数的值转换为number类型的值 返回值： 包含指定字符串的指定数量副本的新字符串。运用：1234567console.log("hello".repeat(-1)); =&gt; "RangeError: repeat count must be positive and less than inifinity"console.log("hello".repeat(0)); =&gt; ""console.log("hello".repeat(1)); =&gt; "hello"console.log("hello".repeat(2)); =&gt; "hellohello"console.log("hello".repeat(3.5)); =&gt; "hellohellohello", 参数count将会被自动转换成整数.console.log("hello".repeat(1/0)); =&gt; RangeError: repeat count must be positive and less than inifinityconsole.log((&#123;toString : () =&gt; "hello", repeat : String.prototype.repeat&#125;).repeat(2)); //"hellohello",repeat是一个通用方法,也就是它的调用者可以不是一个字符串对象. replace: f replace(regexp|substr, newSubStr|function) 属性： 是一个方法含义： 方法返回一个由替换值（replacement）替换一些或所有匹配的模式（pattern）后的新字符串。 模式可以是一个字符串或者一个正则表达式，替换值可以是一个字符串或者一个每次匹配都要调用的函数。参数： regexp (pattern): 一个RegExp 对象或者其字面量。该正则所匹配的内容会被第二个参数的返回值替换掉。 substr (pattern): 一个将被 newSubStr 替换的 字符串。其被视为一整个字符串，而不是一个正则表达式。仅第一个匹配项会被替换。 newSubStr (replacement): 用于替换掉第一个参数在原字符串中的匹配部分的字符串。该字符串中可以内插一些特殊的变量名。参考下面的使用字符串作为参数。 function (replacement): 一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。参考下面的指定一个函数作为参数。 备注： 该方法并不改变调用它的字符串本身，而只是返回一个新的替换后的字符串。 在进行全局的搜索替换时，正则表达式需包含 g 标志。 使用字符串作为替换参数[第二个参数]（替换字符串可以插入下面的特殊变量名）:| 变量名 | 代表的值 || :——– | :——–|| $$ | 插入一个 “$”。|| $&amp; | 插入匹配的子串。|| $` | 插入当前匹配的子串左边的内容。|| $’ | 插入当前匹配的子串右边的内容。|| $n | 假如第一个参数是 RegExp对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。提示：索引是从1开始| 指定一个函数作为替换参数[第二个参数]： 你可以指定一个函数作为第二个参数。在这种情况下，当匹配执行后，该函数就会执行。 函数的返回值作为替换字符串。 (注意：上面提到的特殊替换参数在这里不能被使用。) 另外要注意的是，如果第一个参数是正则表达式，并且其为全局匹配模式， 那么这个方法将被多次调用，每次匹配都会被调用。 下面是该函数的参数：(正则调用exec方法返回的结果) 变量名 代表的值 match 匹配的子串。（对应于上述的$&amp;。） p1,p2, … 假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。） 例如，如果是用 /(\a+)(\b+)/ 这个来匹配，p1 就是匹配的 \a+，p2 就是匹配的 \b+。 offset 匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是 ‘abcd’，匹配到的子字符串是 ‘bc’，那么这个参数将会是 1） string 被匹配的原字符串。 (精确的参数个数依赖于 replace() 的第一个参数是否是一个正则表达式（RegExp）对象，以及这个正则表达式中指定了多少个括号子串。) 返回值： 一个部分或全部匹配由替代模式所取代的新的字符串。 运用:下面的例子将会使 newString 变成 ‘abc - 12345 - #$*%’：123456function replacer(match, p1, p2, p3, offset, string) &#123; // p1 is nondigits, p2 digits, and p3 non-alphanumerics return [p1, p2, p3].join(' - ');&#125;var newString = 'abc12345#$*%'.replace(/([^\d]*)(\d*)([^\w]*)/, replacer); //[^\d]除了0~9的数字之外的字符；[^\w]：匹配除了字母、下划线、数字的其他字符console.log(newString); // abc - 12345 - #$*% 在下面的例子中，replace() 中使用了正则表达式及忽略大小写标示。1234var str = 'Twas the night before Xmas...';var newstr = str.replace(/xmas/i, 'Christmas');console.log(newstr); // Twas the night before Christmas...在 replace() 中使用 global 和 ignore 选项 下面的例子中,正则表达式包含有全局替换(g)和忽略大小写(i)的选项,这使得replace方法用’oranges’替换掉了所有出现的”apples”.123456var re = /apples/gi;var re = /apples/gi;var str = "Apples are round, and apples are juicy.";var newstr = str.replace(re, "oranges");// oranges are round, and oranges are juicy.console.log(newstr); 下面的例子演示了如何交换一个字符串中两个单词的位置，这个脚本使用$1 和 $2 代替替换文本。12345var re = /(\w+)\s(\w+)/;var str = "John Smith";var newstr = str.replace(re, "$2, $1");// Smith, Johnconsole.log(newstr); 在这个例子中，所有出现的大写字母转换为小写，并且在匹配位置前加一个连字符。重要的是，在返回一个替换了的字符串前需要在匹配元素前需要进行添加操作。在返回前，替换函数允许匹配片段作为参数，并且将它和连字符进行连接作为新的片段1234567function styleHyphenFormat(propertyName) &#123; function upperToHyphenLower(match) &#123; return '-' + match.toLowerCase(); &#125; return propertyName.replace(/[A-Z]/g, upperToHyphenLower);&#125;console.log(styleHyphenFormat('borderTop')); //'border-top' 因为我们想在最终的替换中进一步转变匹配结果，所以我们必须使用一个函数。这迫使我们在使用toLowerCase()方法前进行评估。如果我们尝试不用一个函数进行匹配，那么使用toLowerCase() 方法将不会有效。1var newString = propertyName.replace(/[A-Z]/g, '-' + '$&amp;'.toLowerCase()); // won't work 这是因为 &#39;$&amp;&#39;.toLowerCase() 会先被解析成字符串字面量（这会导致相同的’$&amp;’)而不是当作一个模式。 split: f split([separator[, limit]]) 属性：这是一个方法含义：使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置，不修改原始字符串参数： 无参数：返回一个原始字符串填充的字符串数组 separator: 参数指定使用怎样的字符作为分隔符，可以是一个字符，也可以是一个字符串，也可以是一个正则表达式 如果是多个字符组成的字符串作为分隔符，则必须找到整个字符串来表示分割点 如果原始字符串中没有出现分隔符，则返回的数组包含一个由整个字符组成的元素。 如果分隔符为空字符串，则将原始字符串中的每一个字符组成的数组返回 limit：一个整数，限定返回的分割片段数量。当提供此参数时，split 方法会在指定分隔符的每次出现时分割该字符串，但在限制条目已放入数组时停止。如果在达到指定限制之前达到字符串的末尾，它可能仍然包含少于限制的条目。新数组中不返回剩下的文本。 备注： 找到分隔符后，将其从字符串中删除，并将子字符串的数组返回。 如果没有找到或者省略了分隔符，则该数组包含一个由整个字符串组成的元素。 当字符串为空时，split（）返回一个包含一个空字符串的数组，而不是一个空数组，如果字符串和分隔符都是空字符串，则返回一个空数组。 如果分隔符出现在字符串的开始或结尾，或两者都分开，分别以空字符串开头，结尾或两者开始和结束。因此，如果字符串仅由一个分隔符实例组成，则该数组由两个空字符串组成。 如果分隔符是包含捕获括号的正则表达式，则每次分隔符匹配时，捕获括号的结果（包括任何未定义的结果）将被拼接到输出数组中。但是，并不是所有浏览器都支持此功能。 返回值： 返回源字符串以分隔符出现位置分隔而成的一个 Array 运用：12345678console.log("hello".split()); //["hello"]console.log("hello".split("")); //["h", "e", "l", "l", "o"]console.log("hello".split("l")); //["he", "", "o"]console.log("hello".split("ll")); //["he", "o"]console.log("hello".split(/llo$/)); //["he", ""]console.log("hello".split(/h/)); //["", "ello"]console.log("hello".split(/o/)); //["hell", ""]console.log("hello".split(/l/, 2)); //["he", ""] 下例中，split() 方法会查找“0 或多个空白符接着的分号，再接着 0 或多个空白符”模式的字符串，找到后，就将空白符从字符串中移除，nameList 是 split 的返回数组。12345678var names = "Harry Trump ;Fred Barney; Helen Rigby ; Bill Abel ;Chris Hand ";console.log(names);var re = /\s*(?:;|$)\s*/;var nameList = names.split(re);console.log(nameList);//上例输出两行，第一行输出原始字符串，第二行输出结果数组。//Harry Trump ;Fred Barney; Helen Rigby ; Bill Abel ;Chris Hand [ "Harry Trump", "Fred Barney", "Helen Rigby", "Bill Abel", "Chris Hand", "" ] 下例中，split 查找字符串中的 0 或多个空格，并返回找到的前 3 个分割元素（splits）123var myString = "Hello World. How are you doing?";var splits = myString.split(" ", 3);console.log(splits); //["Hello", "World.", "How"] 如果 separator 包含捕获括号（capturing parentheses），则其匹配结果将会包含在返回的数组中。1234var myString = "Hello 1 word. Sentence number 2.";var splits = myString.split(/(\d)/);console.log(splits);//[ "Hello ", "1", " word. Sentence number ", "2", "." ] 其它不常用的方法localeCompare: f localeCompare(compareString, ?locales, ?options) 属性： 是一个方法含义：用本地特定的顺序来比较两个字符串。参数： compareString: 用来比较的字符串 locales: 可选。 用来表示一种或多种语言或区域的一个符合 BCP 47 标准的字符串或一个字符串数组。 locales参数的一般形式与解释， 详情请参考 Intl page. options: 可选。 支持下列的一些或全部属性的一个对象: 备注： 返回一个数字表示是否原始字符串在排序中位于比较字符串的前面，后面，或者二者相同。 当原始字符串在比较字符串前面时,返回 -1 当原始字符串在比较字符串后面时,返回 1 当原始字符串和比较字符串相同时,或根据本地排序规则没有区别，返回 0 切勿依赖于 -1 或 1 这样特定的返回值。不同浏览器之间（以及不同浏览器版本之间） 返回的正负数的值各有不同，因为W3C规范中只要求返回值是正值和负值，而没有规定具体的值。一些浏览器可能返回-2或2或其他一些负的、正的值。 返回值：返回一个数字来指示一个参考字符串是否在排序顺序前面或之后或与给定字符串相同。 如果引用字符存在于比较字符之前则为负数; 如果引用字符存在于比较字符之后则为正数; 相等的时候返回 0 . 运用：1234console.log("hello".localCompare("a")); =&gt; 1console.log("hello".localeCompare("g")); =&gt; -1console.log("hello".localeCompare("hello")); =&gt; 0console.log("北京".localeCompare("北京")); =&gt; 0 normalize: f normalize([form]) 属性： 是一个方法含义： 用来将字符的不同表示形式统一为相同的形式，也就是按照指定的一种 Unicode 正规形式将当前字符串正规化. 对于那些拥有语调和重音符号的字符，Unicode提供了两种表示方法。一种是直接提供带重音符号的字符。比如”Ǒ”（字符编码\u01D1）， 另一种是原字符和重音符号合成一个字符，即”O”和”ˇ”，后者的字符编码表示为\u004F\u030C。 这两种表示方法，在语义和视觉上都是等价的，但是JavaScript无法正确识别。12345 "\u01D1" === "\u004F\u030C"; // false "\u01D1".length; // 1 "\u004F\u030C".length; // 2 "\u01D1".normalize() === "\u004F\u030C".normalize(); // true参数： form: 四种 Unicode 正规形式：”NFC”, “NFD”, “NFKC”, 以及 “NFKD” 其中的一个, 默认值为 “NFC”. NFC - Normalization Form Canonical Composition. 规范化形式规范组合。 NFC，默认参数，表示“标准等价合成”，返回多个简单字符的合成。所谓的“标准等价”指的是视觉和语义上的等价。&quot;\u004F\u030C&quot;.normalize().length === 1; // true，合成一个字符 NFD - Normalization Form Canonical Decomposition. 规范化形式规范分解。 NFD，表示“标准等价分解”，即在标准等价的前提下，将合成字符分解成多个简单字符。&quot;\u01D1&quot;.normalize(&#39;NFD&#39;).length === 2; // true，分解成两个字符 NFKC - Normalization Form Compatibility Composition. 规范化形式兼容性组合。 NFKC，表示“兼容等价合成”，返回合成字符，所谓的“兼容等价”指的是语义上等价，但视觉上不等价。 NFKD - Normalization Form Compatibility Decomposition. 规范化形式兼容性分解。 NFKD，表示“兼容等价分解”，返回分解字符，在“兼容等价”的前提下，将合成字符分解为多个简单字符。 备注： 如果给 form 传入了非法的参数值, 则会抛出 RangeError 异常. String.prototype.normalize()方法目前只能识别2个字符的合成。 返回值： 正规化完成的字符串 运用：1234console.log("\u1E9B\u0323".normalize("NFC")); =&gt; "\u1E9B\u0323"console.log("\u1E9B\u0323".normalize("NFD")); =&gt; "\u017F\u0323\u0307"console.log("\u1E9B\u0323".normalize("NFKC")); =&gt; "\u1E69"console.log("\u1E9B\u0323".normalize("NFKD")); =&gt; "\u0073\u0323\u0307"]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String原型上的方法以及属性详细讲解(二)]]></title>
    <url>%2F2019%2F02%2F18%2FString%E5%8E%9F%E5%9E%8B%E4%B8%8A%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[判断指定字符串是否包含在原始字符串中的方法search: f search(regexp) 属性：这是一个方法含义：search()方法检索指定字符串是否包含在原始字符串中参数： regexp: 一个正则表达式（regular expression）对象。如果传入一个非正则表达式对象，则使用 new RegExp(obj) 隐式地将其转换为正则表达式对象（new RegExp(obj) 隐式转换会先使用toString()方法，将参数值转换为字符串(String类型的值)，再进行处理）。 没有参数时，或空字符串，或空数组，该方法都默认返回0 备注： 当你想要知道字符串中是否存在某个模式（pattern）时可使用 search，类似于正则表达式的 test 方法。当要了解更多匹配信息时，可使用 match（会更慢），该方法类似于正则表达式的 exec 方法。 返回值： 如果匹配成功，则 search() 返回正则表达式在字符串中==首次==匹配项的索引。否则，返回==-1==。 运用：12345console.log("hello".search("")); // 0console.log("hello".search(/e/)); // 1console.log("hello".search(/l/)); // 2 console.log("hello".search(/y/)); // -1 console.log("hello".search("l"); // 2 下例记录了一个消息字符串，该字符串的内容取决于匹配是否成功。123456789function testinput(re, str)&#123; var midstring; if (str.search(re) != -1)&#123; midstring = " contains "; &#125; else &#123; midstring = " does not contain "; &#125; console.log (str + midstring + re);&#125; includes: f includes(searchString, ?position) 属性： 是一个方法含义： 方法用于判断一个字符串是否包含在原始字符串中，根据情况返回 true 或 false。 如果第二个参数存在，则用于判断字符串（第一个参数）是否包含在子字符串中（从原始字符串的某个索引位置【第二个参数：从0开始】开始截取子字符串） 参数： 参数一：需要判断的子字符串（可以是一个字符，也可以是一个空字符） 参数二：可以不填，表示在原始字符串中开始查找的位置。可以是任意整数。默认值为 0 备注： 如果第一个参数为空字符则默认返回结果为true，不管第二个参数存不存在 第一个参数可以是其它数据类型，该方法会自动将其转换为String类型（利用toString方法）。 第二个参数不填时，该方法默认它的值为0 原始字符串包含第一个参数，如果第二个参数小于原始字符串的长度的最小值（负数），返回值默认是true 第二个参数可以是其它数据类型，该方法会自动会将其转换为Number类型（利用Number方法） 第二个参数大于原始字符串的长度，返回值默认是false 大小写敏感 返回值： true： 如果传入的子字符串包含在原始字符串中; 如果第一个参数字符串包含在原始子字符串（从第二个参数值开始截取原始字符串）中 false: 如果传入的子字符串包含不在原始字符串中; 如果第一个参数字符串包含不在原始子字符串（从第二个参数值开始截取原始字符串）中 运用：123456789console.log("hello".includes("h")); =&gt; trueconsole.log("hello".includes("to")); =&gt; falseconsole.log("hello".includes("he", 1)); =&gt; falseconsole.log("hello".includes("ello", 1)); =&gt; trueconsole.log("hello".includes("lo", 8)); =&gt; falseconsole.log("hello".includes("he", -1)); =&gt; trueconsole.log("hello1".includes(1, 5)); =&gt; trueconsole.log("hello1".includes(1, "5")); =&gt; trueconsole.log("Hello".includes("h", 0)); =&gt; false indexOf: f indexOf(searchString, ?position) 属性： 是一个方法含义： 用于判断子字符串（第一个参数）是否在原始字符串中出现过； 如果不存在，则返回-1; 如果存在，则返回子字符串中的第一个字符在原始字符串中==第一次==出现的位置索引（从0开始）。 如果第二个参数存在，则用于判断字符串（第一个参数）是否包含在子字符串中（从原始字符串的某个索引位置【第二个参数：从0开始】开始截取子字符串） 如果不包含，则返回-1； 如果包含，则返回子字符串（的第一个字符）在原始字符串中第一次出现的位置索引（从0开始）【与子字符串本身相关，不只是单个字符的索引位置，而是整个子字符串的第一位索引值】。 参数： 参数一：需要判断的子字符串（可以是一个字符，也可以是一个空字符） 参数二：可以不填，表示在原始字符串中开始查找的位置。可以是任意整数。默认值为 0 备注： 第一个参数可以是其它数据类型，该方法会自动将其转换为String类型（利用toString方法）。 第一个参数为空字符串时： 没有设置第二个参数：默认返回值为0 第二个参数 &gt; 0 &amp;&amp; 第二个参数 &lt; 原始字符串的长度：默认返回值为第二个参数值； 第二个参数 &gt;= 原始字符串的长度：默认返回值为原始字符串的长度 第二个参数可以是其它数据类型，该方法会自动会将其转换为Number类型（利用Number方法） 第二个参数不填时或第二个参数 &lt;= 0：该方法默认它的值为0 第一个参数不为空字符串时, 第二个参数 &gt;= 原始字符串的长度：默认返回值为-1 大小写敏感 返回值： 子字符串（第一个参数）的第一个字符在原始字符串中第一次出现的位置索引（从0开始）【与子字符串本身相关，不只是单个字符的索引位置，而是整个子字符串的第一位索引值】。 如果没有找到， 则返回-1。 运用：1234567891011121314console.log("hello".indexOf("")); =&gt; 0console.log("hello".indexOf("", -2)); =&gt; 0console.log("hello".indexOf("", 4)); =&gt; 4console.log("hello".indexOf("", 8)); =&gt; 5console.log("hello".indexOf("h")); =&gt; 0console.log("hello".indexOf("l")); =&gt; 2console.log("hello".indexOf("to")); =&gt; -1console.log("hello".indexOf("he", 1)); =&gt; -1console.log("hello".indexOf("ello", 1)); =&gt; 1console.log("hello".indexOf("lo", 8)); =&gt; -1console.log("hello".indexOf("he", -1)); =&gt; 0console.log("hello1".indexOf(1, 5)); =&gt; 5console.log("hello1".indexOf(1, "5")); =&gt; 5console.log("Hello".indexOf("h", 0)); =&gt; -1 lastIndexOf: f lastIndexOf(searchString, ?position) 属性： 是一个方法含义： 用于判断子字符串（第一个参数）是否在原始字符串中出现过； 如果不存在，则返回-; 如果存在，则返回子字符串中的第一个字符在原始字符串中==最后一次==出现的位置索引（从0开始）。 如果第二个参数存在，则用于判断字符串（第一个参数）是否包含在子字符串中（从原始字符串的某个索引位置【第二个参数：从0开始】向前开始截取子字符串） 如果不包含，则返回-1； 如果包含，则返回子字符串（的第一个字符）在原始字符串中最后一次出现的位置索引（从0开始）【与子字符串本身相关，不只是单个字符的索引位置，而是整个子字符串的第一位索引值】。 参数： 参数一：需要判断的子字符串（可以是一个字符，也可以是一个空字符） 参数二：可以不填，表示在原始字符串中开始查找的位置（从指定位置向前查找）。可以是任意整数。默认值为原始字符串的长度 注意： 参数二 &lt; 0: 该方法会默认它的值为0； 参数二不填 或 第参数二 &gt;= 原始字符串的长度：该方法默认它的值为原始字符串的长度 备注： 第一个参数可以是其它数据类型，该方法会自动将其转换为String类型（利用toString方法）。 第一个参数为空字符串时： 没有设置第二个参数：默认返回值为原始字符串的长度; 第二个参数 &lt; 0: 默认返回值为0; 第二个参数 &gt; 0 &amp;&amp; 第二个参数 &lt; 原始字符串的长度：默认返回值为第二个参数值； 第二个参数 &gt;= 原始字符串的长度：默认返回值为原始字符串的长度 第二个参数可以是其它数据类型，该方法会自动会将其转换为Number类型（利用Number方法） 大小写敏感 var i = str.lastIndexOf(p1,p2)可以等效为var i = str.indexOf(p1); i = i &gt; p2? -1 : i; 返回值： 子字符串（第一个参数）的第一个字符在原始字符串中最后一次出现的位置索引（从0开始）【与子字符串本身相关，不只是单个字符的索引位置，而是整个子字符串的第一位索引值】。 如果没有找到， 则返回-1。 运用：1234567891011console.log("hello".lastIndexOf("")); =&gt; 5console.log("hello".lastIndexOf("", -2)); =&gt; 0console.log("hello".lastIndexOf("", 4)); =&gt; 4console.log("hello".lastIndexOf("", 8)); =&gt; 5console.log("hello".lastIndexOf("h")); =&gt; 0console.log("hello".lastIndexOf("l")); =&gt; 3console.log("hello".lastIndexOf("to")); =&gt; -1console.log("hello".lastIndexOf("he", -1)); =&gt; 0, (-1 =&gt; 0)，对应备注第五条console.log("hello1".lastIndexOf(1, 5)); =&gt; 5console.log("hello1".lastIndexOf(1, "5")); =&gt; 5console.log("Hello".lastIndexOf("h", 0)); =&gt; -1 截取子串的方法slice: f slice([start], [end]) 属性：这是一个方法含义：提取原始字符串的一部分，并返回一个新的字符串。对原始字符串不产生影响参数： 无参数：返回原始字符串，相当于复制一个原始字符 start: 可选.。从该索引（以 0 为基数）处开始提取原字符串中的字符。 如果值为负数，会被当做 sourceLength + beginSlice 看待，这里的sourceLength 是原始字符串的长度 (例如， 如果beginSlice 是 -3 则看作是: sourceLength - 3) 如果该参数超出原始字符串的长度，则默认返回值为空字符串 end: 可选。在该索引（以 0 为基数）处[==不包含该索引==]结束提取字符串。如果省略该参数，slice会一直提取到字符串末尾。 如果该参数为负数，则被看作是 sourceLength + endSlice，这里的 sourceLength 就是原始字符串的长度(例如，如果 endSlice 是 -3，则是, sourceLength - 3)。 如果该参数超出原始字符串的长度，则默认等于原始字符串的长度。 如果此参数值不存在，则默认值为原始字符串的长度 备注： slice() 从一个字符串中提取字符串并返回新字符串。在一个字符串中的改变不会影响另一个字符串。也就是说，slice 不修改原字符串，只会返回一个包含了原字符串中部分字符的新字符串。 注意：slice() 提取的新字符串包括beginSlice但不包括 endSlice。 例1：str.slice(1, 4) 提取新字符串从第二个字符到第四个 (字符索引值为 1, 2, 和 3)。 例2：str.slice(2, -1) 提取第三个字符到倒数第二个字符。 start参数和end参数可以接收小数，该方法会使用Math.floor()方法，转换为整数 返回值： 返回一个从原字符串中提取出来的新字符串 运用：1234console.log("hello".slice()); //helloconsole.log("hello".slice(1, 9)); // elloconsole.log("hello".slice(0, 3)); // helconsole.log("hello".slice(1.2, 2.9)); // e 下面例子使用 slice() 来创建新字符串:123var str1 = 'The morning is upon us.';var str2 = str1.slice(4, -2);console.log(str2); // OUTPUT: morning is upon u 下面的例子在 slice() 使用了负值索引:1234var str = 'The morning is upon us.';str.slice(-3); // returns 'us.'str.slice(-3, -1); // returns 'us'str.slice(0, -1); // returns 'The morning is upon us' substr: f substr(start[, length]) 属性: 是一个方法含义：从原始字符串中在==指定位置==截取==指定长度==的字符串参数： start：是一个字符的索引（从0 开始计算），表示开始提取字符的位置。 如果为负值，则被看作 strLength + start，其中 strLength 为原始字符串的长度（例如，如果 start 为 -3，则被看作 strLength + (-3)）。 如果大于原始字符串的长度，则返回值为空字符串 length：可选。提取的字符数。 备注： start 是一个字符的索引。首字符的索引为 0，最后一个字符的索引为 字符串的长度减去1。 substr 从 start 位置开始提取字符，提取 length 个字符（或直到字符串的末尾）。 如果 start 为正值，且大于或等于字符串的长度，则 substr 返回一个空字符串。 如果 start 为负值，则 substr 把它作为从字符串末尾开始的一个字符索引。 如果 start 为负值且 abs(start) 大于字符串的长度，则 substr 使用 0 作为开始提取的索引。 注意负的 start 参数不被 Microsoft JScript 所支持。 如果 length 为 0 或负值，则 substr 返回一个空字符串。 如果忽略 length，则 substr 提取字符，直到字符串末尾。 返回值：返回在原始字符串中从指定位置开始到指定字符数的字符串。运用：12345678console.log("hello".substr(0)); =&gt; helloconsole.log("hello".substr(1, 2)); =&gt; elconsole.log("hello".substr(-3, 3)); =&gt; lloconsole.log("hello".substr(-4)); =&gt; elloconsole.log("hello".substr(-20, 2)); =&gt; heconsole.log("hello".substr(20, 2)); =&gt; ""[空字符串]console.log("hello".substr(2, 0)); =&gt; ""[空字符串]console.log("hello".substr(2, -9)); =&gt; ""[空字符串] substring: f substring(indexStart[, indexEnd]) 属性: 是一个方法含义：从原始字符串中截取在开始索引到结束索引之间的一个子字符串, 或从开始索引直到字符串的末尾的一个子字符串。参数： indexStart：需要截取的第一个字符的索引(从0开始计算)，该字符作为返回的字符串的首字母。 indexEnd：可选。一个 0 到字符串长度之间的整数，==以该数字为索引的字符不包含在截取的字符串内==。 备注： substring 提取从 indexStart 到 indexEnd（不包括）之间的字符。特别地： 如果 indexStart 等于 indexEnd，substring 返回一个空字符串。 如果省略 indexEnd，substring 提取字符一直到字符串末尾。 如果任一参数小于 0 或为 NaN，则被当作 0。 如果任一参数大于 stringName.length，则被当作 stringName.length。 如果 indexStart 大于 indexEnd，则 substring 的执行效果就像两个参数调换了一样。 返回值：包含给定字符串的指定部分的新字符串。运用：123456789101112131415161718192021222324var anyString = "Mozilla";// 输出 "Moz"console.log(anyString.substring(0,3));console.log(anyString.substring(3,0));console.log(anyString.substring(3,-3));console.log(anyString.substring(3,NaN));console.log(anyString.substring(-2,3));console.log(anyString.substring(NaN,3));// 输出 "lla"console.log(anyString.substring(4,7));console.log(anyString.substring(7,4));// 输出 ""[空字符串]console.log(anyString.substring(4,4));// 输出 "Mozill"console.log(anyString.substring(0,6));// 输出 "Mozilla"console.log(anyString.substring(0));console.log(anyString.substring(0,7));console.log(anyString.substring(0,10)); 下面一个例子运用了 String.length 属性去获取指定字符串的倒数元素。显然这个办法更容易记住，因为你不再像上面那个例子那样去记住起始位置和最终位置。12345678// Displays 'illa' the last 4 charactersvar anyString = 'Mozilla';var anyString4 = anyString.substring(anyString.length - 4);console.log(anyString4);// Displays 'zilla' the last 5 charactersvar anyString = 'Mozilla';var anyString5 = anyString.substring(anyString.length - 5);console.log(anyString5); 下例替换了一个字符串中的子字符串。可以替换单个字符和子字符串。该例结尾调用的函数将 “Brave New World” 变成了 “Brave New Web”。12345678910function replaceString(oldS, newS, fullS) &#123;// Replaces oldS with newS in the string fullS for (var i = 0; i &lt; fullS.length; i++) &#123; if (fullS.substring(i, i + oldS.length) == oldS) &#123; fullS = fullS.substring(0, i) + newS + fullS.substring(i + oldS.length, fullS.length); &#125; &#125; return fullS;&#125;replaceString("World", "Web", "Brave New World"); 尝试把 “World” 替换成 “OtherWorld”。一个更好的方法如下：123function replaceString(oldS, newS,fullS)&#123; return fullS.split(oldS).join(newS);&#125; 转换大小写的方法toLocalLowerCase: f toLocalLowerCase() 属性: 是一个方法含义：方法根据任何特定于语言环境的案例映射，返回调用字符串值转换为小写的值。参数：无备注： toLocaleLowerCase()方法返回调用该方法的字符串被转换成小写之后的值，转换规则根据任何本地化特定的大小写映射。 toLocaleLowerCase()并不会影响字符串自身的值。 在大多数情况下，该方法产生的结果和调用toLowerCase()的结果相同，但是在某些本地环境中，比如土耳其语，它的大小写映射并不遵循在Unicode中的默认的大小写映射，因此会有一个不同的结果。 返回值：根据任何特定于语言环境的案例映射，将表示调用字符串的新字符串转换为小写。运用：1234console.log('ALPHABET'.toLocaleLowerCase()); // 'alphabet'console.log('中文简体 zh-CN || zh-Hans'.toLocaleLowerCase());// '中文简体 zh-cn || zh-hans' toLocalUpperCase: f toLocalUpperCase() 属性: 是一个方法含义：使用本地化（locale-specific）的大小写映射规则将输入的字符串转化成大写形式并返回结果字符串参数：无备注： toLocaleUpperCase() 方法返回的是将输入的字符串根据本地化的大小写映射规则转化成的大写形式的新字符串。 toLocaleUpperCase() 不会影响输入的字符串本身的值. 大多数情况下，这个方法与 toUpperCase() 会产生相同的值，但是对于一些语言（locale）,例如土耳其语，因为它们的大小写映射规则与Unicode默认的映射规则不同，所以调用这两个方法将会产生不同的结果。 返回值：一个新的字符串，即根据本地化的大小写映射规则将输入的字符串转化成大写形式的结果。运用：1console.log('alphabet'.toLocaleUpperCase()); // 'ALPHABET' toLowerCase: f toLowerCase() 属性: 是一个方法含义：会将调用该方法的字符串值转为小写形式，并返回。参数：无备注： toLowerCase() 会将调用该方法的字符串值转为小写形式，并返回。 toLowerCase 不会影响字符串本身的值。 返回值：一个新的字符串，表示串转换为小写的调用字符。运用：1234console.log('中文简体 zh-CN || zh-Hans'.toLowerCase());// 中文简体 zh-cn || zh-hans​console.log( "ALPHABET".toLowerCase() ); // "alphabet" toUpperCase: f toLowerCase() 属性: 是一个方法含义：会将调用该方法的字符串值转为大写形式，并返回。参数：无备注： toUpperCase() 会将调用该方法的字符串值转为大写形式，并返回。 toUpperCase不会影响字符串本身的值。 返回值：一个新的字符串，表示串转换为大写的调用字符。运用：1234console.log('中文简体 zh-CN || zh-Hans'.toUpperCase());// 中文简体 ZH-CN || ZH-HANS​console.log( "alphabet".toUpperCase()); // "ALPHABET" 去掉空格的方法trim: f trim() 属性: 是一个方法含义：方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR）。参数：无备注： trim() 方法并不影响原字符串本身，它返回的是一个新的字符串。 返回值：运用：下面的例子中将显示小写的字符串 ‘foo’:12345var orig = ' foo ';console.log(orig.trim()); // 'foo'// 另一个.trim()例子，只从一边删除var orig = 'foo ';console.log(orig.trim()); // 'foo' 如果 trim() 不存在，可以在所有代码前执行下面代码12345vif (!String.prototype.trim) &#123; String.prototype.trim = function () &#123; return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ''); &#125;;&#125; trimStart: f trimStart()trimLeft: f trimLeft() 属性: 是一个方法含义：方法从字符串的开头删除空格。trimLeft()是此方法的别名。参数：无备注： trimStart() / trimLeft()方法移除原字符串左端的连续空白符并返回， trimStart() /trimLeft()方法并不会直接修改原字符串本身。 为了与 String.prototype.padStart 等函数保持一致，标准方法名称为trimStart。 但是，出于Web兼容性原因，trimLeft仍然是trimStart的别名。在某些引擎中，这意味着：String.prototype.trimLeft.name === &quot;trimStart&quot;; 返回值： 一个新字符串，表示从其开头（左端）剥离空格的调用字符串。运用：1234567891011var greeting = ' Hello world! ';console.log(greeting);// expected output: " Hello world! ";console.log(greeting.trimStart());// expected output: "Hello world! ";var str = " foo ";alert(str.length); // 8str = str.trimLeft();alert(str.length); // 5console.log( str ); //foo trimRight: f trimRight()trimEnd: f trimEnd() 属性: 是一个方法含义：方法从一个字符串的==右端==移除空白字符。参数：无备注： trimEnd() / trimRight()方法移除原字符串右端的连续空白符并返回. trimEnd() / trimRight()方法并不会直接修改原字符串本身。为了与 String.prototype.padEnd 等函数保持一致，标准方法名称为trimEnd。 但是，出于Web兼容性原因，trimRight仍然是trimEnd的别名。 在某些引擎中，这意味着：String.prototype.trimRight.name === &quot;trimEnd&quot;; 返回值：一个新字符串，表示从其（右）端剥去空白的调用字符串。运用：1234567891011var greeting = ' Hello world! ';console.log(greeting);// expected output: " Hello world! ";console.log(greeting.trimEnd());// expected output: " Hello world!";var str = " foo ";alert(str.length); // 8str = str.trimRight();alert(str.length); // 6console.log( str ); // foo 将指定对象转换为字符串形式的方法toString: f toString() 属性: 是一个方法含义：将指定对象转换为字符串形式。参数：无备注： String 对象覆盖了Object 对象的 toString 方法；并没有继承 Object.toString()。 对于 String 对象，toString 方法返回该对象的字符串形式，和String.prototype.valueOf() 方法返回值一样。 返回值：返回指定对象的字符串形式。运用：12var x = new String("Hello world");alert(x.toString()) // 输出 "Hello world" valueOf: f valueOf() 属性: 是一个方法含义：方法返回一个String对象的原始值（primitive value）。参数：无备注： String 对象的 valueOf 方法返回一个String对象的原始值。该值等同于String.prototype.toString()。 该方法通常在 JavaScript 内部被调用，而不是在代码里显示调用。 返回值：方法返回一个String对象的原始值（primitive value）。运用：12x = new String("Hello world");alert(x.valueOf()) // Displays "Hello world"]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的原型链模式]]></title>
    <url>%2F2019%2F02%2F16%2FJS%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1234567891011function Create(name, age) &#123; this.x = 1000; this.name = name; this.age = age;&#125;Create.prototype.writeJS = function()&#123; console.log("i will write JS, my name is " + this.name + ", my age is " + this.age);&#125;var p1 = new Create('朱小露', 20);var p2 = new Create('肖暖', 20);console.log(p1.writeJS === p2.writeJS); //true 构造函数中拥有了类和实例的概念，并且实例和实例之间是相互独立开的 =》 实例识别基于构造函数模式的原型模式解决了方法或属性公有的问题 =》 把实例之间相同的属性和方法提取成公有的属性和方法 =》 想让谁公有就把谁放在Create.prototype即可 每一个函数数据类型（普通函数、类）都有一个天生自带的属性prototype（原型），并且这个属性是一个对象数据类型的值。 并且在prototype上，浏览器天生给它加了一个属性constructor(构造函数)，属性值是当前函数（类）本身。 每一个对象数据类型（普通的对象、实例、prototype）也天生自带一个属性：proto(前后分别有两个下划线)，属性值是当前实例所属类的原型（prototype）;12345678function Fn() &#123; this.x = 1000;&#125;Fn.prototype.getX = function()&#123; console.log(this.x);&#125;var f1 = new Fn();var f2 = new Fn(); Object是JS中所有对象数据类型所有的基类（最底层的类） f1 instanceof Object // true 因为f1通过proto可以向上级查找，不管有多少级，最后总能找到Object 在Object.prototype上没有proto这个属性 原型链模式f1.hasOwnProperty(&quot;x&quot;) // true hasOwnProperty是f1的一个属性但是我们发现在f1的私有属性中并没有这个方法，那如何处理的呢？ 通过 对象名.属性名 的方式获取属性值的时候，首先在对象的私有属性上进行查找，如果私有中存在这个属性，则获取的是私有的属性值 如果私有没有的话，则通过proto找到所属类的原型（类的原型上定义的属性和方法都是当前实例的公有的属性和方法），原型上存在的话，获取的是公有的属性值； 如果原型上也没有的话，则继续通过原型上的proto继续向上查找，一直找到Object.prototype为止。。这种查找机制就是我们的**原型链模式**f1.getX === f2.getX // truef1.__proto__.getX === f2.getX //truef1.getX === Fn.prototype.getX //true 12345678910function Fn() &#123; this.x = 1000; this.sum = function()&#123;&#125;;&#125;Fn.prototype.getX = function()&#123; console.log(this.x);&#125;Fn.prototype.sum = function()&#123;&#125;var f1 = new Fn();var f2 = new Fn(); f1.sum === f2.__proto__.sum //falsef1.sum === Fn.prototype.sum //falsef1.hasOwnProperty -&gt; f1.__proto__.__proto__.hasOwnProperty在IE浏览器中，我们原型链模式也是同样的原理，但是IE浏览器怕通过proto把公有的修改，禁止我们是proto 12345678910111213f1.sum = function()&#123; //修改自己私有的sum&#125;;f1.__proto__.sum = function()&#123; //修改所属类原型上的 sum&#125;Fn.prototype.sum = function()&#123; //修改公有的sum&#125;; this和原型扩展 在原型链模式中，this常用的两种情况：在类中this.xxx = xxx; this -&gt; 当前类的实例某一个方法中的this -&gt; 看执行的时候’.‘前面是谁this就是谁 需要先确定this的指向（this是谁） 先把this替换成对应的代码 按照原型链查找的机制，一步步的查找结果123456789101112131415161718192021222324function Fn()&#123; this.x = 100; this.y = 200; this.getY = function()&#123; console.log(this.y); &#125;&#125;Fn.prototype = &#123; constructor:Fn, y: 300, getX:function ()&#123; console.log(this.x); &#125;, getY:function ()&#123; console.log(this.y); &#125;&#125;;var f = new Fn();f.getX(); //this -&gt; f ,console.log(this.x) -&gt; console.log(f.x) =&gt; 100f.getY(); //this -&gt; f ,console.log(this.y) -&gt; console.log(f.y) =&gt; 200f.__proto__.getX(); //this -&gt; f.__proto__ ,console.log(this.x) -&gt; console.log(f.__proto__.x) =&gt; undefinedf.__proto__.getY(); //this -&gt; f.__proto__ ,console.log(this.y) -&gt; console.log(f.__proto__.y) =&gt; 300Fn.prototype.getX(); //this -&gt; Fn.prototype ,console.log(this.x) -&gt; console.log(fFn.prototype.x) =&gt; undefined 在内置类的原型上扩展我们的方法12345678910111213141516171819//数组去重Array.prototype.myUnique = function ()&#123; var obj = &#123;&#125;; for(var i = 0; i &lt; this.length; i++)&#123; var curr = this[i]; if(obj[curr] === curr)&#123; this[i] = this[this.length - 1]; this.length--; i--; continue; &#125; obj[curr] = curr; &#125; obj = null;&#125;var ary = [1, 2, 3, 4, 1, 2, 2, 4];ary.myUnique();console.log(ary);return this; //=&gt;目的是为了实现链式写法 链式写法：执行完成数组的一个 方法可以紧接着执行下一个方法原理：ary为什么可以使用sort方法？ 因为sort是Array.prototype上的公有的方法，而数组ary是Array这个类的一个实例，所以ary可以使用sort方法 =》数组才能使用我们Array原型上定义的属性和方法sort执行完成的返回值是一个排序后的数组reverse执行完成的返回值是一个数组,可以继续执行poppop执行完成的返回值是被删除的那个元素，不是一个数组了ary.sort(function (a, b){return a-b;}).reverse().pop();]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的单例模式和工厂模式]]></title>
    <url>%2F2019%2F02%2F16%2FJS%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式 对象数据类型的作用：把描述同一个事物（同一个对象）的属性和方法放在一个内存空间下，起到了分组的作用，这样，不同事物之间的属性即使属性名相同，相互也不会发生冲突我们把这种分组编写代码的模式叫做单例模式在单例模式中，我们把person1和person2也叫做命名空间 12345678var person1 = &#123; name: '朱小露', age: 20&#125;var person2 = &#123; name: '肖暖', age: 20&#125; 单例模式是一种项目开发中经常给使用的模式，因为项目中我们可以使用单例模式来进行我们的模块化开发模块化开发：对于一个相对来说比较大的项目，需要多人协作开发的。我们一般情况下会根据当前项目的需求划分成几个功能板块，每个人负责一部分，同时开发，最后把每个人的代码进行合并。1234567891011121314151617181920212223var utils = &#123; click: function()&#123; &#125;&#125;var temp1 = &#123; changed: function()&#123; utils.click(); //在自己的命名空间下调用其他命名空间的方法 &#125; &#125;var temp2 = &#123; changed: function()&#123; this.select(); //在自己的命名空间下调用自己命名空间下的方法 &#125;, select: function()&#123; &#125;&#125; 工厂模式 单例模式虽然解决了分组的作用，但是不能实现批量的生产，属于手工作业模式，这就需要用到工厂模式1234567891011121314function create(name, age) &#123; var obj = &#123;&#125;; obj.name = name; obj.age = age; obj.writeJS = function()&#123; console.log("i will write JS, my name is " + obj.name + ", my age is " + obj.age); &#125; return obj;&#125;var person1 = create('朱小露', 20);person1.writeJS();var person2 = create('肖暖', 20);person2.writeJS(); 把实现同一件事的相同代码放到同一个函数中，以后如果想实现这个功能，不需要重新的编写这些代码了，只需要执行当前的函数即可，这就是函数的封装。低耦合高内聚：减少页面中的冗余代码，提高代码的重复利用率。 拓展 面向对象开发的编程语言： 类的继承、封装、多态继承： 子类继承父类中的属性和方法多态：当前方法的多种形态，后台语言中：多态包括重载和重写1234567891011function sum(num)&#123; console.log("first");&#125;function sum(num1, num2)&#123; console.log("second");&#125;sum(1);sum(1,2);//两次输出的都是second JS中不存在重载，方法名一样的话，后面会把前面的覆盖掉，最后保留一个JS中有一个操作类似重载，但是不是重载，我们可以根据传递的参数的不一样，实现不同的功能12345678910function sum(num)&#123; if(typdef(num)=== "undefined")&#123; return 0; &#125; return num;&#125;sum(100);sum(); 重写：子类重写父类的方法]]></content>
      <categories>
        <category>JS设计模式</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的小知识]]></title>
    <url>%2F2019%2F02%2F16%2FJS%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[内嵌导入和外链导入不能合并在一起，如果当前是外链导入，那么在script脚本块中编写的所有代码都不会被执行了。 真实项目中我们一般都会把CSS放在BODY的上面，把JS放在BODY的末尾（约定俗成的规范）BODY中编写的都是HTML标签，JS很多时候需要操作这些元素，，首先我们要保证元素加载成功，才可以在JS中获取到（JS放在结构之后加载，JS放在BODY的末尾） 如果把JS放在HTML标签前面了，如何等到结构加载完成再加载JS？ 方法一：JS:window.onload=function(){}页面中所有的资源文件都加载完成执行操作 方法二：JQ：$(doucument).ready(function(){}) 页面中的结构加载完成就会执行操作 window.addEventListener(‘load’, function(){}, false) window.attachEvent(‘onreadystatechange’, function(){}) 1.写静态页面从UI设计师手里拿到设计稿（静态的图片：PSD）,使用HTML+CSS把图片变为静态的HTML页面2.拿JS写一些用户交互的效果，例如：点击某一个按钮，实现一个图片的切换等，JS中有一个很常用的操作就是用来操作页面中的HTML标签的(DOM元素) JS中提供的浏览器弹框 1.alert： 在浏览器中弹出一个提示框（提供确定按钮，点击确定弹框消失） 使用alert弹框提示信息，提示的内容最都会被转换为字符串输出（调用了toString这个方法） 2、 confirm: 在alert基础上增加了让用户选择性的操作（提供两个按钮： 确定和取消）当用户点击确定按钮的时候，我们接收到的结果是true，点击的是取消按钮，我们接收到的结果是false， 此后我们可以根据接收的结果做不同的处理即可 3、prompt：在confirm基础上增加让用户输入的效果用户点击取消按钮，我们获取到的结果是null，如果用户点击的是确定按钮，我们将会获取到用户输入的内容：如果用户没有输入任何内容，获取的结果是空字符串；否则，获取的结果是用户输入的实际内容。 真实项目中，尤其是需要样式精美的网站中，我们的提示框一般都是自己封装插件和组件来实现的，不会用内置的（使用原生IS封装模态框组件） 控制台输出：方便开发人员进行调试的F12（FN+F12）打开浏览器的控制台 console.log：在控制台输出，优势不会转换数据类型，输出什么格式的数据都可以 console.dir： 比log输出的更加 详细一些console.table: 把json数据 展示成为一个表格]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的常量和变量]]></title>
    <url>%2F2019%2F02%2F16%2FJS%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[变量：值是可以改变的常量：值是不可变的1234567891011121314//=&gt;JS 中定义变量的方式//var 变量名 = 值；（ES6中定义变量使用let）var num = 12;var str = 'zxl'//=&gt;JAVA等后台语言定义变量比较严谨，JS比较松散//int num = 12;//float num = 12.5;//double num = 3.1415926;console.log(num); //=&gt;变量其实只是一个无意义的名字，它所代表的的意义都是其存储的那个值num = 13; //=&gt;让原有的NUM变量存储的值修改为13（变量只能代表一个值） 1234567//=&gt;任何一个具体的数据值都是常量，例如：12就是一个常量//=&gt;和变量类似，我们设置一个常量（也是一个名字），给其存储一个值，但是这个存储的值不能修改const nu, = 12; //=&gt;定义一个常量NUM，给他存储了12num = 13； //=&gt;Uncaught TyprError: Assignment to constant variable,常量存储的值是不能修改的]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的构造函数模式]]></title>
    <url>%2F2019%2F02%2F16%2FJS%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式1234567891011function create(name, age) &#123; var obj = &#123;&#125;; obj.name = name; obj.age = age; obj.writeJS = function()&#123; console.log("i will write JS, my name is " + obj.name + ", my age is " + obj.age); &#125; return obj;&#125;var p1 = create('朱小露', 20); 构造函数模式12345678function Create(name, age) &#123; this.name = name; this.age = age; this.writeJS = function()&#123; console.log("i will write JS, my name is " + this.name + ", my age is " + this.age);&#125;var p1 = new Create('朱小露', 20); 构造函数模式与工厂模式的区别 执行的时候普通函数执行 =》 create（）；构造函数模式 =》 new Create（） 通过new执行后，我们的Create就是一个类了；而函数执行的返回值就是Create这个类的一个实例 `构造函数模式的目的：为了创建一个自定义类，并且创建这个类的实例 在函数执行的时候相同: 都是形成一个私有作用域，然后 形参赋值 =》 预解释 =》 代码从上至下执行（类和普通函数一样，它也有普通函数的一面）不同：在代码执行之前不用自己再手动创建obj对象了，浏览器会默认的创建一个对象数据类型的值（这个对象其实就是我们当前类的一个实例）接下来代码从上至下执行，以当前的实例为执行的主体（this代表的就是当前的实例），然后分别的把属性名和属性值赋值给当前的实例最后，浏览器会默认的把创建的实例返回。 123456789101112131415161718function Create(name, age) &#123;//浏览器会默认创建实例对象 this.x = 1000; this.name = name; this.age = age; this.writeJS = function()&#123; console.log("i will write JS, my name is " + this.name + ", my age is " + this.age); &#125; //浏览器再把创建的实例，默认进行返回&#125;var p1 = new Create('朱小露', 20);p1.writeJS();var p2 = new Create('肖暖', 20);p2.writeJS();var res = Create("朱大陆",2) //=&gt;这样写不是构造函数模式执行，而是普通函数执行，由于没有写return，所以res = undefined，并且Create这个方法中的this是windowconsole.log(res); //=&gt; undefined JS中所有的类都是函数数据类型的，他通过new执行变成了一个类，但是它本身也是一个普通的函数JS中所有的实例都是数据类型的 在构造函数模式中，类中（函数体中）出现的this.xxx = xxx中的this是当前类中的一个实例 p1和p2都是Create这个类的实例，所以都拥有writeJS这个方法，但是不同实例之间的方法是不一样的在类中给实例增加的属性（this.xxx = xxx）属于当前实例的私有属性，实例和实例之间是单独的个体，所以私有属性之间是不相等的(这里针对的是引用类型，值类型的话，只要是值相等，则相等)console.log(p1.writeJS === p2.writeJS) //=&gt; falseconsole.log(p1.x === p2.x) //=&gt; true 构造函数拓展知识123456789101112function Fn()&#123; //this =&gt; 类的实例 this.x = 100; this.getX = function()&#123; //this =&gt; 需要看getX执行的时候才知道 console.log(this.x); &#125;&#125;var f1 = new Fn;f1.getX(); //-&gt; 方法中的this是f1 -&gt; 100var temp = f1.getX;ss(); //=&gt; 方法中的this是window -&gt; undefined 在构造函数模式中new Fn() 执行，如果Fn不需要传递参数的话，后面的小括号可以省略 this的问题：在类中出现的this.xxx = xxx中的this都是当前类的实例，而某一个属性值（方法），方法中的this需要看方法执行的时候，前面是否有’.’，才能知道this是谁。 12345678910function Fn()&#123; var num = 10; this.x = 100; //-&gt; f1.x = 100 this.getX = function()&#123; //-&gt; f1.getX = function... //this =&gt; 需要看getX执行的时候才知道 console.log(this.x); &#125;&#125;var f1 = new Fn;console.log(f1.num); //-&gt; undefined 类有普通函数的一面，当函数执行的时候，var num其实只是当前形成的私有作用域中的私有变量而已，他和我们的的f1这个实例没有任何的关系，只有this.xxx = xxx才相当于给f1这个实例增加私有的属性和方法，才和我们的f1有关系。 1234567891011function Fn()&#123; var num = 10; this.x = 100; //-&gt; f1.x = 100 this.getX = function()&#123; //-&gt; f1.getX = function... //this =&gt; 需要看getX执行的时候才知道 console.log(this.x); &#125; return &#123;num: 100&#125;&#125;var f1 = new Fn;console.log(f1); //-&gt; &#123;num: 100&#125; 在构造函数模式中，浏览器会默认的把我们的实例返回（返回的是一个对象数据类型的值），如果我们自己手动写了return返回： 返回的是一个基本数据类型 的值，当前实例是不变的，例如： return 100；我们的f1还是当前的Fn类的实例； 返回的是一个引用数据类型的值，当前的实例会被自己返回的值给替换掉，例如：return {num: 100}，我们返回的f1就不再是Fn的实例了，而是对象{num: 100}. 12345678function Fn()&#123; var num = 10; this.x = 100; //-&gt; f1.x = 100 this.getX = function()&#123; //-&gt; f1.getX = function... console.log(this.x); &#125;&#125;var f1 = new Fn; 检测某一个实例是否属于这个类 -&gt; instanceofconsole.log(f1 instanceof Fn); //trueconsole.log(f1 instanceof Array); //falseconsole.log(f1 instanceof Object); //true因为所有的实例都是对象数据类型的，而每一个对象数据类型都是Object这个内置类的一个实例，所以f1也是他的一个实例对于检测数据类型来说，typeof有自己的属性，不能细分object下的对象、数组、正则…var a =[]; console.log(a instanceof Array); //true 说明这是一个数组 123456789function Fn()&#123; var num = 10; this.x = 100; //-&gt; f1.x = 100 this.getX = function()&#123; //-&gt; f1.getX = function... console.log(this.x); &#125;&#125;var f1 = new Fn;var f2 = new Fn; f1和f2都是Fn这个类的一个实例，都拥有x和getX两个属性，但是这两个属性是各自的私有属性，所以：console.log(f1.getX === f2.getX); // false值类型属性除外 in：检测某一个属性是否属于这个对象（attr in object）， 不管是私有属性还是公有属性，只要存在，用in来检测都是trueconsole.log(&quot;getX&quot; in f1); //true 是他的一个属性 hasOwnProperty：用来检测某一个属性是否为这个对象的私有属性 ，这个方法只能检测私有的属性‘console.log(f1.hasOwnProperty(&#39;getX&#39;)); //true &#39;getX&#39;是f1的私有属性 思考：检测某一个属性是否为该对象的公有属性 hasPubProperty1234567891011121314function Fn()&#123; var num = 10; this.x = 100; //-&gt; f1.x = 100 this.getX = function()&#123; //-&gt; f1.getX = function... console.log(this.x); &#125;&#125;var f1 = new Fn;function hasPubProperty(obj, attr)&#123; return ( 'attr' in obj ) &amp;&amp; !(obj.hasOwnProperty(attr)); &#125;console.log(hasPubProperty(f1, 'getX')); //=&gt;false isPrototypeof 该isPrototypeOf()方法允许您检查对象是否存在于另一个对象的原型链中。123456789101112function object1() &#123;&#125;function object2() &#123;&#125;object1.prototype = Object.create(object2.prototype);const object3 = new object1();console.log(object1.prototype.isPrototypeOf(object3));// expected output: trueconsole.log(object2.prototype.isPrototypeOf(object3));// expected output: true isPrototypeOf() differs from the instanceof operator. In the expression &quot;object instanceof AFunction&quot;, the object prototype chain is checked against AFunction.prototype, not against AFunction itself.]]></content>
      <categories>
        <category>JS设计模式</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的数据类型]]></title>
    <url>%2F2019%2F02%2F16%2FJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[基本基本数据类型（值类型） number: 数字 string: 字符串 booleaan:布尔 null: 空对象指针 undefined: 未定义 引用数据类型 object 对象数据类型 {}普通对象 []数组 /^$/正则 … function函数数据类型 12345678910number: 12 12.5 -12.5 0'zxl' "朱小露" =&gt;单双引号包裹起来的都是字符串（单双引号没有区别）true false =&gt; 布尔类型：只有两个值null undefined普通对象： &#123;name: 'zxl', age: 8&#125;数组对象: [12,23,45]正则表达式：/^-?(\d|()[1-9]\d+))(\.\d+)?$/函数数据类型：function fun()&#123;&#125; ###这么多数据类型JS如何去检测呢？ typepof: 检测数据类型的运算符 instanceof: 检测某个实例是否属于这个类 constructor: 获取当前实例的构造器 Object.prototype.toString.call:获取当前实例的所属类信息 typeof 使用typeof检测，返回的结果是一个字符串，字符串中包含的内容证明了值是属于什么类型的【局限性】1、typeof null 的结果不是“null” ,而是“object”； 因为null 虽然是单独的一个数据类型， 但是它原本的意思是空对象指针，浏览器使用typeof检测的时候会把它按照对象来检测。2、使用typeof无法具体细分出到底是数组还是正则，因为返回的结果都是“object” ###腾讯的面试题123console.log(typeof typeof []);typeof [] -&gt; "object"typeof "object" -&gt; "string"]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS异步编程思想]]></title>
    <url>%2F2019%2F02%2F16%2FJS%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[JS是单线程的，JS是一个傻子，脑子是一根筋，做着当前的这件事，没有完成之前，绝对不会做下一件事件JS中的两种编程思想： 同步， 异步 同步：上一件事情没有完成，继续处理上一件事情，只有上一件事情完成了，才会做下一件事情（JS中大部分就是同步编程的） for循环就是同步编程的，只有循环结束以后，才会继续执行下面的代码123456for(var i=0; i&lt;10; i++)&#123; if(i === 9)&#123; console.log("循环结束了"); //第一个输出 &#125;&#125;console.log("ok"); //第二个输出 12while(1)&#123;&#125;console.log("ok"); //永远不会执行，因为上面的while循环是死循环，循环永远都不会结束 异步： 规划要做一件事情，但是不是当前立马去执行这件事情，需要等待一定的时间，这样的话，我们不会等着它去执行，而是继续执行下面的操作。“只有当下面的事情都处理完了，才会返回头处理之前的事情；如果下面的事情还没有处理完，但是等待的事件已经到了（即不管等待的时间到没到），都还是会继续等待，知道下面的事情处理完，才会返回头处理之前的事情” 在JS中异步编程只有四种情况：定时器都是异步编程的、所有的事件绑定都是异步编程的 、AJAX读取数据的时候，我们一般都设置为异步编程、回调函数也是异步编程 123456var n = 0;window.setTimeout(function()&#123; n ++; console.log(n); //第二个输出，输出结果为：1&#125;, 1000);console.log(n); //第一个输出，输出结果为：0 每一个浏览器对于定时器的等待时间都有一个最小值，谷歌：5~6ms；IE：10~13ms，如果设置的等待时间小于这个值，那么设置的这个值不起作用，还是需要等待到最小事件才执行；尤其是写0，也不是立即执行123456var n = 0;window.setTimeout(function()&#123; n ++; console.log(n); //第二个输出，输出结果为：1&#125;, 10);console.log(n); //第一个输出，输出结果为：0 定时器设置的时间不一定就是最后执行的时间，如果定时器之后还有其他的事情正在处理中，不管定时器的时间有没有到，都是不会执行定时器的12345678910var n = 0;window.setTimeout(function()&#123; n ++; console.log(n); //不执行，无输出&#125;, 10);console.log(n); //第一个输出，输出结果为：0while(1)&#123; //死循环 n ++;&#125;console.log(n); //不执行，无输出 12345678910111213var n = 0;window.setTimeout(function()&#123; n += 2; console.log(n); //第四个输出，输出结果为：7&#125;, 100);window.setTimeout(function()&#123; n += 5; console.log(n); //第三个输出，输出结果为：5&#125;, 50);console.log(n); //第一个输出，输出结果为：0for(var i = 0; i &lt; 10000000; i++)&#123;&#125;console.log(n); ///第二个输出，输出结果为：0 12345678910111213var n = 0;window.setTimeout(function()&#123; n += 2; console.log(n); //第四个输出，输出结果为：2&#125;, 5);window.setTimeout(function()&#123; n += 5; console.log(n); //第三个输出，输出结果为：7&#125;, 5);console.log(n); //第一个输出，输出结果为：0for(var i = 0; i &lt; 10000000; i++)&#123;&#125;console.log(n); ///第二个输出，输出结果为：0 12345678910111213var n = 0;window.setTimeout(function()&#123; n += 2; console.log(n); //第四个输出，输出结果为：2&#125;, 5);window.setTimeout(function()&#123; n += 5; console.log(n); //第三个输出，输出结果为：7&#125;, 50);console.log(n); //第一个输出，输出结果为：0for(var i = 0; i &lt; 10000000; i++)&#123;&#125;console.log(n); ///第二个输出，输出结果为：0]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS的盒子模型应用]]></title>
    <url>%2F2019%2F02%2F16%2FJS%E7%9A%84%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[回到顶部123456789101112131415161718192021222324252627282930313233343536373839404142434445464748*&#123; margin: 0; padding: 0; font-size: 12px;&#125;body&#123; width: 100%; height: 10000px; /*代表高度有5个屏幕这么高*/ background: -webkit-linear-gradient(top, #fe472c, #fe7259, #ff8687, #ff8b86, #fac6fe); background: linear-gradient(top, #fe472c,#fe7259, #ff8687, #ff8b86, #fac6fe); -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;&#125;&lt;!-- more --&gt;a&#123; text-decoration: none; color: #000000;&#125;a:hover, a:active, a:target, a:visited&#123; text-decoration: none; color: #000000;&#125;#goLink&#123; display: none; position: fixed; bottom: 30px; right: 30px; width: 35px; height: 50px; padding: 10px 15px; letter-spacing: 5px; text-align: center; line-height: 25px; background: white; border-radius: 10px; opacity: 0.5; filter:alpha(Opacity=50);&#125;#goLink:hover&#123; opacity: 1; filter:alpha(Opacity=100);&#125; 1&lt;a href="javaScript:;" id="goLink"&gt;回到顶部&lt;/a&gt; 1var goLink = document.getElementById("goLink"); A标签本身是跳转页面的标签，把跳转的地址写在href这个属性中， 不写值的话是刷新本页面 写的如果是#target，则代表的是锚点定位，定位到当前页面ID为target这个位置 “javascript:;“,这样写是取消A标签默认的跳转行为 快速回到顶部1234goLink.onclick = function()&#123; document.documentElement.scrollTop = 0; document.body.scrollTop = 0;&#125; 缓慢回到顶部 总时间（duration）：500ms频率（interval）：10ms 多长时间走一步总距离（target）：当前的位置（当前的scrollTop值） - 目标位置（0）步长（step）：，每一次走的距离target/duration：每1ms走的距离target/duration * interval：每一次（10ms）走的距离123456789101112131415161718goLink.onclick = function()&#123; //点击回到顶部的按钮时，让当前的按钮消失 goLink.style.display = "none"; //当点击回到顶部的时候，首先把每一步要走的步长计算出来（步长） var duration = 500, interval = 10, target = document.documentElement.scrollTop || document.body.scrollTop; var step = (target / duration) * interval; var timer = window.setInterval(function()&#123; var curTop = document.documentElement.scrollTop || document.body.scrollTop; if(curTop &lt;= 0)&#123; //已经回到顶部 window.clearInterval(timer); return; &#125; curTop -= step; document.documentElement.scrollTop = curTop; document.body.scrollTop = curTop; &#125;,interval);&#125; 开始回到顶部的按钮是不显示的的，只有当浏览器卷去的高度超过一屏幕的高度的时候再显示，反之隐藏，只要浏览器的滚动条再滚动，我们就需要判断回到顶部按钮是显示还是隐藏。浏览器的滚动条滚动：拖动滚动条，鼠标滚轮，键盘上下键或者是pageDown按键/pageUp按键、点击滚动条的空白 123456789function computedDisplay()&#123; //window.onscroll不管怎么操作，只要滚动条动了就会触发这个行为 var curTop = document.documentElement.scrollTop || document.body.scrollTop; var targetTop = document.documentElement.clientHeight || document.body.clientHeight; if(curTop &gt;= targetTop)&#123; goLink.style.display = "block"; &#125;&#125; window.onscroll = computedDisplay; 我们需要在点击之后，把window.onscroll绑定的事件事件取消掉window.onscroll = null;当动画结束之后，还需要把对应的方法绑定给window.onscrollwindow.onscroll = computedDisplay; 完整版1234567891011121314151617181920212223goLink.onclick = function()&#123; //点击回到顶部的按钮时，让当前的按钮消失 goLink.style.display = "none"; //滚动条往回滚的时候，又会触发window.onscroll事件，会让回到顶部的按钮显示， //我们需要在点击之后，把window.onscroll绑定的事件事件取消掉 window.onscroll = null; //当点击回到顶部的时候，首先把每一步要走的步长计算出来（步长） var duration = 500, interval = 10, target = document.documentElement.scrollTop || document.body.scrollTop; var step = (target / duration) * interval; var timer = window.setInterval(function()&#123; var curTop = document.documentElement.scrollTop || document.body.scrollTop; if(curTop &lt;= 0)&#123; //已经回到顶部 window.clearInterval(timer); //当动画结束之后，还需要把对应的方法绑定给window.onscroll window.onscroll = computedDisplay; return; &#125; curTop -= step; document.documentElement.scrollTop = curTop; document.body.scrollTop = curTop; &#125;,interval);&#125; 跑马灯1234567891011121314151617181920212223242526*&#123; margin: 0; padding: 0; font-size: 14px;&#125;#box&#123; width: 1000px; margin: 50px auto; padding: 0 5px; height: 35px; border:1px solid black; line-height: 35px; background: lightblue;&#125;#box #wrap&#123; height: 35px; white-space: nowrap; /*强制文字不换行*/ overflow: hidden;&#125;#box #wrap div span&#123; color: #006e8b; font-size: 16px;&#125;#box #wrap div&#123; display: inline;&#125; 12345678910&lt;div id="box"&gt; &lt;div id="wrap"&gt; &lt;div id="conBegin"&gt; &lt;span&gt;【招新通知】&lt;/span&gt;南华大学辐射神经毒理创新团队现面向南华大学各学院招收新成员，本团队由公共卫生学院院长带领，请大家仔细阅读招募信息，踊跃参与报名或推荐优秀的同学，欢迎有志者加入本团队。 &lt;/div&gt; &lt;div id="conEnd"&gt; &lt;span&gt;【招新通知】&lt;/span&gt;南华大学辐射神经毒理创新团队现面向南华大学各学院招收新成员，本团队由公共卫生学院院长带领，请大家仔细阅读招募信息，踊跃参与报名或推荐优秀的同学，欢迎有志者加入本团队。 &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123var box = document.getElementById("box");var wrap = document.getElementById("wrap");var conBegin = document.getElementById("conBegin"); 第一次动画效果，不满足要求：连续移动12345678910var timer = window.setInterval(function()&#123; var curLeft = wrap.scrollLeft; wrap.scrollLeft = curLeft + 1; var newLeft = wrap.scrollLeft; //利用了scrollLeft是存在最大值的思想，在累加1之前获取一个值，在累加后再获取的一个值。如果两个值相等了，说明累加是没有作用的，则表示已经回到顶部了 if(curLeft === newLeft)&#123; //window.clearInterval(timer); wrap.scrollLeft = 0; //虽然从头开始了，但是有一歌切换的闪动的效果 &#125;&#125;, 10); 最终版1234567891011var conBegin_width = utils.getCss(conBegin, "width");if(conBegin_width === "auto" || !conBegin_width)&#123; conBegin_width = conBegin.offsetWidth;&#125;function move()&#123; wrap.scrollLeft ++; if(wrap.scrollLeft &gt;= conBegin_width)&#123; wrap.scrollLeft = 0; &#125;&#125;var timer = window.setInterval(move, 10); 事件处理：123456box.onmouseover = function()&#123; window.clearInterval(timer);&#125;box.onmouseout = function()&#123; timer = window.setInterval(move, 10);&#125; 原理图：]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中简单的DOM操作]]></title>
    <url>%2F2019%2F02%2F16%2FJS%E4%B8%AD%E7%AE%80%E5%8D%95%E7%9A%84DOM%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[通过ID获取元素: document.getElementById(&quot;id&quot;)1var newsBox = document.getElementById("ID"); [context].getElementsByTagName() 在指定的上下文[context]中，通过元素的标签名来获取一组元素12var newsList = newsBox.getElementsByTagName("li");//=&gt;获取的结果也是一个对象数据类型的值 1、以数字作为属性名，每一个属性存储的都是获取到的每一个li，JS中我们把数字属性名叫做“索引”（索引是逐级递增的）newsList[0] //获取第一个LInewsList[1] //获取第二个LInewsList[2] //获取第三个LInewsList[n] //获取第n+1个LI 2、有一个length属性存储的是当前集合中LI的个数newsList.length 具备以上两个特点像数组，但是不是数组，所以我们把它称为“类数组” 且类数组中存放的值是“object”类型 JS中的小知识点]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node的一些基础知识]]></title>
    <url>%2F2019%2F02%2F16%2FNode%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[JS是一门“运行在客户端（即运行在浏览器）”的“轻量级”的脚本编程语言JS目前不仅仅只能在浏览器中运行，还可以在Node中运行 什么是Node Node是一个环境，供JS代码执行的环境，我们还可以把它等价于浏览器，只不过我们一般都会把Node这个环境安装到服务器端，这样的话我们就可以在服务器端使用JS编写程序了，也就是说JS不仅仅是客户端的语言也是服务器端的语言 Node与浏览器之间的联系与区别 Node采用的是谷歌的V8引擎来渲染JS的（运行的速度快、稳定性好、而且我们编写的JS代码不需要考虑兼容）浏览器中的全局JS对象是window，而Node环境下的全局JS对象是Global浏览器是安装在客户端的，为了保护客户端的安全，基本上不能提供用JS代码对客户电脑磁盘上的文件进行操作的功能；但是Node环境中提供I/O操作（对服务器上的文件进行操作），我们使用JS可以对服务器上的磁盘里的文件进行增删改查Node提供给JS很多新的方法：http.createServer、fs.writeFileSync、fs.readFileSync…Node是基于事件驱动的、异步编程（我们在node环境下编写的JS程序一般都是异步编程程序） 如何让JS代码在Node环境中执行 利用webstrom嵌入了Node环境，直接把编写的JS通过右键“Run xxx.js”，在Node环境中执行（不建议经常这样使用，因为有些时候会有缓冲，这样导致执行的结果可能是上一次的代码执行结果） 在命令窗口中执行：在当前要执行的JS文件目录下，shift + 右键 =&gt; 在此处打开命令窗口 =&gt; 敲入如下命令：node xxx.js，相当于把JS代码放在Node环境中执行在Node中执行JS代码和浏览器中执行一样，如果JS代码发生了修改，想要看到最新的效果需要重新的执行对应的JS文件 在命令窗口中执行node，然后开始编写对应的JS代码测试即可（rpel命令操作），和在浏览器的控制台写JS代码效果一样 Node中的模块 内置模块（Node环境中自带的模块，相当于一些内置对象）,包含： http(方法：creatServer)、fs(方法writeFileSync、readFileSync…)、url… 自定义模块：我们自己定义的模块 在Node环境中，我们在当前的项目下创建一个JS文件，就相当于创建了一个模块，例如：新建一个a.js，相当于创建了a模块如果需要提供一些方法给其他的模块使用，则需要通过module.exports 把方法导出，例如：在A模块中写了module.exports= {fn: fn} 或者 module.exports.fn = fn如果现在B模块中需要使用A模块，我们先导入A模块：var a = require(&quot;./a&quot;); ./表示当前目录下，必须要加，a表示a模块，因此不需要加上后缀名.js，导入之后就可以调用A模块中的方法了：a.fn() 第三方模块：别人写好的模块我们拿过来使用，在node中我们如果需要使用别人的模块时，需要使用npm这个命令来进行管理：网址为：http://www.npmjs.com/ 安装：npm install 第三方模块名称 -g(安装到Node的全局环境中需要加-g，如果只安装在当前目录下，则不用加-g)卸载：npm uninstall 第三方模块名称 -g(安装在Node环境中的，就需要加-g; 否则不用加-g)安装成功后，在JS中通过var less = require(&quot;less&quot;)；把刚才安装的第三方模块导入到JS中，这样的话，我们就可以使用这个模块中提供的方法了：less.render()…..]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础， NODE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS函数原型上的方法之call_apply_bind之间的区别]]></title>
    <url>%2F2019%2F02%2F16%2Fcall_apply_bind%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[call1234567891011var obj = &#123; name: '朱小露', age: 20&#125;;function fn(num1, num2)&#123; console.log(num1 + num2); console.log(this);&#125; fn(100, 200); //this = window, num1 = 100, num2 = 200; =&gt; 300,windowfn.call(100, 200); //this = 100, num1 = 200. num2 = undefined =&gt; NaN,100fn.call(obj, 100, 200); //this = obj, num1 = 100, num2 = 200; =&gt; 300,obj 非严格模式下12345678910var obj = &#123; name: '朱小露', age: 20&#125;;function fn()&#123; console.log(this);&#125; fn.call(); //this = windowfn.call(null); //this = windowfn.call(undefined); //this = window 严格模式下1234567891011'use strict' //告诉当前浏览器，接下来的JS代码要按照严格模式进行编写var obj = &#123; name: '朱小露', age: 20&#125;;function fn()&#123; console.log(this);&#125; fn.call(); //this = undefinedfn.call(null); //this = nullfn.call(undefined); //this = undefined apply apply和call方法作用是一模一样的，都是用来改变this方法中的关键字，并且把方法执行；而且在严格模式下和非严格模式下，对于第一个参数是null/undefined这种情况的处理方式也是一样的（分为严格模式和非严格模式）12345678910var obj = &#123; name: '朱小露', age: 20&#125;;function fn(num1, num2)&#123; console.log(num1 + num2); console.log(this);&#125;fn.call(obj, 100, 200); fn.apply(obj, [100, 200]); call在给fn传参的时候，是一个一个传值的，而apply不是一个一个传值的，它是要传递的参数值统一的放在一个数组中进行操作，但是在最后形参赋值的时候，也是一个一个赋值的。 bind bind这个方法在IE6~8下不兼容吗，作用和call/apply类似都是用来改变this关键字的，但是也有一定的区别12345678910var obj = &#123; name: '朱小露', age: 20&#125;;function fn(num1, num2)&#123; console.log(num1 + num2); console.log(this);&#125;fn.call(obj, 1, 2); fn.bind(obj, 1, 2); 输出结果： 根据运行结果可知，只有fn.call(obj, 1, 2)输出了结果，而fn.bind(obj, 1, 2)并没有输出结果。 call方法：改变this和执行fn是一起都完成了bind方法：只是改变了fn中的this为obj，并且给函数fn传递了两个参数1， 2，但是此时并没有把fn函数执行。而执行完bind方法会有一个返回值，这个返回值就是把fn函数中的this改变成obj之后的新的fn，若想要bind改变之后的函数执行，代码入下：var tempFn = fn.bind(obj, 1, 2); tempFn(); bind 体现了预处理的思想：事先把fn的this改变为我们想要的结果，并且把对应的参数值也准备好，以后要用了，直接执行即可。]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery动画]]></title>
    <url>%2F2019%2F02%2F16%2FjQuery%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[AJAX12345678$.ajax(&#123; url: 'jsonData.txt?_=' + Math.random(), type: 'get', dataType: 'json', success: function(data)&#123; console.log(data); &#125;&#125;); 事件12345678var $box = $('#box');$box.on('click', function()&#123; //this: 当前元素（JS原生对象） $(this) console.log('1');&#125;)$box.on('click', function()&#123; console.log('2');&#125;) 当触发点击事件的时候，绑定在onclick上的这两个事件都会执行 工具 jQuery.browser.version 1.9以下的版本使用 检测浏览器的版本each: jQuery中有两个each（也有两个map，和each的原理一样，只是可以支持返回值） 第一个each: 循环选择器获取到的jQuery集合中的每一项123$('div').each(function(index, item)&#123; console.log(item);&#125;) 第二个each：循环数组、类数组、对象中的每一项123456789$.each([1, 2, 3, 4], function(index, item)&#123; console.log(item);&#125;)$.each(document.getElementsByTagName('*'), function(index, item)&#123; console.log(item);&#125;)$.each(&#123;name: 'zxl', age: 20&#125;, function(index, item)&#123; console.log(item);&#125;) $.makeArray &lt;==&gt; utils.listToArray 动画 stop([clearQueue],[jumpToEnd]): 停止所有在指定元素上正在运行的动画。如果队列中有等待执行的动画(并且clearQueue没有设为true)，他们将被马上执行delay(duration,[queueName]): 设置一个延时来推迟执行队列中之后的项目。finish( [queue ] ): 停止当前正在运行的动画，删除所有排队的动画，并完成匹配元素所有的动画。animate(params,[speed((&quot;slow&quot;,&quot;normal&quot;, or &quot;fast&quot;)或表示动画时长的毫秒数值(如：1000))],[easing(linear&quot;/&quot;swing)],[fn]): 用于创建自定义动画的函数。这个函数的关键在于指定动画形式及结果样式属性对象fadeIn([speed],[easing],[fn]): 通过不透明度的变化来实现所有匹配元素的淡入效果fadeOut([speed],[easing],[fn]): 通过不透明度的变化来实现所有匹配元素的淡出效果fadeTo([[speed],opacity,[easing],[fn]]): 把所有匹配元素的不透明度以渐进方式调整到指定的不透明度fadeToggle([speed,[easing],[fn]]): 通过不透明度的变化来开关所有匹配元素的淡入和淡出效果show([speed,[easing],[fn]]): 显示隐藏的匹配元素hide([speed,[easing],[fn]]): 隐藏显示的元素toggle([speed],[easing],[fn]): 如果元素是可见的，切换为隐藏的；如果元素是隐藏的，切换为可见的。slideUp([speed,[easing],[fn]]): 这个动画效果只调整元素的高度，可以使匹配的元素以“滑动”的方式隐藏起来slideDown([speed],[easing],[fn]): 这个动画效果只调整元素的高度，可以使匹配的元素以“滑动”的方式显示出来slideToggle: 这个动画效果只调整元素的高度，可以使匹配的元素以“滑动”的方式隐藏或显示 12345678910111213141516171819202122232425262728293031&lt;style&gt; *&#123; margin: 0; padding: 0; &#125; #box&#123; position: absolute; top: 50px; left: 50%; margin-left: -50px; width: 100px; height: 100px; /*渐变效果*/ background: -webkit-linear-gradient(top, #fe472c, #fe7259, #ff8687, #ff8b86, #fac6fe); background: linear-gradient(top, #fe472c,#fe7259, #ff8687, #ff8b86, #fac6fe); opacity: 1; filter: alpha(opacity = 100); &#125; input&#123; width: 100px; height: 20px; outline: none; position: absolute; top: 20px; left: 50%; margin-left: -50px; cursor: pointer; &#125;&lt;/style&gt; 12&lt;input type="button" id="submit" value="操作"/&gt;&lt;div id="box"&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script src="jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; var $submit = $('input'), $box = $('#box'); $submit.on('click', function()&#123; //这些动画效果的speed都是既支持具体的时间，也支持fast和slow $box.stop().hide(500); //stop: 先结束当前正在运行的动画，继续执行下一个动画；hide: 参数500，表示500毫秒完成这件事情 $box.stop().hide('fast'); //fast: 快速隐藏 $box.stop().hide('slow'); //slow: 缓慢隐藏 $box.stop().slideUp(500); //向上折叠 $box.stop().fadeOut(500); //淡出效果 $box.stop().slideToggle(500); //如果当前效果是展开，则收起；如果当前效果是收起，则展开 $box.stop().delay(100).slideToggle(500); //增加延迟效果 $box.stop().slideUp(500).stop().hide(500); //slideUp的效果不存在了 stop: 结束之前的动画（这里指的是slideUp动画, 之后的动画是紧接着当前位置开始的 $box.stop().slideUp(500).finish().hide(500); // hide的效果不存在了 finish: 结束之前的动画，并不是停止，而是让其css样式立刻到达目标值，再开始执行之后的动画 $box.animate(&#123; width: 20, height: 20, opacity: 0.5, &#125;, 1000, 'linear'); //匀速 $box.animate(&#123; width: 20, height: 20, opacity: 0.5, &#125;, 1000, 'swing'); //摆动 $box.animate(&#123; width: 20, height: 20, opacity: 0.5, &#125;, 1000, function()&#123; $(this).css('background', 'blue'); &#125;); //回调函数 &#125;); &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery核心解读]]></title>
    <url>%2F2019%2F02%2F16%2FjQuery%E6%A0%B8%E5%BF%83%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[1234567jQuery = function( selector, context ) &#123; //可以理解为，返回的是一个jQuery类（jQuery原型上init这个类（方法)的实例）的实例 return new jQuery.fn.init( selector, context );&#125;;jQuery.fn = jQuery.prototype = &#123; constructor: jQuery&#125;; jQuery.extend：把jQuery当做一个普通的对象，在对象中增加了extend方法jQuery.fn.extend：在jQuery的原型上也增加了一个extend对象1jQuery.extend = jQuery.fn.extend = function() &#123;&#125;; jQuery选择器：执行jQuery方法，创建jQuery这个类的实例（jQuery对象）在jQuery这个类的原型上定义了很多的属性和方法，而通过选择器获取的每一个实例都可以调用这些方法：属性、CSS、文档操作、筛选、动画、动画、事件。。。$(&#39;*&#39;).css();把jQuery当做一个普通对象，在它自己的属性上增加了一些常用的方法： Ajax、工具。。。$.ajax(); extend: 扩展，向jQuery这个类库中增加一些其他常用的方法 用途：完善类库，给类库增加核心的方法 向jQuery普通对象的属性名上扩展方法 (把它当做一个对象)123456jQuery.extend(&#123; aa: function()&#123; console.log('aa'); &#125;&#125;);$.aa(); 向jQuery原型上扩展（把它当做一个对象） 用途：编写一些基于jQuery插件 1234567jQuery.fn.extend(&#123; bb: function()&#123; console.log('bb'); &#125; &#125;); $().bb(); $.fn.bb();]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS函数原型上的方法之call方法深入]]></title>
    <url>%2F2019%2F02%2F16%2Fcall%E6%96%B9%E6%B3%95%E6%B7%B1%E5%85%A5%2F</url>
    <content type="text"><![CDATA[1234var obj = &#123;name: '朱小露', age: 20&#125;;function fn ()&#123; console.log(this);&#125; 如果想要把fn中的this改变为obj，该如何做： obj.fn() 报错： Uncaught TypeError: obj.fn is not a function fn.call(obj) call方法的作用： 首先我们让原型上的call方法执行，在执行call方法的时候，我们让fn方法中的this变为第一个参数obj，然后再把fn这个函数执行 自己模拟一个内置的call方法，写一个myCall方法，深入探讨call方法的执行原理123456789Function.prototype.myCall(context)&#123; //1.让fn中的this关键字变为context的值（这里是context= obj） // =&gt;让this这个函数中的'this关键字'变为context //eval(this.toString().replace('this',context)); ... //2. 让fn方法再执行 this();&#125;fn.mycall(obj);//mycall方法中的this是fn 练习题123456function fn1()&#123; console.log(1);&#125;function fn2()&#123; console.log(2);&#125; fn1.call(fn2); 首先fn1通过原型链机制找到Function.prototype上的call方法，并且让call方法执行，此时call这个方法中this就是我们需要修改this的fn1，在call方法代码执行的过程中。首先让fn1中的’this关键字’变为fn2，然后再让fn1这个方法执行 输出结果为1 fn1.call.call(fn2); 首先fn1通过原型链机制找到Function.prototype上的call方法，然后再让call方法通过原型链机制找到Function.prototype上的call方法（因为call本身的值也是一个函数，所以同样可以通过原型链机制找到Function.prototype），在第二次再找到call的时候，让call方法执行，方法中的this就是fn1.call，执行过程：首先让fn1.call方法中的this变为fn2，然后再让fn1.call方法执行输出结果为2 fn1.call.call.call.call(fn2) 输出结果为2执行的函数是fn1.call.call.call方法，但是fn1.call.call.call方法中的this已经变成fn2,所以最终执行的是fn2方法fn1只是起到了查找的作用，查找call方法而已 Function.prototype.call(fn1) 什么也不输出，没有任何意义最终执行函数是Function.prototype这个函数，尽管现在this已经变成fn1，但是Function.prototype是一个空函数，里面没有任何内容，因此什么也不会输出，也没有任何意义 Function.prototype.call.call(fn1) 输出结果为1执行函数是Function.prototype.call这个函数，这个函数中有this，此时的this已经变成了fn1，因此，最终执行函数是fn1]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础之sort深入]]></title>
    <url>%2F2019%2F02%2F16%2Fsort%E6%B7%B1%E5%85%A5%2F</url>
    <content type="text"><![CDATA[12var ary = [12, 23, 14, 34, 23, 1, 14, 16, 26, 2];ary.sort(); 这样只能处理10以内的数字排序1234var ary = [12, 23, 14, 34, 23, 1, 14, 16, 26, 2];ary.sort(function(a, b)&#123; return a - b;&#125;); 回调函数 把一个方法A当做参数值传递给另外一个函数B，然后在B的执行过程中，我们随时根据需求让A方法执行12345function A()&#123;&#125;function B(fn)&#123;&#125;B(A); 回调函数的形参a , b的意义：a：每一次执行匿名函数的时候，找到的数组中的当前项b：当前项的后一项 return a - b 升序如果 a &gt; b，返回的值大于0，a和b交换位置 return b - a 降序如果 b &gt; a，返回的值大于0，a和b交换位置 return的是一个大于0的值或者是一个小于等于0的值，如果是一个大于0的数，就让a和b交换一下位置，如果是小于等于0的数，就在原来的位置上不动12345var ary = [12, 23, 14, 34, 23, 1, 14, 16, 26, 2];ary.sort(function(a, b)&#123; return 1;&#125;); console.log(ary); 不管a和b谁大，每一次都返回一个恒大于0的数，也就是每一次a和b都要交换位置，最后的结果就是原来数组倒过来排列了 =》 相当于reverse 按照年龄从小到大进行排序123456789var ary = [&#123;name:'朱小露', age: 20&#125;,&#123;name: '朱庭庭', age: 22&#125;,&#123;name: '朱新渝', age: 10&#125;];ary.sort(function(a, b)&#123; return a.age - b.age;&#125;); console.log(ary); 按照年龄从大到小进行排序123456789var ary = [&#123;name:'朱小露', age: 20&#125;,&#123;name: '朱庭庭', age: 22&#125;,&#123;name: '朱新渝', age: 10&#125;];ary.sort(function(a, b)&#123; return b.age - a.age; // =&gt; return (a.age - b.age) * -1&#125;); console.log(ary); 按照姓名从小到大进行排序 localeCompare 定义：用本地特定的顺序来比较两个字符串。语法：stringObject.localeCompare(target)参数：target——要以本地特定的顺序与 stringObject 进行比较的字符串。返回值：说明比较结果的数字。（1）如果 stringObject 小于 target，则 localeCompare() 返回小于 0 的数。（2）如果 stringObject 大于 target，则该方法返回大于 0 的数。（3）如果两个字符串相等，或根据本地排序规则没有区别，该方法返回 0。 说明：把 &lt; 和 &gt; 运算符应用到字符串时，它们只用字符的 Unicode 编码比较字符串，而不考虑当地的排序规则。以这种方法生成的顺序不一定是正确的。localeCompare() 方法提供的比较字符串的方法，考虑了默认的本地排序规则。ECMAscript 标准并没有规定如何进行本地特定的比较操作，它只规定该函数采用底层操作系统提供的排序规则。 实例：12345var array = ['白鸽', '麻雀', '大象', '狗', '猫', "鸡"];array = array.sort(function compareFunction(item1, item2) &#123; return item1.localeCompare(item2);&#125;);//["白鸽", "大象", "狗", "鸡", "麻雀", "猫"] 1、可以使用localeCompare() 方法来实现中文按照拼音排序，方法相当简单123456789var ary = [&#123;name:'朱小露', age: 20&#125;,&#123;name: '朱庭庭', age: 22&#125;,&#123;name: '朱新渝', age: 10&#125;];ary.sort(function(a, b)&#123; return (a.name).localeCompare(b.name);&#125;); console.log(ary); 实现字母、数字的混合排序：12345678var d = [1,2,3,'a','k','b','d',10,20,'c'] d.sort(function(a,b)&#123; var c = isFinite(a), // 如果 number 是有限数字（或可转换为有限数字），那么返回 true。否则，如果 number 是 NaN（非数字），或者是正、负无穷大的数，则返回 false。 d = isFinite(b); return (c != d &amp;&amp; d - c) || a &gt; b; &#125;) console.log(d);//[1, 2, 3, 10, 20, "a", "b", "c", "d", "k"] isFinite() 判断a、b是否是数字。return 后面的语句：c != d &amp;&amp; c - d 如果c和d不相等 ，也就是说比较的值不是同一类型。那就比较 c-d的值是1还是-1（中间进行了隐式类型转换）如果c == d 也就是说c、d是同一类型的值，c、d可能都是字母，也可能都是数字。这里就可以直接比较大小了（都是字母的话不能直接做减法）。isFinite() 函数用于检查其参数是否是无穷大。如果 number 是有限数字（或可转换为有限数字），那么返回 true。否则，如果 number 是 NaN（非数字），或者是正、负无穷大的数，则返回 false。]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS事件]]></title>
    <url>%2F2019%2F02%2F16%2F%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[什么是事件 事件分为两个部分： 行为本身：浏览器天生就赋予其的行为：onclickonmouseover(onmouseenter)onmouseout(onmouseseleace)onmousemove, onmousedown（鼠标左键按下）onmouseup(鼠标左键抬起)onmousewheel(鼠标滚轮滑动)onscroll(滚动条滚动行为)onresize(window.onresize浏览器窗口的大小改变事件)onloadonunloadonfocus(文本框获取焦点行为)onblur(文本框失去焦点行为)onkeydown(键盘的按下)onkeyup(键盘抬起) 哪怕没有给上述行为绑定方法，事件也是存在的，当我们点击这个盒子的时候，同样会触发它的onclick行为，只是什么事情都没有做而已 事件绑定：给元素的某一个行为绑定方法12345678910111213var oDiv = document.getElementById('div');//DOM0级事件绑定//onclick这个行为定义在当前元素的私有属性上oDiv.onclick = function()&#123; //当我们触发这个oDiv的click行为的时候，会把绑定的这个函数执行&#125;;//给oDiv的click事件绑定事件的另一种方式：//DOM2级事件绑定//addEventListener这个属性定义在当前元素所属EventTarget这个类的原型上oDiv.addEventListener('click', function()&#123; console.log('ok');&#125;, false); //false代表点击事件执行方式是同步的 事件对象 把函数定义的部分当做一个值赋值给oDiv的点击行为 —— 匿名函数之函数表达式当我们触发oDiv的点击行为的时候，会执行对应绑定上去的方法 重要：不仅仅是把绑定的方法执行了，而且浏览器还默认的给这个方法传递了一个参数值 123oDiv.onclick = function()&#123; console.log(arguments);&#125;; 123document.body.onclick = function(e)&#123; console.log(e.target);&#125;; MouseEvent: 鼠标事件对象 它是一个对象数据类型的值，里面包含了很多的属性名和属性值，这些都是用来记录当前鼠标的相关信息的 MouseEvent -&gt; UIEvent -&gt; Event -&gt; Object MouseEvent记录的是页面中唯一一个鼠标每一次触发事件的时候的相关信息，与在哪个元素上触发的没有关系 关于事件对象MouseEvent的兼容问题 事件对象本身的获取存在兼容问题：标准浏览器中是浏览器给方法传递的参数，只需要定义形参e就可以获取到，但是在IE6~8中浏览器不会给方法传递参数， 如果需要的参数的话，需要从window.event中获取。 e = e || window.event; e.type: 存储的是当前鼠标触发的行为类型：’click’ e.clientX/e.clientY：存储的是当前鼠标触发点的位置距离当前屏幕的左上角的位置的x/y轴的坐标值 e.target: 事件源，当前鼠标触发的哪个元素，那么它存储的就是那个元素，跟事件冒泡无关,但是在IE6~8中不存在这个属性（e.target的值是undefined）, 我们使用e.srcElement来获取事件源 e.target = e.target || e.srcElement; 123456document.body.onclick = function(e)&#123; console.log(e.target); //输出的值不是body，而是div#div&#125;;oDiv.onclick = function(e)&#123; console.log(e.target); //div#div&#125;; e.pageX/e.pageY: 当前鼠标触发点距离body左上角（页面第一屏幕最左上角，而不是当前屏幕）的x/y轴的坐标值, 但是在IE6~8下，没有这个属性，我们通过使用（e.clientX + 浏览器滚动条卷去的宽度）/（e.clientY + 浏览器滚动条卷去的高度）来获取pageX/pageY e.pageX = e.pageX || (e.clientX + (document.documentElement.scrollLeft || document.body.scrollLeft)); e.pageY = e.pageY || (e.clientY + (document.documentElement.scrollTop || document.body.scrollTop)); 12345oDiv.onclick = function(e)&#123; console.log(e.clientY); //538 console.log(e.pageY); //1043&#125;; e.preventDefault：阻止浏览器的默认行为, 但是在IE6~8下不兼容，需要使用 e.returnValue = false;来代替 e.preventDefault? p.preventDefault() : e.returnValue = false; 直接return false; 和上述的作用一样，阻止浏览器的默认行为 e.stopPropagation:阻止事件的冒泡传播，在IE6~8下不兼容，使用e.cancelBubble = true; 来代替 e.stopPropagation ? e.stopPropagation() : e.cancelBubble = rtue; e: keyboardEvent e.keyCode: 当前键盘上每一个键对应的值 常用键的值空格键（space）: 32回退键（Backspace）: 8回车键（Enter) : 13删除键（Del）: 46四个方向键: （左）: 37（上）: 38 （右）: 39 （下）: 40 事件的传播机制12345678910111213141516171819202122232425262728&lt;style type="text/css"&gt; body,div&#123; margin: 0; padding: 0; &#125; div&#123; width: 100%; height: 100%; &#125; .outer&#123; margin: 20px auto; padding: 20px; width: 300px; height: 300px; background-color: #95fb47; &#125; .center&#123; padding: 20px; width: 200px; height: 200px; background-color: #0cb788; &#125; .inner&#123; width: 100px; height: 100px; background-color: #03f0e8; &#125;&lt;/style&gt; 12345&lt;div id="outer" class="outer"&gt; &lt;div id="center" class="center"&gt; &lt;div id="inner" class="inner"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123var outer = document.getElementById('outer'), center = document.getElementById('center'), inner = document.getElementById('inner'); 事件的默认传播机制： 捕获阶段：从外向内依次查找元素 目标阶段：当前事件源本身的操作 冒泡阶段：从内到外依次触发相关的行为（最常用的就是冒泡阶段）123456789101112document.body.onclick = function()&#123; console.log('body');&#125;;outer.onclick = function()&#123; console.log('outer');&#125;;center.onclick = function()&#123; console.log('center');&#125;;inner.onclick = function()&#123; console.log('inner');&#125;; 输出结果:使用DOM0级事件绑定给元素的某一个行为绑定的方法，都是在行为触发后的冒泡阶段把方法执行的123456789101112document.body.onclick = function(e)&#123; console.log(e);&#125;;outer.onclick = function(e)&#123; console.log(e);&#125;;center.onclick = function(e)&#123; console.log(e);&#125;;inner.onclick = function(e)&#123; console.log(e);&#125;; addEventListener： 第一个参数是行为的类型 第二个参数是给当前的行为绑定的方法 第三个参数是控制在哪个阶段发生： true 在捕获阶段发生 false 在冒泡阶段发生123456789101112document.body.addEventListener('click', function()&#123; console.log('body');&#125;, false);document.body.addEventListener('click', function()&#123; console.log('body');&#125;, false); //冒泡阶段outer.addEventListener('click', function()&#123; console.log('outer');&#125;, true); //捕获阶段center.addEventListener('click', function()&#123; console.log('center');&#125;, false); //冒泡阶段 事件委托 利用事件冒泡的传播机制（触发当前这个元素的某个行为，它的父级所有元素的相关行为都会被触发），如果一个容器中有很多元素都要绑定点击事件，就没有必要一个个的绑定了，只需要给最外层容器绑定一个点击事件即可，在这个方法执行的时候，通过事件源的区分来进行不同的操作12345678var outer = document.getElementById('outer'); var center = document.getElementById('center'); var inner = document.getElementById('inner'); document.body.onclick = function(e)&#123; e = e || window.event; e.target = e.target || e.srcElement; console.log(e.target);&#125;]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的判断操作语句]]></title>
    <url>%2F2019%2F02%2F16%2F%E5%88%A4%E6%96%AD%E6%93%8D%E4%BD%9C%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[if \ else if \ else12345678910111213141516171819if(条件1)&#123; //=&gt;条件1成立执行的操作&#125;else if(条件2)&#123; //=&gt;上面条件不成立，条件2成立，执行的操作&#125;...else&#123; //=&gt; 以上条件都不成立执行的操作&#125;&lt;!--more--&gt;如果好几个条件都成立了，只把第一个成立的条件执行，后面成立的条件忽略不管条件：A == B、 A != B 、A &gt;= B 、A &lt; Bif(A)&#123;&#125; //先把A转换为布尔类型，判断真假以此来决定条件是否成立if(A &gt; B &amp;&amp; A &lt; 10)&#123;&#125; //只有两个小条件都是真的，整体条件才为真if(A &gt; B || A == 0)&#123;&#125; //只有其中一个小条件成立，整体条件就是真... BAT面试题请问最后的结果是什么？答案是：字符串0 &#39;0&#39;parseFloat(&#39;width:12.5px&#39;); //-&gt; 结果为NaN且NaN != NaN 三元运算符 条件？条件成立执行：条件不成立执行； if(条件){}else1{}: 三元运算符就是这种简单if、else的另一种写法举例1：举例2：举例3：举例4：举例5： switch case switch case 应用于if、else中一个变量在不同值情况下的不同操作案例1：案例2：案例3：案例4： 循环操作语句 循环： 重复做一件事情 for循环12345for(设置循环起始值；设置循环执行的条件；步长累加)&#123; //=&gt;循环体： 重复做的事情都在循环体中&#125;]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数据类型之值数据类型]]></title>
    <url>%2F2019%2F02%2F16%2F%E5%80%BC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数字(number)、布尔(boolean)、字符串(string)、null、undefined Boolean() 把其它数据类型的值转换为布尔类型只有0、NaN、空字符串、null、undefined、false这六个数据值转换为布尔类型的false， 其余的都会被转换为true ！ !=：不等于叹号在JS中还有一个作用：取反，先把值转换为布尔类型，然后再去取反。 !! 在一个叹号取反的基础上在取反，取两次反相当于没有做操作，但是却已经把其它类型值转换为布尔类型了，和Boolean() 是相同的效果 字符串 在JS中 单引号和双引号包裹起来的都是字符串 12312 -&gt;number'12' -&gt; string'[12, 23, 45]' -&gt; string 常用方法 charAt() charCodeAt()substr() substring() slice()toUpperCase() toLowerCase()indexOf() lastIndexOf()split()replace()match()… number数字 0 12 -12 12.5 ，此外JS中多增加了一个number类型的数据：NaNtypeof NaN =&gt; “number” NaN NaN 是not a number的缩写，它不是一个数，但是属于number类型NaN == NaN: 其结果为false， NaN和任何其他值都不相等 isNaN() 用来检测当前这个值是否是非有效数字，如果不是有效数字，则返回结果为true, 反之是有效数字则为false 1234isNaN(0) =&gt; falseisNaN(NaN) =&gt; trueisNaN('12') =&gt; false, 当我们使用isNaN检测值的时候，检测的值不是number类型的，浏览器会默认把值先转换为number类型，然后再去检测 Number() 把其它数据类型值转换为number类型 的值123456789101112131415Number('12') =&gt; 12Number('12px') =&gt; NaN 在使用Number转换的时候只要字符串中出现任何一个非有效数字字符，最后的结果都是NaNNumber(true) =&gt; 1Number(false) =&gt; 0Number(NaN) =&gt; 0Number(undefined) =&gt; NaNNumber([]) =&gt; 把引用数据类型转换为number,首先需要把引用数据类型转为字符串（toString），在把字符串转换为number即可，例如： [] -&gt; '' '' -&gt; 0Number([12]) -&gt; [12] -&gt;'12' '12' -&gt; 12 Number([12,23]) -&gt; [12,23] -&gt; '12,23' '12,23' -&gt;NaNNumber(&#123;name:'zxl'&#125;) =&gt; NaNNumber(&#123;&#125;) =&gt; NaN parseInt() 也是吧其它数据类型值装换为number, 和Number方法在处理字符串的时候有所区别123Number('12px') -&gt; NaNparseInt('12px') -&gt; 12pareInt('12px13') -&gt; 12 提取规则：从左到右依次查找有效数字字符，直到遇见非有效数字字符为止（不管后面时候还有，都不找了），把找到的转换为数字，如果第一个都不是数字，那么结果为NaN。 parseFloat() 在parseInt()的基础上可以识别小数点12parseInt('12.5px') -&gt; 12parseFloat('12.5px') -&gt; 12.5 parseInt()常用的只需要床底一个值作为参数即可，但是它支持多个参数，但是它还存在其它参数，例如：parseInt(‘12.5’, 10)的意思是：将12按照十进制进行解析。编写则默认转换为十进制。 null和undefined null: 空， 没有undefined: 未定义， 没有 ‘’: 空字符串， 没有0： 也可以理解为没有 空字符串和null的区别 拿种树打比方：空字符串属于挖了个坑，但是没有种任何东西null是连坑都没挖 空字符串相对于null来说开辟了内存，消耗了那么一丢丢的性能 null和undefined的区别 null一般都是暂时没有，预期中以后会有的（可能以后也没有达到预期）：在JS中null一般都是手动先赋值为null,后期我们再给其赋具体值 undefined: 完全没在预料之内的 例子：小明是个帅气的男孩子，他现在的女朋友滴null,他的男朋友是undefined]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM2级事件]]></title>
    <url>%2F2019%2F02%2F16%2FDOM2%E7%BA%A7%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[123456789101112&lt;style type="text/css"&gt; html,body,div&#123; margin: 0; padding: 0; &#125; #box&#123; margin: 50px auto; width: 200px; height: 200px; background-image: linear-gradient(to top, #df89b5 0%, #bfd9fe 100%); &#125;&lt;/style&gt; 1&lt;div id="box"&gt;&lt;/div&gt; 使用DOM2级事件绑定，其实是让box通过原型链一直找到EventTarget这个内置类原型上的addEventListener方法实现的DOM0级事件绑定：只能给一个元素的某一个行为绑定一个方法，第二次绑定的会把第一次绑定的方法覆盖掉12345678var box = document.getElementById("box");box.onclick = function(e)&#123; console.log(1);&#125;box.onclick = function(e)&#123; console.log(2);&#125;//只会输出2 DOM2级事件绑定：可以个某一个元素的同一行为绑定多个不同的方法1234567box.addEventListener('click', function(e)&#123; console.log(1); &#125;, false); //false表示将匿名函数绑定在冒泡阶段 box.addEventListener('click', function(e)&#123; console.log(2); &#125;, false);//1,2都会输出 DOM0级中的行为（事件）类型，用DOM2级一样可以绑定，而且DOM2级中还提供了DOM0级中没有的行为类型，DOMContentLoaded：当页面页面中的DOM结构（HTML结构加载完成）触发的行为1document.addEventLitener('DOMContentKoaded', function(e)&#123;&#125;, false); window.onload = function(e){}：当页面中的所有资源都加载完成了（图片，HTML结构、音视频。。）才会执行后面的函数；并且在一个页面中只能用一次，后面再写会把前面的覆盖掉；因为它采用的DOM0级事件绑定，只能绑定一次jQuery: $(document).ready(function(){}) &lt;=&gt; $(function(){})只要当页面中的HTML结构加载完成就会执行对应的函数，并且在同一个页面中可以出现多次原理：使用DOM2级事件绑定的方式绑定DOM2中新增的那个DOMContentLoaded行为onload绑定多个方法：利用DOM2级事件绑定12window.addEventListener('load', function(e)&#123;&#125;, false);window.addEventListener('load', function(e)&#123;&#125;, false); DOM2级绑定事件时，最好不要使用匿名函数的方式，因为如果绑定的匿名函数，则想要移除绑定的事件时，是不知道需要移除哪个事件的，因此最好是绑定一个有名字的函数123456789101112box.addEventListener('click', function(e)&#123; console.log(this); //这里的this是当前元素box&#125;, false);box.removeEventListener('click', function(e)&#123; //两个匿名函数不是同一个，因此上面绑定的匿名函数没有被移除掉 console.log(this); &#125;, false)function fn1()&#123; console.log(this);&#125;box.addEventListener('click', fn1, false);box.removeEventListener('click', fn1, false); 移除的时候需要保证三个参数：行为、方法、哪个阶段发生，一点都不能差，在使用DOM2级事件的时候，一般都会给它绑定的是实名函数 只能给某一个元素的同一个行为绑定多个“不同”的方法（如果方法相同了，只能保留一个）当行为触发，会按照绑定的先后顺序依次把绑定的方法执行了, 执行的方法中this是当前被绑定事件的元素本身 123456789101112131415161718192021function fn1(e)&#123; console.log(1)&#125;;function fn2(e)&#123; console.log(2)&#125;;function fn3(e)&#123; console.log(3)&#125;;function fn4(e)&#123; console.log(4)&#125;;function fn5(e)&#123; console.log(5)&#125;;function fn6(e)&#123; console.log(6)&#125;;function fn7(e)&#123; console.log(7)&#125;;function fn8(e)&#123; console.log(8)&#125;;function fn9(e)&#123; console.log(9)&#125;;function fn10(e)&#123; console.log(10)&#125;; box.addEventListener('click', fn1, false); box.addEventListener('click', fn2, false); box.addEventListener('click', fn3, false); box.addEventListener('click', fn4, false); box.addEventListener('click', fn9, false); box.addEventListener('click', fn10, false); box.addEventListener('click', fn5, false); box.addEventListener('click', fn6, false); box.addEventListener('click', fn7, false); box.addEventListener('click', fn8, false); 在IE6~8下，不支持addEventListener/removeEventListener，如果想要实现DOM2级事件绑定只能用attachEvent/detachEvent, 它只有两个参数，不能像addEventListener那样控制在哪个阶段发生，默认只能在冒泡阶段发生行为需要添加“on”(和DOM0级事件特别的类似)12345678910box.attachEvent("onclick", fn1);box.attachEvent("onclick", fn2);box.attachEvent("onclick", fn3);box.attachEvent("onclick", fn4);box.attachEvent("onclick", fn5);box.attachEvent("onclick", fn6);box.attachEvent("onclick", fn7);box.attachEvent("onclick", fn8);box.attachEvent("onclick", fn9);box.attachEvent("onclick", fn10); 事件池： 是用来存储当前元素行为绑定的方法的（浏览器自带的机制）IE6~8下的事件池机制和标准浏览器的事件池机制对比： 顺序问题：执行的时候顺序是混乱的，标准浏览器是按照绑定的顺序执行的 重复问题：IE6~8下，可以给同一个元素的同一个行为绑定多个相同的方法，标准浏览器是不可以的 this问题：在IE6~8下，当方法执行的时候，方法中的this不是当前元素box,而是window; 而标准浏览器中的this是当前元素box]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS原型链模式扩展-批量设置公有属性]]></title>
    <url>%2F2019%2F02%2F16%2F%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95-%E6%89%B9%E9%87%8F%E8%AE%BE%E7%BD%AE%E5%85%AC%E6%9C%89%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[方式一：起一个别名12345678910functon Fn()&#123; this.x = 100;&#125;var pro = Fn.prototype;pro.a = function ()&#123;&#125;pro.b = function ()&#123;&#125;pro.c = function ()&#123;&#125; 把原来原型指向的地址赋值给pro，现在他们操作的是同一个内存空间。这种方式虽然简单，但是改变效果并不明显。 方式二：重构原型对象的方式 123456789101112functon Fn()&#123; this.x = 100;&#125;Fn.prototype = &#123; constructor：Fn, a:function()&#123; &#125;, b:functoin()&#123; &#125;, c:function()&#123; &#125;&#125; 自己新开辟一个堆内存，存储公有的属性和方法，把浏览器原来给Fn.prototype开辟的那个堆内存给替换掉 只有浏览器天生给Fn.prototype开辟的堆内存里才有constructor，而我们自己开辟的这个堆内存里面没有这个属性，这样constructor指向就不在是Fn，而是Object了，console.log(f.constructor); 没做任何处理之前是Object为了和原来的保持一致，我们需要手动的增加constructor的指向。 用这种方式给内置类增加公有的属性1234567//给内置类Array增加数组去重的方法Array.prototype = &#123; constructor: Array, unique: function()&#123; &#125;&#125;;console.log(Array.prototype ); 我们这种方式会把之前已经存在与原型上的属性和方法给替换掉，所以我们用这种方法修改内置类的话吗，浏览器是会屏蔽掉的。但是，我们可以一个个的修改内置的方法，当我们通过下述在数组的原型上增加方法，如果方法名和原来内置的方法名重复了，会把人家内置的修改掉，因此我们以后再内置类的原型上增加方法，命名都需要加商特殊的前缀。12345Array.prototype.sort = function()&#123; cosole.log("ok");&#125;;var ary = [1,2,3,4,3,1,1,5];ary.sort(); 可枚举与不可枚举1234567891011Object.prototype.aaa = function()&#123;&#125;;var obj = &#123;name: '朱小露', age: 20&#125;;for(var key in obj)&#123; //-&gt;for in循环在遍历的时候，默认的可以把自己私有的和在它所属类原型上扩展的属性和方法都可以遍历到，但是一般情况下，我们遍历的一个对象，只需要遍历私有的即可，我们可以使用以下的判断进行处理：(两种方式都可以) if(obj.prototypeIsEnumerable(key))&#123; console.log(key); &#125; if(obj.hasOwnProperty(key))&#123; console.log(key); &#125;&#125; Object.create(proObj) 创建一个新的对象，但是还要把proObj作为这个对象的原型，但是在IE6~8下不兼容（ECMAScript5）1234567891011121314151617var obj = &#123; getX: function()&#123; console.log("x"); &#125;&#125;;var obj2 = Object.create(obj);//obj2的结构：//__proto__: //getX:function... //__proto__:Object.prototypeobj.getY = function()&#123; console.log("y");&#125;obj2.getX();obj2.getY(); 各种浏览器都兼容的Object.create()123456789101112var obj = &#123; getX: function()&#123; console.log("x"); &#125;&#125;;function createObject(o)&#123; function Fn()&#123;&#125; Fn.prototype = o; return new Fn;&#125;var newObj = createObject(obj);console.dir(newObj); 1234567891011121314var obj = &#123; getX: function()&#123; console.log("x"); &#125;&#125;;function createObject(o)&#123; function Fn()&#123;&#125; Fn.prototype = o; return new Fn;&#125;function sum()&#123;&#125;sum.prototype = createObject(obj);console.dir(new sum);]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数据类型之对象数据类型]]></title>
    <url>%2F2019%2F02%2F16%2F%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bobject%2F</url>
    <content type="text"><![CDATA[var obj = {name: ‘珠峰’, age : 8}每个对象都是由零到多组属性名（Key键）：属性值（Value值）组成的，或者说有多组键值对组成的，每一组键值对中间用逗号隔开。属性：用来描述这个对象的特点特征的对象的属性名是字符串或者数字格式的，存储的属性值可以是任何的数据类型对象名.属性名：忽略了属性名的单双引号对象名[属性名]：不能忽略属性名的单双引号 12345678910111213141516171819202122var obj = &#123;name:'zxl',age:20, friend:['习大大', '彭麻麻']&#125;;//=&gt;获取某个属性名对应的属性值obj.nameobj['name']//=&gt;如果属性名是数字如何操作obj.0 语法不支持obj[0] / obj['0'] 两种都可以支持//=&gt;如果操作的属性名在对象中不存在，得到的结果是undefinedobj.sex =&gt; undefined//=&gt;设置 / 修改一个对象的属性名是不能重复的（唯一性），如果之前存在就是修改属性值的操作，反之不存在就是新设置属性的操作obj.sex = '男';obj['age'] = 21;//=&gt;删除//=&gt;假删除：让其属性值赋值为null，但是属性还在对象中obj.sex = null;//=&gt;真删除：把整个属性都在对象中暴力移除delete obj.sex; 思考题 obj[age]和obj[‘age’]有什么样的区别？1234var obj = &#123;name: 'zxl', age: 8&#125;;var age = '朱小露';obj[age]obj['age'] 区别如下 obj[age] obj[age] 中 age 其实是一个变量，不是obj对象中的属性。因为 age = ‘朱小露’, 所以 obj[age] &lt;=&gt; obj[ ‘朱小露’]由于obj对象中没有属性名为‘朱小露’,因此结果为undefined.如果我们为obj增加一个1属性名为“朱小露”的属性，则obj[age]的就是其属性的属性值 obj[&#39;age&#39;] 这里的’age’单纯的指属性名，因此obj[‘age’] = 8; 基本数据类型和引用数据类型的区别 JS是运行在浏览器中的（内核浏览器），浏览器符为JS提供赖以生存的环境（提供给JS代码执行 的环境 ）=&gt; 全局作用域window（global） 12345678var a = 12;var b = a; //=&gt;把a变量存储的值赋值给bb = 13;console.log(a);var n = &#123;name: '珠峰'&#125;；var m = n;console.log(n.name); 基本数据类型是按值操作的：基本数据类型在赋值的时候，是直接把值赋值给变量即可。引用数据类型是按照空间地址（引用数据地址）来操作的：var n = {name: ‘珠峰’}; 1、先创建一个变量n； 2、浏览器首先会开辟一个新的存储空间（内存空间），目的是把对象中需要存储的内容（键值对）分别的存储在这个空间中，为了方便后期找到这个空间，浏览器给空间设定一个地址（十六进制的） 3、把空间的地址赋值给了变量 函数数据类型 函数数据类型也是按照引用地址来操作的函数：具有一定功能的方法 12345678//=&gt;创建函数function 函数名()&#123; //=&gt;函数体： 实现某一个功能的具体JS代码&#125;//=&gt;执行函数: 相当于使用洗衣机洗衣服（如果函数只创建了，但是没有去执行，函数没有任何的意义）函数名（）； 123456function fn()&#123; console.log(1+1);&#125;fn; =&gt;输出函数本身fn();=&gt;把函数执行 （把函数体中实现功能的代码执行） 123456789//=&gt;形参： 形式参数（变量），函数的入口//当我们创建一个函数想要实现某个功能的时候，发现有一些材料并不清楚，只有当函数运行的时候，别人传递给我，我才知道，此时我们就需要设定入口，让用户执行的时候通过入口把值给我们function fn(num1, num2)&#123; console.log(num1 + num2);&#125;//=&gt; 实参：函数执行传递给函数的具体值就是实参fn(1,2);fn(10,20); arguments实参集合 当我们不知道用户具体传递几个值的时候（传递几个值都行了），此时我们无法设置形参的个数；遇到此类需求，需要使用函数内置的实参集合：arguments1、arguments只有函数才有2、不管执行函数的时候是否传递实参，arguments天生就存在，没有传递实参时，ARG是一个空集合，传递了实参时，ARG中包含了所有传递的实参值3、不管是否设置了形参，ARG中始终存储了所有的实参信息arguments是一个类数组集合1、以数字作为索引（属性名），从零开始arguments[0]第一个实参信息arguments[1]第三个实参信息arguments[n]第n+1个实参信息2、有一个length的属性，存储的是当前集合长度（当前传递实参的个数）arguments.lengtharguments[‘length’]arguments.callee: 存储的是当前函数本身arguments.caller: 存储的是当前函数在哪执行的（宿主函数），在全局作用域下执行的，结果是null 123456789"use strict"; //在JS代码执行之前加入这句话；开启JS的严格模式function sum()&#123; console.log(arguments.callee);//ERROR: Uncaught TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them&#125;"use strict"sum();//arguments.callee或者arguments.callee.caller一般真正项目中很少使用：因为在严格的JS模式下不允许我们使用这两个属性，然而现有项目大部分都是基于严格模式来的 JS中的返回值return 返回值是函数提供的一个出口：我们如果想在外面使用函数私有的一些信息，那么就需要通过return，把这些信息返回出来供外边使用。 任意数求和完整版 ###JS中的匿名函数 没有名字的函数 函数表达式 自执行函数 函数表达式12345oBox.onclick = function()&#123;//=&gt;把一个没有名字的函数（有名字也无所谓）作为值赋值给一个变量或者一个元素的某个事件： . 函数表达式 .&#125; 自执行函数 12345678910111213;(function(n)&#123; //=&gt;创建函数和执行函数放在一起了，创建完成你嘛执行； . 自执行函数. //=&gt; n形参 n = 10&#125;)(10)//=&gt; 以下都是自执行函数，符号只是控制语法规范~function(n)&#123;&#125;(10);-function(n)&#123;&#125;(10);+function(n)&#123;&#125;(10);!function(n)&#123;&#125;(10);]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础之数据类型检测的四种方式]]></title>
    <url>%2F2019%2F02%2F16%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. typeof用来检测数据类型的运算符123console.log(typeof 12); //"number"var num = "zhuxiaolu";console.log(typeof num); //"string" 使用typeof检测数据类型，首先返回的都是一个字符串，其次字符串中包含了对应的数据类型，例如：”number”, “string”, “boolean”, “undefined”, “function”, “object”console.log(typeof typeof typeof function fn(){}); //=&gt; &quot;function&quot;局限性typeof null -&gt; &quot;object&quot;不能具体的细分是数组还是正则，还是对象中的其他的值，因为使用typeof检测数据类型，对于对象数据类型中的所有的值，最后返回的结果都是&quot;object&quot;应用场景12345678910111213function fn(num1, num2)&#123; if(typeof num2 === "undefined")&#123; num2 = 0; &#125; //也可以简写成：num2 = num2 || 0;&#125;fn(10);function fn2(callback)&#123; typeof callback === "function" ? callback() : null; //也可以简写成：callback &amp;&amp; callback();&#125;fn(function()&#123;&#125;); 2. instanceof检测某一个实例是否属于某个类123var ary = [12, 23];console.log(ary instanceof Array); //trueconsole.log(ary instanceof Function); //false 局限性123console.log(1 instanceof Number); //falseconsole.log(new Number instanceof Number); //trueconsole.log((2.3333).toFixed(2)); //2.33 不能用来处理由字面量方式创建出来的基本数据类型值对于基本数据类型来说，字面量创建出来的结果和实例方式创建出来的结果是有一定区别的，从严格意义上来讲，只有实例创建出来的结果才是标准的对象数据类型的值，也是标准的Number这个类的一个实例；对于字面量方式创建出来的结果是基本的数据类型的值，不是严谨的实例，但是由于JS的松散特点，导致了可以使用Number.prototype上提供的方法 instanceof的特性：只要在当前实例的原型链上，我们用其检测出来的结果都是true1234567var ary = [];console.log(ary instanceof Array); //trueconsole.log(ary instanceof Object); //truefunction fn()&#123;&#125;console.log(fn instanceof Function); //trueconsole.log(fn instanceof Object); //true 在类的原型继承中，我们最后检测出来的结果未必是准确的123456function Fn()&#123;&#125;var ary = new Array;Fn.prototype = ary; //原型继承：让子类的原型等于父类的一个实例var f = new Fn;console.log(f instanceof Array); //true f -&gt; Fn.prototype -&gt; Array.prototype -&gt; Object.prototype 3. constructor构造函数 作用和instanceof非常的相似123var ary = [];console.log(ary.constructor === Array); //trueconsole.log(ary.constructor === RegExp); //false constructor可以处理基本数据类型的检测12var num = 1;console.log(num.constructor === Number); //true constructor检测Object和instanceof不一样，一般情况下是检测不了的123var reg = /^\d$/;console.log(reg.constructor === RegExp); //trueconsole.log(reg.constructor === Object); //false 局限性：我们可以把类的原型进行重写，在重写的过程中，很有可能出现把之前的constructor给覆盖了，这样检测出来的结果就是不准确的123456function Fn()&#123;&#125;var ary = new Array;Fn.prototype = ary; //原型继承：让子类的原型等于父类的一个实例var f = new Fn;console.log(f.constructor === Array); //true 对于特殊的数据类型null和undefined，他们的所属类是Null和Undefined，但是浏览器把这两个类保护起来了，不允许我们在外面访问使用 4. Object.prototype.toString.call() 最准确、最常用的方式首先获取Object原型上的toString方法，让方法执行，并且改变方法中this关键字的指向Object.prototype.toString它的作用是返回当前方法的执行主体（方法中的this）所属类的详细信息1234var obj = &#123;name: "zhuxiaolu"&#125;;console.log(obj.toString());//-&gt;[object Object]//toString中的this是obj，返回的就是obj所属类的信息 [object Object]中，第一个object代表当前实例是对象数据类型的（这个是固定的），第二个Obeject代表的是obj是Object这个类的一个实例，也就是说obj所属类是Object12345678910var ary = [];console.log(Object.prototype.toString.call(ary));console.log(Object.prototype.toString.call(/^\d$/));console.log(Object.prototype.toString.call(new Date));console.log(Object.prototype.toString.call(1));console.log(Object.prototype.toString.call("zhuxiaolu"));console.log(Object.prototype.toString.call(true));console.log(Object.prototype.toString.call(null));console.log(Object.prototype.toString.call(undefined));console.log(Object.prototype.toString.call(function()&#123;&#125;)); 应用示例：检测一个变量是否是数组数据类型的1234var ary = [];console.log(Object.prototype.toString.call(ary) === "[object Array]"); //truevar reg = /^\[object\sArray\]$/;console.log(reg.test(Object.prototype.toString.call(ary))); //true 解决instanceof和constructor的局限性1234567function Fn()&#123;&#125;Fn.prototype = new Array;var f = new Fn;console.log(f.constructor === Array); //trueconsole.log(f instanceof Array); //trueconsole.log(Object.prototype.toString.call(f) === "[object Array]"); //false 5.toString的理解 乍一看应该是转换为字符串，但是某些toString方法不仅仅是转换为字符串对于Number,String, Boolean, Array, RegExp, Date, Function原型上的toString方法都是把当前的数据类型转换为字符串类型（他们的作用仅仅是用来转换为字符串的）Object.prototype.toString并不是用来转换为字符串的({name: &quot;朱小露&quot;}).toString() -&gt; “[object] Object]”Match.toString(); -&gt; [object, Math]]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础之将类数组转换为数组]]></title>
    <url>%2F2019%2F02%2F16%2F%E5%B0%86%E7%B1%BB%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[1234var oLis = document.getElementsByTagName('div');console.dir(oLis); //HTMLCollection元素集合类的一个实例，同时它也是一个类数组集合oLis = document.getElementsByName('box');console.dir(oLis); //NodeList节点集合，它也是一个类数组集合 在IE6~8浏览器中，不支持借用数组的slice方法实现将元素集合的类数组转换为数组SCRIPT5014: Array.prototype.slice: &#39;this&#39; 不是 JavaScript对象 （报错）但是对于arguments借用数组的方法是不存在任何兼容性问题的1234//标准var oLis = document.getElementsByTagName('div');var ary = Array.prototype.slice.call(oLis);console.log(ary); 1234//非标准for(var i = 0; i &lt; oLis.length; i++)&#123; ary[ary.length] = oLis[i];&#125; 浏览器异常信息捕获12console.log(num);console.log('ok'); 在JS代码中，在没有做任何处理的情况下，报错代码之后的代码都不会执行12345try&#123; console.log(num);&#125;catch(e)&#123; &#125;console.log('ok'); 如果用try/catch做异常捕获，则不会影响下面的代码继续执行，如果try中的代码执行出粗了，会默认的去执行catch中的代码catch的形参必须要写，一般起名叫做e123456try&#123; console.log(num);&#125;catch(e)&#123; console.log(e.message);&#125;console.log('ok'); e.message可以收集当前代码报错的原因 12345678try&#123; //JS 代码块&#125;catch(e)&#123; //如果代码报错执行catch中的代码&#125;finally //一般不用，不管try中的代码是否报错，都要执行finally中的代码&#125;console.log('ok'); 有时候即想捕获到错误的信息，又不想让下面的代码继续执行12345678try&#123; console.log(num);&#125;catch(e)&#123; console.log(e.message); //可以得到错误信息，把其进行统计 //手动抛出一条错误信息，终止代码继续执行 throw new Error('当前网络繁忙，请稍后再试~~');&#125;console.log('ok'); new TypeError =&gt; 类型错误new ReferenceError =&gt; 引用错误new RangeError =&gt; 范围错误 将类数组转换为数组最终版（解决浏览器兼容问题）1234567891011121314var utils = &#123; //listToArray：实现将类数组转换为数组 listToArray: function (likeArray)&#123; var ary = []; try&#123; ary = Array.prototype.slice.call(likeArray); &#125;catch(e)&#123; //如果IE6~8不支持上述方法，就会报错，将执行catch中的代码 for(var i = 0; i &lt; likeArray.length; i++)&#123; ary[ary.length] = likeArray[i]; &#125; &#125; return ary; &#125;&#125;]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中数组的基本结构]]></title>
    <url>%2F2019%2F02%2F16%2F%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数组也是对象数据类型的typeof [] -&gt; &#39;object&#39; 数组也有属性名，只不过属性名是数字，我们把数字属性名称之为它的索引：数组是以数字作为索引，索引从零开始，有一个length属性代表数组的长 类数组：类似于数组，但是不是数组1、通过getElementsByTagName()获取的元素集合是类数组2、函数中的实参集合arguments也是类数组… FOR 循环 与 FOR IN 循环 数组中常用方法 数组中有很多常用的方法console.dir(Array.prototype) 1、方法的意义和作用2、方法的形参3、方法的返回值4、通过此方法，原来的数组是否发生了变化 实现数组的增加、修改、删除 1var ary = [12, 23, 34]; 数组的查询 参数异常的情况： 将两个数组进行拼接 把数组转换为字符串的 实现数组中每一项的排序和排列 验证数组中是否包含某一项 遍历数组每一项 数组去重 解决方法方法1：方法2： 方法3：版本一: 版本二： 版本三： 方法4： 冒泡排序 快速排序 插入排序]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器内核]]></title>
    <url>%2F2019%2F02%2F16%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[作为前端开发，我们会使用HTML/CSS/JS编写代码，编写代码的时候要遵循一些规范（W3C） 浏览器开发商开发的浏览器，目的就是为了按照W3C的规范，识别出开发者编写的代码，并且在页面中绘制出开发者预想的页面和效果(利用显卡：GPU),我们把浏览器中识别代码绘制页面的东西称为“浏览器的内核或者渲染引擎”]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电脑命名知识]]></title>
    <url>%2F2019%2F02%2F16%2F%E7%94%B5%E8%84%91%E5%91%BD%E5%90%8D%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[(DOS命令窗口中的一些常用DOS命令：windows键 + R -&gt; 运行命令框中输入cmd)| DOS命令| 解释|| :——– | :——–|| ipconfig / ipconfig -all| 查看自己电脑的IP地址 || ping www.baidu.com -t| 查看自己电脑的网络状况 || ctrl + c| 终止正在运行的DOS命令 || exit | 关掉DOS命令窗口|| cls| 清屏| 文件夹命令| DOS命令| 解释|| :——– | :——–|| cd ../ | 返回当前文件夹目录的上一级目录|| cd ./| 当前目录不变 || cd /| 返回当前磁盘的根目录 || D：| 直接进入到D盘|| cd 目录名称| 进入到指定的文件夹中|| dir | 查看当前文件夹下包含的目录（包含隐藏文件）| 以上所有的操作基本都是为了进入具体的某一个文件夹下操作，但是我们可以不必要这么纠结，我们可以直接找到对应的文件夹，在文件夹的空白处：shift + 鼠标右键,在此处打开命令窗口 如何发布一个网站 自己做一个网站，想让别人可以看见，该如何做？ 买一台服务器（云服务器），服务器连上网络之后，会存在一个外网IP地址；把我们开发的项目源文件（HTML/CSS/JS/IMG…）都上传到服务器上（FTP上传） 买一个域名（万网） 进行DNS解析（域名解析） DNS是一个网络服务器，我们的域名解析其实就是在DNS上记录一天信息记录：ww.baidu.com 220.114.23.56（服务器外网IP地址） 80(服务器端口号) 当用户在自己的浏览器中输入一个网址的时候，到最终看到页面和内容，发生了哪些事情？ 服务器的端口号（0~65535） 我们的一台服务器上可以发布很多项目，而每一个项目都有一自己对应的房间或者区域，服务器使用端口号来区分具体是哪一个项目一般我们把自己的项目发布到80/443这两个端口下 谷歌浏览器控制台（F12）NetWork这一项，可以看到当前客户端想服务器发送的所有请求以及请求的状态信息等通过在NetWork中观看看，我们发现当我们第一次把HTML源代码请求回来的时候，浏览器开始按照自己的引擎渲染，在渲染的过程中我们还会出现重新想服务器请求的CSS/JS/IMG。。。每一次的请求步骤和HTML 的步骤一模一样；如果请求的资源次数过多，页面打开的速度和渲染的速度就会变慢，所以我们以后在页面优化的方法中，首先要做的就是减少资源请求数（即减少HTTP请求） CSS合并成一个， 或者如果CSS不是很多的话，我们采用内嵌式CSS JS合并成为一个， 或者如果JS不是很多的话，我们采用内嵌式JS 图片合并（雪碧图技术/ CSS Sprite， 或者图片延迟加载 Ajax请求和源文件的请求原理是一样的 URI/URL/URN URI: 统一资源标识/统一资源信息 URI = URL + URN 不常用 URL: 统一资源定位符 http://v.qq.com:80/index.html?name=zhuxiaolu&amp;age=21#usc;http: 传输协议，客户端给服务器端的内容和服务器端传递给客户端的内容都是通过HTTP传输协议进行传输的v.qq.com：域名80：端口号index.html：请求资源文件名，告诉服务器需要请求的资源文件是哪一个?name=zhuxiaolu&amp;age=21：URL问号传参，客户端传递给服务器端的内容（客户端可以把一些值传递给服务器端，服务器端依然可以把一些内容传递给客户端）‘#usc’：URL的hash(锚点定位) 传输协议 HTTP: 超文本传输协议，除了传输文本外还可以传输其他东西，例如：XML，音视频等HTTPS: 更加安全的HTTPFTP: 文件传输协议（应用于把项目源文件传递到服务器上）在不指定服务器端口的情况下，每一种协议会有一个默认会找的端口地址HTTP默认会找服务器的80端口HTTPS默认会找服务器的443端口FTP默认会找服务器的21端口 URN: 统一资源名称]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[真实项目中的开发流程及API接口文档]]></title>
    <url>%2F2019%2F02%2F16%2F%E7%9C%9F%E5%AE%9E%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E5%8F%8AAPI%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSONP请求]]></title>
    <url>%2F2019%2F02%2F16%2FJSONP%2F</url>
    <content type="text"><![CDATA[如果用ajax发送非同源请求，则会报错： JSONP的原理 利用元素JS写JSON的方法步骤]]></content>
      <categories>
        <category>JSONP</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础，JSONP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX基础知识]]></title>
    <url>%2F2019%2F02%2F16%2FAJAX%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[async javascript and xml异步的JS和XML客户端的JS代码中，用来向服务器发送请求（还可以传递给服务器端数据），然后把服务器端返回的内容获取到（Ajax一般是运行在客户端的浏览器中的）XML可扩展的标记性语言（在XML文件中使用的标签都是自己扩展的）利用自己扩展的有规则的标记来存储相关数据 AJAX的四步 第一步：创建一个AJAX对象（下面这种写法在IE）及更低版本的浏览器中不支持var xhr = new XMLHttpRequest; 第二步：发送前的基本信息配置： ‘get’：配置请求方式（GET、POST、PUT、DELETE、HEAD） ‘../data.txt’：打开一个URL地址（配置向哪个服务器地址发送请求） false：同步还是异步（true代表异步，false代表同步），默认值是true username: 向服务器提供请求的用户名 userpass: 向服务器提供请求的用户密码 这两个参数一般都不写，只有当服务器做了安全的限制时，只允许特定的用户访问，才传递参数过去xhr.open(&#39;get&#39;, &#39;../data.txt&#39;, false, [username], [userpass]); 第三步：给onreadystatechang这个事件绑定一个方法，监听状态的改变（只要状态发生改变，就会触发这个事件，继而执行绑定的方法）xhr.readtState: Ajax状态码，可以代表当前AJAX处理的进度| 状态码 | 代码标识| 解释|| :——–| :——–| :——: || 0 | UNSENT | 当前的请求还没有开始发送|| 1 | OPENED | URL地址已经打开（发送前的参数配置已经完成）|| 2 | HEADERS_RECEIVED| 响应头信息已经接收|| 3 | LOADING| 主要返回的内容正在服务器端进行准备处理|| 4 | DONE| 响应主体的内容已经成功返回到客户端|xhr.status：HTTP网络状态码，描述了服务器响应内容的状态| HTTP网络状态码|解释|| :——– | :—— || 200 OR /^2\d{2}$/(200或者以2开头的2位数) | 响应主体的内容已经成功返回了|| 301 | 永久重定向/永久转移，一个网站更改了地址，但是用户用以前的地址访问时，地址就会跳转为新的地址|| 302 | 临时重定向/临时转移，服务器的负载均衡，当一台服务器已经超负荷了之后，会将用户的请求跳转到其他的服务器上进行处理|| 304 | 本次获取的内容是读取缓存中的内容，这样会加快页面显示的速度|| 400 | 客户端传递给服务器端的参数出现错误|| 401 | 无权限访问|| 404 | 客户端访问的地址不存在|| 500 | 未知的服务器错误|| 503 | 服务器已经超负荷了，一台服务器能承受10000人同时访问，那么第10001个人进行访问时，如果没有做服务器的负载均衡，那么返回的状态码就是503|xhr.onreadystatechange = function(){ if(xhr.readyState === 4 &amp;&amp; /^2\d{2}$/.test(xhr.status)){ xhr.responseText; }} 第四步`发送请求：参数是请求主体中传递给服务器的内容xhr.send(null); AJAX的核心只有3步，第三步监听状态其实跟AJAX发送请求没有关系，因此不列为核心步骤。关键的一步是第三步：发送请求，如果没有第三步，则前面的步骤都是没有意义的 AJAX详细知识HTTP METHOD:客户端向服务器端发送请求以下的请求方式不管哪一种都可以服务器传递数据，也可以从服务器获取到数据，而且从本质意义上来讲是没有任何区别的，例如：用POST做的事情，用GET也能做，而接下来的区别都是目前开发约定俗成的规范GET 一般应用于从服务器获取数据（给服务器的数据少，从服务器拿的数据多），项目中最常用的请求方式是GET使用GET请求给服务器传递内容，一般都使用“URL问号传参的方式”xhr.open(&#39;get&#39;, &#39;/getList?name=12&#39;); POST 一般应用于向服务器推送数据（给服务器的数据多，从服务器拿的数据少）使用POST请求给服务器传递内容，一般都使用“请求主体的方式”xhr.open(&#39;post&#39;, &#39;/getList&#39;);xhr.send(&#39;{&quot;name&quot;:&#39;zhuxiaolu&#39;,&quot;age&quot;:12}&#39;) PUT 一般应用于给服务器上增加资源文件（上传图片功能） DELETE 一般应用于从服务器上删除资源文件 HEAD 一般应用于只获取服务器的响应头信息 GET 与 POST 的区别大小问题 GET请求传递给服务器的内容存在大小的限制，而POST理论上是没有限制的 缓存问题 GET请求会出现缓存（这个缓存不一定是304），POST是没有缓存的在项目中，GET请求一般不会让其出现缓存，则清理缓存: 在URL末尾追加一个随机数，让客户端每次请求的URL都是不一样的，则不会出现缓存 安全问题 一般来说GET不安全，因为通过URL传递参数是对外暴露的，容易泄露。而POST相对于安全些 同步（SYNC）与异步(ASYNC) JS是单线程的，最好使用异步编程 定时器是异步编程 事件绑定是异步编程 回调函数可以理解为异步编程 在AJAX中可以使用异步编程 如何理解同步与异步编程？现在有一个饭店，将饭店里的服务员理解成为线程，因为JS是单线程的，因此饭店中只有一个服务员 同步：在上午10：00，饭店进来一位顾客 -&gt; 服务员服务顾客 -&gt; 顾客点菜 -&gt; 服务员给后厨菜单 -&gt; 后厨完成菜品需要5分钟 -&gt; 服务员在一旁等待菜品完成，不进行任何活动，即使此时进来另外一位顾客，也不进行服务，直到第一位顾客的菜品完成，服务员方可服务第二位顾客,以此类推。。。异步：在上午10:00 ，饭店进来一位顾客 -&gt; 服务员服务顾客 -&gt; 顾客点菜 -&gt; 服务员给后厨菜单 -&gt; 后厨完成菜品需要5分钟 -&gt; 在10: 02，进来第二位顾客 -&gt; 服务员服务第二位顾客 -&gt; 第二位顾客点菜 -&gt; 服务员给后厨菜单 -&gt; 后厨完成菜品需要3分钟 -&gt; 在10:04进来一百位顾客 -&gt; 服务员服务这一百位顾客 -&gt; 在这期间，第一位顾客的菜品和第二位的菜品，后厨已经完成，但是服务员不会停止正在执行的任务，直到这100位顾客服务完，才会服务第二位顾客（这里需要注意，并不是第一位顾客先开始等待，就先服务它，而是按照等待时间的长短来服务的，第一位顾客的等待时长为5分钟，第二位顾客的等待时长为3分钟，因此先服务第二位顾客）。。。 案例123456var count = 0; window.setTimeout(function()&#123; count ++; console.log(count); //后输出，输出结果为：1 &#125;, 100); console.log(count); //先输出，输出结果为：0 1234567var count = 0; window.setTimeout(function()&#123; count ++; console.log(count);//后输出，输出结果为：1 &#125;, 0); //将定时器的时间设置为0，也不是立马执行，而是需要等待一段时间， //浏览器都有自己的一段默认时间 ：谷歌 5~6ms, IE 10~13ms console.log(count); //先输出，输出结果为：0 123456789101112var count = 0; window.setTimeout(function()&#123; console.log("A"); //后输出 &#125;, 10); window.setTimeout(function()&#123; console.log("B"); //先输出 &#125;, 6); var i = 0; while(i &lt; 100000000)&#123; i ++; &#125; //多个定时器，如果执行完成循环到达时间了，先执行时间的短的定时器，不是先设置哪个再执行哪个 ajax中的同步： 当ajax的任务开始的时候，需要到readystate === 4的时候，任务才结束，此时才可以处理其他的事情ajax的异步： 当ajax的任务开始的时候，不需要到readystate === 4的时候，依然可以继续做其他的任务，并且只有当其他的任务完成之后，才看readystate是否到4，到达4的时候，做一些相关操作12345678910111213141516171819202122232425262728293031323334353637 var xhr = createXHR(); xhr.open('get', '/index.html', false); //false是同步 xhr.send(null); //只有send之后，ajax向服务器发送请求的任务才开始，没有send之前，不算任务//绑定在open前，可以输出1，绑定在open之后，不能输出1,因为，在执行xhr.open()的时候，xhr.state已经变成1了，这时onreadystatechange还没有绑定呢，因此不会输出1 var xhr = createXHR(); xhr.open('get', 'ajax1.html', true); //true表示异步 xhr.onreadystatechange = function()&#123; console.log(xhr.readyState); //输出结果为2,3,4 &#125;; xhr.send(null); var xhr = createXHR(); xhr.open('get', 'ajax1.html', false); //false表示同步 xhr.onreadystatechange = function()&#123; console.log(xhr.readyState); //输出结果为4 &#125;; xhr.send(null); //因为这题ajax采用的同步编程，当为onreadstatechange绑定事件的时候，readystate = 1， // 而当执行xhr.send（）时，ajax任务进入等待队列，直到readysatte === 4时，才会执行别的任务，因为此时readystate = 4，继而执行onreadystatecahnge方法，输出的结果为4 var xhr = createXHR(); xhr.open('get', 'ajax1.html', true); //true表示同步 xhr.send(null); xhr.onreadystatechange = function()&#123; console.log(xhr.readyState); //输出的结果：2 3 4 &#125;; //因为这题ajax采用的是异步编程，即使onreadystatechange绑定方法在send的后面，请求过程中还是会执行其他的操作，所以会输出2,3,4 var xhr = createXHR(); xhr.open('get', 'ajax1.html', false); //false表示同步 xhr.send(null); xhr.onreadystatechange = function()&#123; console.log(xhr.readyState); //无输出结果 &#125;; //因为这题ajax采用的同步编程，当执行xhr.send（）时，ajax任务进入等待队列，直到readysatte === 4时，才会执行别的任务，紧接着为onreadstatechange绑定事件，此时的readystate = 4，而readstate不会再改变，因此绑定的方法永远不会执行，即无输出结果 获取浏览器的时间 （保证是异步编程，才可以得到状态2，同步是得不到状态2的）123456789101112var xhr = createXHR();xhr.open('head', 'ajax1.html', true); //true表示同步xhr.onreadystatechange = function()&#123; if(xhr.readyState === 2)&#123; //xhr.getResponseHeader：获取服务器的响应头信息 var time = xhr.getResponseHeader('Date'); console.log(new Date(time)); //Mon Jan 21 2019 13:14:04 GMT+0800 (中国标准时间) &#125; //当xhr.readyState === 4时，也可以获取到请求头时间，但是为什么要在2的时候获取呢， // 因为是为了更快的获取服务器事件，减少时间差，例如京东倒计时，必须要将客户端获取到的时间与服务器时间差值最小&#125;;xhr.send(null);]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础，AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中常用方法之获取元素的具体样式]]></title>
    <url>%2F2019%2F02%2F16%2FJS%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%B9%8B%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E5%85%B7%E4%BD%93%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[元素.style.属性名 需要我们把元素的样式都写在行内样式上才可以（写在样式表中是不管用的） 12console.log(box.style.height); //-&gt;""console.log(box.style.width); //-&gt;"200px" 在真实项目中，这种方式不常用，因为不能为了获取值而把所有的样式都写在行内（无法实现css与html分离） 使用window.getComputedStyle这个方法获得所有经过浏览器计算过的样式 所有经浏览器计算过的样式是指：只要当前元素标签可以在页面中呈现出来，那么它的所有样式都是经过浏览器计算过的（渲染过的），哪怕有些样式没有写，我们也可以获取到（获取的属性值是默认值）方法形参：window.getComputedStyle([当前要操作的元素对象]，[当前元素的伪类(一般我们不用写伪类，直接写null)])获取的结果是CssStyleDeclaration这个类的实例：包括了当前元素的所有样式属性和值 123console.log(window.getComputedStyle); //-&gt; ƒunction getComputedStyle() &#123; [native code] &#125;console.log(window.getComputedStyle(box, null)); //200pxconsole.log(window.getComputedStyle(box, null)["height"]); //200px 方法虽然好用，但是在IE6~8下是不兼容的，因为window下没有getComputedStyle这个属性 -&gt; 在IE6~8下执行会报错 console.log(window.getComputedStyle); //undefined在IE6~8下我们可以使用currentStyle来获取所有金经过浏览器计算过的样式console.log(box.currentStyle.height); //200px getCss方法：获取当前元素所有经过浏览器计算过的样式中的【attar】对应的值 1.使用try/catch来处理兼容 前提：必须保证try中的代码在不兼容浏览器中执行的时候出错，这样才可以用catch捕获到异常信息，进行其他处理，不管是什么浏览器，都需要把try中的代码执行一遍，如果当时是IE8，window.getComputedStyle本身是不兼容的，但是也要先把它执行一遍，报错了再把currEle.currentStyle执行一遍（比较消耗性能）1234567891011Object.prototype.myGetCss = function (attar)&#123; var val = null; try&#123; //google等浏览器下 val = window.getComputedStyle(this, null)[attar]; &#125;catch(e)&#123; //IE8浏览器下 val = this.currentStyle[attar]; &#125; return val;&#125;console.log(box.myGetCss("height")); 上述方法在IE8以下的浏览器都是不兼容的： 对象不支持“myGetCss”属性或方法 currEle:[Object]当前要操作的元素对象attar:[String]要获取的样式属性的名称123456789function getCss(curEle, attar)&#123; try&#123;//google等浏览器下 val = window.getComputedStyle(curEle, null)[attar]; &#125;catch(e)&#123; //IE8浏览器下 val = curEle.currentStyle[attar]; &#125; return val;&#125;console.log(getCss(box,"height")); 从报错原因出发：判读当前浏览器中是否存在这个属性或者方法，存在就兼容，不存在就不能兼容 第一种写法： 12345678910function getCss(curEle, attar)&#123; var val = null; if(&quot;getComputedStyle&quot; in window)&#123; 如果返回的是true，代表window下面存在getComputedStyle这个属性，兼容 val = window.getComputedStyle(curEle, null)[attar]; &#125;else&#123; //当前浏览器下面不存在这个属性，不兼容 val = curEle.currentStyle[attar]; &#125; return val;&#125; 第二种写法:12345678910function getCss(curEle, attar)&#123; var val = null; if(typeof window.getComputedStyle === "function")&#123; //如果返回的是true，代表window下面存在getComputedStyle这个属性，兼容 val = window.getComputedStyle(curEle, null)[attar]; &#125;else&#123; //当前浏览器下面不存在这个属性，不兼容 val = curEle.currentStyle[attar]; &#125; return val;&#125; 第三种写法：12345678910function getCss(curEle, attar)&#123; var val = null; if(window.getComputedStyle)&#123; //如果返回的是true，代表window下面存在getComputedStyle这个属性，兼容 val = window.getComputedStyle(curEle, null)[attar]; &#125;else&#123; //当前浏览器下面不存在这个属性，不兼容 val = curEle.currentStyle[attar]; &#125; return val;&#125; 3.通过检测浏览器版本和类型来处理兼容 window.navigator.userAgent12345678910google：Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.81 Safari/537.36IE7：Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; LCTE)IE8：Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; LCTE)IE10：Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; LCTE)IE11：Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; LCTE; rv:11.0) like Gecko 123456789101112function getCss(curEle, attar)&#123; var val = reg = null; reg = /^Mozilla\/5.0/i; //正则匹配浏览器的版本，i表示忽略大小写 if(reg.test(window.navigator.userAgent))&#123; //如果返回的是true，兼容 val = window.getComputedStyle(curEle, null)[attar]; &#125;else&#123;//当前浏览器下面不存在这个属性，不兼容 val = curEle.currentStyle[attar]; &#125; return val;&#125;console.log(getCss(box, "height")); 上述方法无法区分具体的浏览器123456789101112function getCss(curEle, attar)&#123; var val = null, reg = null; reg = /MSIE (6|7|8)/i; //正则匹配浏览器的版本，i表示忽略大小写, 一定记得带上小括号 if(reg.test(window.navigator.userAgent))&#123; //如果返回的是true，代表IE6-7-8，不兼容 val = curEle.currentStyle[attar]; &#125;else&#123;//当前浏览器下面不存在这个属性，不兼容 val = window.getComputedStyle(curEle, null)[attar]; &#125; return val; &#125; 判断当前浏览器的版本以及类型的方法1234567891011121314151617181920212223242526272829303132function getBrowserInfo()&#123; var agent = navigator.userAgent.toLowerCase() ; //将获取的字符串全部变成小写字母 var regStr_ie = /msie [\d.]+;/gi ; //gi: 全局匹配，忽略大小写 var regStr_ff = /firefox\/[\d.]+/gi var regStr_chrome = /chrome\/[\d.]+/gi ; var regStr_saf = /safari\/[\d.]+/gi ;//IE if(agent.indexOf("msie") &gt; 0) &#123; return agent.match(regStr_ie) ; &#125;//firefox if(agent.indexOf("firefox") &gt; 0) &#123; return agent.match(regStr_ff) ; &#125;//Chrome if(agent.indexOf("chrome") &gt; 0) &#123; return agent.match(regStr_chrome) ; &#125;//Safari if(agent.indexOf("safari") &gt; 0 &amp;&amp; agent.indexOf("chrome") &lt; 0) &#123; return agent.match(regStr_saf) ; &#125;&#125;var browser = getBrowserInfo() ;var verinfo = (browser+"").replace(/[^0-9.]/ig,""); //匹配除了".数字"之外的符号，用""替换console.log(browser);console.log(verinfo); 标准浏览器和IE浏览器获取的有些样式结果还是不一样的，对于部分样式属性，不同浏览器获取的结果不一样，主要是由于getComputedStyle和currentStyle在某些方面不一样console.log(getCss(box, &quot;font-family&quot;)); console.log(getCss(box, &quot;border&quot;)); google： IE8以下： 获取元素具体样式（升级版） 第一次升级：把获取到样式值的”单位去掉”12345678910111213141516function getCss(curEle, attar)&#123; var val = null, reg = null; reg = /^(-?\d+(\.\d+)?)(px|pt|rem|em)?$/; if("getComputedStyle" in window)&#123; //如果返回的是true，代表window下面存在getComputedStyle这个属性，兼容 val = window.getComputedStyle(curEle, null)[attar]; &#125;else&#123; //当前浏览器下面不存在这个属性，不兼容 val = curEle.currentStyle[attar]; &#125;// return parseFloat(val); //这样写肯定是不行的，对于某一些样式属性的值是不能去单位的 //例如：float、position、margin、padding、border这些复合值，以及background等等 return reg.test(val) ? parseFloat(val) : val;&#125;console.log(getCss(box, "height"));console.log(getCss(box, "border")); 第二次升级：有些样式属性在不同的浏览器中是不兼容的,例如：opacity(设置元素透明度)12345678910111213141516171819202122232425function getCss(curEle, attar)&#123; var val = null, reg = null; reg = /=(\d+)/i;//正则表达式还可以写成：/^alpha\(opacity=(\d+(?:\.\d)?)\)$/i if("getComputedStyle" in window)&#123; //如果返回的是true，代表window下面存在getComputedStyle这个属性，兼容 val = window.getComputedStyle(curEle, null)[attar]; &#125;else&#123; //当前浏览器下面不存在这个属性，不兼容 //如果传递进来的是opacity,说明想获取的是透明度的值，但是在IE8以下的浏览器获取透明度 //需要使用filter if(attar === "opacity")&#123; val = curEle.currentStyle["filter"]; //"alpha(opacity=10)"把获取到的结果进行剖析，获取里面的数字，让数字乘以100才和标准的浏览器保持了一致 val = reg.test(val) ? parseFloat(reg.exec(val)[1])/100 : 1; //1 默认没有透明度 &#125;else&#123; val = curEle.currentStyle[attar]; &#125; &#125;// return parseFloat(val); //这样写肯定是不行的，对于某一些样式属性的值是不能去单位的 //例如：float、position、margin、padding、border这些复合值，以及background等等 return reg.test(val) ? parseFloat(val) : val; &#125;// console.log(getCss(box, "height"));// console.log(getCss(box, "border")); console.log(getCss(box, "opacity"));]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中延迟加载思想和单张图片的延迟加载]]></title>
    <url>%2F2019%2F02%2F16%2FJS%E4%B8%AD%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E6%80%9D%E6%83%B3%E5%92%8C%E5%8D%95%E5%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[首屏图片的延迟加载 原理：作用：保证页面打开的速度 对于首屏内容的图片，首先给对应区域一张默认的图片占着位置（默认图片需要非常的小，一般维持在5kb以内），当首屏内容都加载完成后（或者也可以给一个延迟的时间），再开始加载真实的图片。 对于其它屏中的图片：也是给一张默认的图片占位，当滚动条滚动到对应区域的时候，我们再开始加载真实的图片 扩展：数据的异步加载，开始只是把前两屏的数据加载绑定出来，后面的数据不进行处理，当页面滚动到对应区域的时候再重新请求数据然后绑定渲染数据 123456789101112131415161718192021*&#123; margin: 0; padding: 0;&#125;#banner&#123; margin: 20px auto; width: 576px; height: 360px; border: 1px solid silver; background:url("../images/de1.gif") no-repeat center center; /*给当前的区域在加一个默认图占位，告诉用户此处的图片正在加载中*/&#125;#banner img&#123; display: none; /*在开始的时候IMG的SRC属性没有地址，这样的话，在IE浏览器中容器中 会显示一张碎图，不美观，所以我们让其默认是隐藏的，当真实图片加载完成后显示*/ width: 576px; height: 360px; /*max-width: 576%;*/ /*height: 0;*/ opacity: 0;&#125; 1234&lt;div id="banner"&gt; &lt;!--trueImg是当前IMG标签的自定义属性，存储的是真实图片的地址--&gt; &lt;img src="" trueImg="../images/1.jpg" /&gt;&lt;/div&gt; 12var banner = document.getElementById("banner");var img = banner.getElementsByTagName("img")[0]; 代码讲解：1234window.setTimeout(function() &#123; img.src = img.getAttribute("trueImg"); img.style.display = "block";&#125;, 1500); 以上处理还是不完整的：如果我们获取的真实图片地址是错误的，当赋值给IMG的SRC属性的时候,不仅控制台会报错，而且页面中会出现碎图/叉子图，影响视觉效果。获取图片的地址，验证地址的有效性，如果是有效的才进行赋值操作，否则不进行赋值操作。1234567var tempImg = new Image(); //创建一个临时的img标签，两种方式都可以tempImg.src = img.getAttribute("trueImg");tempImg.onload = function()&#123; //当图片能够正常的加载 img.src = img.getAttribute("trueImg"); img.style.display = "block"; tempImg = null;&#125; 渐进效果1234567891011var duration = 1400, interval = 150, total = 1;var stemp = (interval * total) / duration;var timer = window.setInterval(function () &#123; var opacity = utils.getCss(img, "opacity"); opacity += stemp; if (opacity &gt;= total) &#123; window.clearInterval(timer); &#125; img.style.opacity = opacity; console.log(img.opacity);&#125;, interval); 从左上角到右下角缓慢变大的效果12345678910var duration = 1000,interval = 100, total = 360;var stemp = (interval * total) / duration;var timer = window.setInterval(function ()&#123; var height = utils.getCss(img, "height"); height += stemp; if(height &gt;= total)&#123; window.clearInterval(timer); &#125; img.style.height = height + "px";&#125;,interval); 其他屏的图片延迟加载 计算图：12345678910111213141516171819202122232425262728293031323334*&#123; margin: 0; padding: 0;&#125;#banner&#123; margin: 20px auto; width: 576px; height: 360px; border: 1px solid silver; background:url("../images/de1.gif") no-repeat center center; /*给当前的区域在加一个默认图占位，告诉用户此处的图片正在加载中*/&#125;#banner img&#123; display: none; /*在开始的时候IMG的SRC属性没有地址，这样的话，在IE浏览器中容器中 会显示一张碎图，不美观，所以我们让其默认是隐藏的，当真实图片加载完成后显示*/ width: 576px; height: 360px; /*max-width: 576%;*/ /*height: 0;*/ opacity: 0;&#125;#other&#123; margin: 800px auto; width: 576px; height: 360px; border: 1px solid silver; background:url("../images/de1.gif") no-repeat center center;&#125;#other img&#123; display: none; width: 576px; height: 360px; opacity: 0; &#125; 12345&lt;!--trueImg是当前IMG标签的自定义属性，存储的是真实图片的地址--&gt;&lt;img src="" trueImg="../images/1.jpg" /&gt;&lt;div id="other"&gt; &lt;img src="" trueImg="../images/1.jpg" /&gt;&lt;/div&gt; 12var other = document.getElementById("other");var otherImg = other.getElementsByTagName("img")[0]; 动画效果 1234567891011121314151617181920212223242526function animation(img)&#123; /*渐进效果*/ var duration = 1000, interval = 100, total = 1; var stemp = (interval * total) / duration; var timer = window.setInterval(function () &#123; var opacity = utils.getCss(img, "opacity"); opacity += stemp; if (opacity &gt;= total) &#123; window.clearInterval(timer); &#125; img.style.opacity = opacity; console.log(img.opacity); &#125;, interval);/*从左上角到右下角缓慢变大的效果*/// var duration = 1000,interval = 100, total = 360;// var stemp = (interval * total) / duration;// console.log(stemp);// var timer = window.setInterval(function ()&#123;// var height = utils.getCss(img, "height");// height += stemp;// if(height &gt;= total)&#123;// window.clearInterval(timer);// &#125;// img.style.height = height + "px";// &#125;,interval); &#125; 一张图片懒加载:123456789101112function oneImgLazyLoad(Img)&#123; window.setTimeout(function() &#123; var tempImg = new Image(); //创建一个临时的img标签，两种方式都可以 tempImg.src = Img.getAttribute("trueImg"); tempImg.onload = function()&#123; //当图片能够正常的加载 Img.src = Img.getAttribute("trueImg"); Img.style.display = "block"; tempImg = null; &#125; animation(Img); &#125;, 1000); &#125; 首屏图片懒加载:1oneImgLazyLoad(img); 其他屏图片懒加载:12345678910111213141516window.onscroll = function()&#123; if(other.count)&#123; return; &#125; var distanceImg = other.offsetHeight + utils.offset(other).top; var distanceClient = utils.win("scrollTop") + utils.win("clientHeight"); other.count = false; //设置一个自定义属性，用来表示图片是否已经加载完成，默认值是false，表示没有加载完成 if(distanceImg &lt; distanceClient)&#123; /* 当条件成立，加载真实图片，第一次加载完成后，我们在让页面继续滚动的过程中， distanceImg &lt; distanceClient一直成立，又从新开始执行了下面的操作，导致了重复给一个容器中的图片进行加载 */ oneImgLazyLoad(otherImg); other.count = true; //表示图片已经加载完成(不管时候正常加载，只要处理过一次，以后都不在处理了) &#125; &#125; 多张图片的延迟加载12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152*&#123; margin: 0; padding: 0; font-size: 14px;&#125;ul,li&#123; list-style: none;&#125;img&#123; display: none; border: none; width: 100%; height: 100%; opacity: 0;&#125;/*最外层容器是不设定固定宽高的*/#news&#123; padding: 10px;&#125;#news li&#123; position: relative; padding: 10px 0; height: 80px; border-bottom: 1px dashed silver;&#125;#news li &gt; div:nth-child(1)&#123; position: absolute; top: 10px; left: 0; width: 75px; height: 75px; white-space: nowrap; background: url("../images/de3.gif") no-repeat center center; background-size: 100% 100%; /*设置背景图片大小，表示当前容器有多大，图片就有多大*/&#125;#news li &gt; div:nth-child(2)&#123; margin-left:80px; height: 80px;&#125;#news li &gt; div:nth-child(2) h2&#123; height: 20px; line-height: 20px; /*实现文字超出一行的3样式*/ overflow: hidden; white-space: nowrap; text-overflow: ellipsis; /*超过的部分用省略号代替*/&#125;#news li &gt; div:nth-child(2) p&#123; line-height: 20px; font-size: 12px; color: silver;&#125; 1&lt;ul id="news"&gt;&lt;/ul&gt; 12345678910111213141516171819202122var news = document.getElementById("news");var imgList = news.getElementsByTagName("img");var data = null;``` 1. 获取需要绑定的数据（AJAX）：data2.txt中的json格式的字符串```javascript ~function()&#123; //[1]新建一个XMLHttpRequest对象 var xhr = new XMLHttpRequest; //[2]打开数据文件 xhr.open('get', 'data2.txt', false); //[3]检查请求状态 xhr.onreadystatechange = function()&#123; //URL地址后面加的随机数是在清除每一次请求数据的时候（GET请求）产生的缓存 if(xhr.readyState === 4 &amp;&amp; /^2\d&#123;2&#125;$/.test(xhr.status))&#123; var res = xhr.responseText; data = utils.jsonParse(res); &#125; &#125; //[4]发送请求 xhr.send(); &#125;(); 数据绑定：把data中存储的数据绑定在页面中（文档碎片的方式） 1234567891011121314 ~function()&#123; if(data)&#123; var frg = document.createDocumentFragment(); for (var i = 0; i &lt; data.length; i++) &#123; var oLi = document.createElement("li"); oLi.innerHTML = '&lt;div&gt;&lt;img src="" trueImg="' + data[i].imgSrc + '"/&gt;&lt;/div&gt;' + '&lt;div&gt;&lt;h2&gt;'+ data[i].title +'&lt;/h2&gt;' + '&lt;p&gt;'+ data[i].content + '&lt;/p&gt;&lt;/div&gt;'; frg.appendChild(oLi); &#125; news.appendChild(frg); frg = null; &#125;&#125;(); 图片延迟加载 先编写一个方法，实现单张图片的延迟加载 1234567891011function lazyImg(img)&#123; var tempImg = new Image; tempImg.src = img.getAttribute("trueImg"); tempImg.onload = function()&#123; img.src = this.src; img.style.display = "block"; fadeIn(img); tempImg = null; &#125; img.isLoad = true;&#125; 循环处理每一张图片12345678910111213141516function handleAllImg()&#123; for (var i = 0; i &lt; imgList.length; i++) &#123; var currImg = imgList[i]; //当前的图片进行处理了，就不再从新进行处理了 if(currImg.isLoad)&#123; continue; &#125; var currImgPar = currImg.parentNode; var A = currImgPar.offsetHeight + utils.offset(currImgPar).top; var B = utils.win("scrollTop") + utils.win("clientHeight"); //只有A&lt;B的时候再进行处理：当前图片是隐藏的，我们计算的A的值其实是计算它父级容器的值 if(A &lt; B)&#123; lazyImg(currImg); &#125; &#125;&#125; 动画效果 123456789101112function fadeIn(img)&#123; var duration = 2000,interval = 100, total = 1; var step = (total * interval) / duration; var timer = window.setInterval(function()&#123; var opacity = utils.getCss(img, "opacity"); opacity += step; if (opacity &gt;= total) &#123; window.clearInterval(timer); &#125; img.style.opacity = opacity; &#125;, interval);&#125; 什么时候进行延迟加载图片（定时器设置2000ms，以及滚动条滚动的时候）123window.setTimeout(handleAllImg, 1000);![Alt text](./JS中DOM详细讲解.pdf)window.onscroll = handleAllImg;]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中盒子模型中的常用的前8个属性]]></title>
    <url>%2F2019%2F02%2F16%2FJS%E4%B8%AD%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E7%9A%84%E5%89%8D8%E4%B8%AA%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[1234&lt;div id="box" class="test test1 test2" index="0"&gt; 生活是一面镜子。你对它笑，它就对你笑；你对它哭，它也对你哭。活着一天，就是有福气，就该珍惜。当我哭泣我没有鞋子穿的时候，我发现有人却没有脚。 人生是个圆，有的人走了一辈子也没有走出命运画出的圆圈 &lt;/div&gt; 12345678910111213141516*&#123; margin: 0; padding: 0; font-family: 微软雅黑; font-size: 14px;&#125;#box&#123; width: 200px; height: 200px; margin: 100px; padding: 30px; border: 10px solid #8cadef; line-height: 30px; /*overflow: hidden;*/ /*溢出部分隐藏*/ /*overflow: auto; /!*溢出部分自动增加滑动条*!/*/&#125; 12var box = document.getElementById("box");console.dir(box); 个别属性解释一、常用属性讲解 client系列属性clientWidth/clientHeight: 内容的宽度 + 左右填充/高度 + 上下填充（和内容是否溢出没有关系）clientLeft/clientTop: 左边框的宽度[borderLeft]/上边框的高度[borderTop] 内容的宽度/高度： 我们设置的width/height这两个样式就是内容宽度和高度；如果没有设置height的值，容器的高度会根据里面的内容自己进行适应，这样获取的值就是真实内容的高度值；如果设置固定高度的值，不管内容是或溢出，或者时候填满，我们获取的值都是设定的那个height的高度值 真实内容的宽度/高度： 这个代指的是实际内容的宽度和高度（和我们设置的width/height没有必然的联系）例如：设置的高度是200px，如果内容有溢出，那么真实内容的高度是要把溢出内容的高度加上的 offset系列 offsetWidth/offsetHeight: clientWidth + 左右边框的宽度/clientHeight + 上下边框的高度(和内容是否溢出也是没有任何关系的)offsetLeft/offsetTop: 当前元素的外边框距离父级参照物的内边框的偏移量offsetParent: 当前元素的户父级参照物 scroll系列 scrollWidth/scrollHeight: 和clientWidth/clientHeight的计算方式是一模一样的（前提是：容器中的内容没有溢出的情况下）如果容器中内容有溢出，我们获取的结果的规则如下：scrollWidth：真实内容的宽度（包含溢出） + 左填充scrollHeight: 真实内容的高度（包含溢出） + 上填充获取到的结果都是“约等于”的值，因为：同一个浏览器，是否设置overflow: hidden 对于最终的结果是有影响的;在不同的浏览器中，我们获取到的结果也是不相同的scrollLeft/ scrollTop: 滚动条卷去的高度/宽度 二、关于JS盒子模型属性取值的问题 通过这13个属性值获取的结果永远不可能出现小数，都是整数；浏览器在获取结果的时候，还在原来真实结果的基础上进行了四舍五入三、关于操作浏览器本身的盒子模型信息clientWidth/clientHeight是当前浏览器可视窗口的宽度和高度（一屏幕的宽度和高度）scrollWidth/scrollHeight是当前页面的真实宽度和高度（浏览器所有屏加起来的宽度和高度，但是是一个约等于的值）我们不管哪种属性，也不管是什么浏览器，也不管是获取还是设置，想要兼容的话，需要写两套document.documentElement[attar] || document.body[attar]且document.documentElement[attar]必须放在前面例如：获取：document.documentElement.clientWidth || document.body.clientWidth设置：document.documentElement.scrollTop = 0;document.body.scrollTop = 0; win: 编写一个有关操作浏览器盒子模型的方法如果只传递attar，没有传递value, 默认的意思是获取如果两个参数都传递了，意思就是设置不严谨的来说，这就是有关于“类的重载”：同一个方法，通过传递参数不同实现了不同的功能123456789function win(attar, value)&#123; var val = null; if(typeof value === 'undefined')&#123; val = document.documentElement[attar] || document.body[attar]; return val &#125; document.documentElement[attar] = value; document.body[attar] = value;&#125; 获取元素的偏移量offset 案例剖析：12345678910111213141516171819202122232425*&#123; margin: 0; padding: 0;&#125;#outer&#123; width: 180px; height: 180px; margin: 50px auto; padding: 50px; border: 10px solid #176dff; background-color: #a4bbef;&#125;#inner&#123; width: 80px; height: 80px; padding: 50px; border: 10px solid #3fc554; background-color: #b2ef39;&#125;#center&#123; width: 50px; height: 50px; border: 10px solid #fe7259; background-color: #feaaac;&#125; 12345&lt;div id="outer"&gt; &lt;div id="inner"&gt; &lt;div id="center"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123var outer = document.getElementById("outer");var inner = document.getElementById("inner");var center = document.getElementById("center"); parentNode 父亲节点，HTML结构层架关系中的上一级元素console.log(outer.parentNode); //-&gt;body console.log(inner.parentNode); //-&gt;outer console.log(center.parentNode); //-&gt;inner offset 父级参照物 在同一平面中，最外层的元素是里面所有元素的父级参照物（和HTML层级没有必然的联系）一般来说一个页面中所有元素的父级参照物都是bodyconsole.log(outer.offsetParent); //body console.log(inner.offsetParent); //body console.log(center.offsetParent); //body console.log(document.body.offsetParent); //null 想要改变父级参照物需要通过position定位来改变：absolute、fixed、relative三个中的任意一个值都可以把父级参照物进行修改12345678910outer.style.position = "relative";console.log(outer.offsetParent); //bodyconsole.log(inner.offsetParent); //outerconsole.log(center.offsetParent); //outerouter.style.position = "relative";inner.style.position = "relative";console.log(outer.offsetParent); //bodyconsole.log(inner.offsetParent); //outerconsole.log(center.offsetParent); //inner offsetTop/offsetLeft：当前元素(的外边框)距离其父级参照物（的内边框）的偏移距离12345outer.style.position = "relative";inner.style.position = "relative";console.log(outer.offsetLeft); //533console.log(inner.offsetLeft); //50console.log(center.offsetLeft); //50 offset：等同于jQuery中的offset方法，实现获取页面中任意一个元素，距离body的偏移（包含左偏移和上偏移），不管当前元素的父级参照物是谁获取的结果是一个对象{left: 距离BODY的左偏移，top: 距离BODY的上偏移}在标准的IE8浏览器中，我们使用offsetLeft/offsetTop其实是把父级参照物的边框已经算在内了，所以我们不需要自己在单独的加上边框了 123456789101112131415161718192021function offset(curEle)&#123; var totalLeft = 0, totalTop = 0, par = curEle.offsetParent; totalLeft += curEle.offsetLeft; totalTop += curEle.offsetTop; while(par.offsetParent != null)&#123; //如果当前元素par不是body if(window.navigator.userAgent.indexOf("MSIE 8.0") === -1)&#123; //不是标准的IE8浏览器，我们才进行累加边框 //累加父级参照物的边框 totalLeft += par.clientLeft; totalTop += par.clientTop; &#125; //累加父级参照物本身的偏移 totalLeft += par.offsetLeft; totalTop += par.offsetTop; par = par.offsetParent; &#125; return &#123;left: totalLeft, top: totalTop&#125;;&#125;console.log(offset(inner)); scrollTop/scrollLeft 1234567891011121314151617181920212223242526272829*&#123; margin: 0; padding: 0; font-family: 微软雅黑; font-size: 14px; &#125; #box&#123; width: 200px; height: 200px; margin: 100px auto; padding: 30px; border: 1px dashed #8cadef; line-height: 30px; /*overflow: hidden;*/ /*溢出部分隐藏*/ overflow: auto; /*溢出部分自动增加滑动条*/ &#125;``` ```htmlbars&lt;div id="box" class="test test1 test2" index="0"&gt; 生活是一面镜子。你对它笑，它就对你笑；你对它哭，它也对你哭。活着一天，就是有福气，就该珍惜。当我哭泣我没有鞋子穿的时候，我发现有人却没有脚。 人生是个圆，有的人走了一辈子也没有走出命运画出的圆圈 生活是一面镜子。你对它笑，它就对你笑；你对它哭，它也对你哭。活着一天，就是有福气，就该珍惜。当我哭泣我没有鞋子穿的时候，我发现有人却没有脚。 人生是个圆，有的人走了一辈子也没有走出命运画出的圆圈 生活是一面镜子。你对它笑，它就对你笑；你对它哭，它也对你哭。活着一天，就是有福气，就该珍惜。当我哭泣我没有鞋子穿的时候，我发现有人却没有脚。 人生是个圆，有的人走了一辈子也没有走出命运画出的圆圈&lt;/div&gt;``` ```javascript var box = document.getElementById("box"); 之前我们学习的盒子模型中：client系列/offset系列/scrollWidth/scrollHeight都是”只读“属性，只能通过属性获取值，不能通过属性修改元素的样式2.scrollTop/scrollLeft:滚动条卷去的高度/宽度（这两个属性是唯一”可读写”属性）box.scrollTop = 0;直接回到了容器的顶部我们的scrollTop 的值是存在边界的（最大值和最小值），我们设置的值比最小值还要小，或者比最大值还要大 都没有用，起到效果的依然是边界值123456【最小值是零】 box.scrollTop = -1000; //页面显示效果：直接回到容器顶部，并没有超出效果 console.log(box.scrollTop); //0【最大值 = 真实高度（scrollHeight） - 一个屏幕的高度（clientHeight）】 var maxTop = box.scrollHeight - box.clientHeight; console.log(maxTop); //490]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础之JSON及操作]]></title>
    <url>%2F2019%2F02%2F16%2FJSON%E5%8F%8A%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[JSON不是一个单独的数据类型，它只是一种特殊的数据格式，它是对象数据类型的12var obj = &#123;name: '朱小露', age: 20&#125;; //普通格式的对象var jsonObj = &#123;"name": '朱小露', "age": 20&#125;; //JSON格式的对象（相对于普通的格式来说，只是把属性名和用双引号包起来了），且只能是双引号 在window浏览器对象中，提供了一个叫做JSON的属性，它里面提供了两种方法：window.JSON window可以省略 JSON.parse() =&gt; 把JSON格式的字符串转换为JSON格式的对象 JSON.stringify() =&gt; 把JSON格式的对象转换为JSON格式的字符串123var jsonObj = &#123;"name": '朱小露', "age": 20&#125;;var jsonStr = JSON.stringify(jsonObj);console.log(jsonStr); 123var jsonStr = '&#123;"name": "朱小露", "age": 20&#125;';var jsonObj = JSON.parse(jsonStr);console.log(jsonObj); 在IE6~8浏览器下，我们的window下没有JSON对象，刚才的parse和stringify方法都不存在了，即都不能使用 把JSON格式的字符串转换为JSON格式的对象(IE6~8浏览器下兼容)123var jsonStr = '&#123;"name": "朱小露", "age": 20&#125;';var jsonObj = eval("(" + jsonStr + ")");console.log(jsonObj); 一定要记住使用eval的话，不要忘记要手动添加一个小括号 12345678910//jsonParse: 把JSON格式的字符串转换为JSON格式的对象jsonParse: function(jsonStr)&#123; var jsonObj = null; try&#123; jsonObj = JSON.parse(jsonStr); &#125;catch(e)&#123; jsonObj = eval("(" + jsonStr + ")"); &#125; return jsonObj;&#125;]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中原型深入之函数的三种角色]]></title>
    <url>%2F2019%2F02%2F16%2FJS%E4%B8%AD%E5%8E%9F%E5%9E%8B%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%89%E7%A7%8D%E8%A7%92%E8%89%B2%2F</url>
    <content type="text"><![CDATA[1234567function Fn()&#123; this.x = 100;&#125;Fn.prototype.getX = function()&#123; console.log(this.x);&#125;var f = new Fn; 函数本身也会有一些自己的属性：length:0 形参的个数name: &#39;Fn&#39;函数名prototype 类的原型，在原型上定义的方法都是当前Fn这个类的实例的公有方法__proto__ 把函数当做一个普通对象，指向Function这个类的原型函数在整个JS中是最复杂也是最终要的知识 一个函数存在了多面性：普通函数：它本身就是一个普通的函数，执行的时候形成私有的作用域（闭包）=&gt;形参赋值 =&gt; 预解释 =&gt; 代码执行 =&gt; 执行完成后栈内存销毁/不销毁类：它有自己的实例，也有一个叫做 prototype属性是自己的原型，它的实例都可以指向自己的原型普通对象：和var obj = {}中的obj一样，就是一个普通的对象吗，它作为对象可以有一些自己的私有属性和方法，也可以通过__proto__找到Function.prototype 这三者之间是没有必然关系的 12345678910111213function Fn()&#123; var num = 500; this.x = 100;&#125;Fn.prototype.getX = function()&#123; console.log(this.x);&#125;Fn.aaa = 100; //函数作为普通对象var f = new Fn; //函数作为类，Fn中的this是ff.num =&gt; undefinedf.aa =&gt; undefinedvar res = Fn(); //函数作为普通函数，Fn中的this是windowres = undefined //方法没有返回值]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery的常用方法]]></title>
    <url>%2F2019%2F02%2F16%2FjQuery%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[jQuery详解版链接：(http://jquery.cuishifeng.cn/) jQuery的回调函数12345678910111213function fn1(value1)&#123; console.log('fn1:' + value1);&#125;function fn2(value)&#123; console.log('fn2:' + value);&#125;var $call = $.Callbacks(); //创建一个回调函数的列表集合$call.add(fn1);//fn1:10 向集合中增加一个叫fn1的函数$call.fire(10); //触发fire方法的时候，把回调函数集合中的方法执行，并且把对应的参数值传递给对应的方法$call.add(fn2);$call.fire(20); //fn1:20 fn2:20$call.remove(fn1); //在集合中移除我们的fn1这个方法$call.fire(30); //fn2:30 $(function(){}) &lt;=&gt; $(document).ready(function(){}); 和原生的JS对应window.onload的意思是：当页面中的HTML结构，图片，文字等多种资源都加载完成才会触发这个行为, 并且在一个页面中它只能执行一次，后面编写的会把前面的覆盖掉.$(document).ready(function(){}); 只要HTML结构加载完成之后就会触发对应的行为，而且在一个页面中可以使用多次，即将多个方法都绑定在上面，也不会出现覆盖效果优点： 所有的HTML结构都加载完成了，将js文件引入的代码放在head标签里面也不会出现问题 私有作用域形成了一个闭包，不会与外部相同变量出现冲突问题 因此，最好将所有的JQ代码写到$(document).ready(function(){。。。})里面 属性 attr: 获取和设置元素的自定义属性，等价于原生的JS中的set/getAttribute12345678var $box = $('#box');$box.attr('name', 'zhuxiaolu'); //传递两个参数就是设置console.log($box.attr('name')); //传递一个参数就是获取 zhuxiaolu$box.removeAttr('name'); //移除$box.attr(&#123; //批量设置 'name': '朱小露', age: 20&#125;); 设置属性：移除属性：批量设置属性：prop: 获取和设置元素的属性，其中内置的属性可以在HTML结构中体现出来，但是不是内置的属性是体现不出来的.1234567var $box = $('#box');$box.prop('name', 'zhuxiaolu'); //传递两个参数就是设置$box.prop('index', '1'); //传递两个参数就是设置$box.prop(&#123; //批量设置 'name': '朱小露', age: 20&#125;); prop和attr是两种不同的方式，两者之间不能互相混用：用attr设置的非内置属性只能用attr删除或者修改，或者获取。同理，用prop设置的非内置属性，也只能用prop进行操作), 但是，如果是内置属性，则可以相互混用1234567var $box = $('#box');$box.prop('name', 'zhuxiaolu'); //传递两个参数就是设置console.log($box.attr('name')); //zhuxiaolu$box.prop('index', '1'); //传递两个参数就是设置console.log($box.attr('index')); //undefined$box.attr('age', 1);console.log($box.prop('age')); //undefined attr和prop的区别：attr一般是用来设置和操作元素的自定义属性的，而prop一般都是用来操作元素的内置属性的， 尤其是表单元素的操作，大部分都是使用prop 类名 addClass/removeClass/toggleClass(toggle系列都是之前有就执行移除操作，如果之前没有，就执行新增操作)12345var $box = $('#box');$box.addClass('w100 w200');$box.removeClass('w100');$box.toggleClass('w100');$box.toggleClass('w100'); 新增： 移除： 关于jQuery内置遍历机制和手动循环的方法 123456789 var $box = $('#box');console.log($box); //m.fn.init [div#box]var $divList1 = $('div');console.log($divList1); //m.fn.init(5) [div#box, div#div2, div#div3, div#div4, div#div5] context: documentvar $divList2 = $('div', $box);console.log($divList2); //m.fn.init(4) [div#div2, div#div3, div#div4, div#div5] context: documentjQuery(selector, context) context一般不需要传递，默认是document， 但是也可以指定具体的上下文来获取需要的元素$('#box div') &lt;==&gt; $('div', $box)$('#box&gt;div') &lt;==&gt; #box.children('div') 12345678var $box = $('#box');var $divList = $('div', $box);$divList.addClass('w1'); //通过jQuery选择器获取到一个集合，然后让集合直接调用jQuery中提供的方法相当于将集合中的元素进行遍历，然后给给集合中的每一个子元素都调取了对应的方法（addClass）这就是jQuery的内置循环操作for (var i = 0; i &lt; $divList.length; i++) &#123; var obj = $divList[i]; console.log(obj); //obj都是js原生对象 $(obj).addClass('w2'); //$(obj)将obj转换为jQuery对象&#125; 通过jQuery选择器获取到一个集合，然后让集合直接调用jQuery中提供的方法相当于将集合中的元素进行遍历，然后给给集合中的每一个子元素都调取了对应的方法（addClass）这就是jQuery的内置循环操作 each 可以遍历jQuery集合中的每一项（和数组的ForEach类似，区别是，匿名函数的形参是item, index格式的）12345$divList.each(function(index, item)&#123;// console.log(arguments); //index: item格式 item是JS原生对象// $(item).addClass('w3'); $(this).addClass('w3'); //this &lt;==&gt; item: 当前遍历的这一项内容&#125;) html/text/val 对匹配的元素进行设置（传递参数值）/获取（不传递参数值） html = innnerHTML 可以识别html标签text = innnerText 只能识别文字val = value 设置/获取表单元素的值 css css: 获取/设置（批量设置）当前元素的样式值1234567var $box = $('#box');console.log($box.css('width')); //200px$box.css('background', 'red');$box.css(&#123; background: 'green', width: '300px'&#125;) offset: 不管父级参照物是谁，获取当前元素距离BODY的偏移距离（top/left）position: 获取当前元素距离父级参照物的偏移（top/left）123var $box = $('#box');console.log($box.offset()); //&#123;top: 10, left: 5&#125;console.log($box.position()); //&#123;top: 10, left: 5&#125; scrollTop/scrollLeft: 获取/设置元素的卷去距离顶部的高度/左边的宽度123var $box = $('#box');console.log($box.width()); //200console.log($box.height()); //200 width/height: 获取/设置当前元素的真实宽度/高度（不包括边框）12console.log($box.innerWidth()); //260console.log($box.innerHeight()); //260 innerWidth/innerHeight :获取/设置第一个匹配元素内部区域宽度/高度（包括补白、不包括边框）， (可视区域的，设置值时等价于clientWidth/clientHeight，获取值时，保留padding的值，把width的值进行改变，且width的值最小为0)12 console.log($box.outerWidth()); //280console.log($box.outerHeight()); //280 outerWidth/outerHeight: 获取/设置第一个匹配元素外部宽度/高度（默认包括补白和边框）,（设置值的时候等价于offsetWidth/offsetHeight，获取值的时候，保留padding的值，把width的值进行改变，且width的值最小为0）如果传递的参数是true,则默认的把margin的值也计算在内了 jQuery非常强大的功能在于它支持链式写法，执行完成一个方法后返回的结果依然是一个jQuery对象，这样就可以继续调用下一个方法了12console.log($box.css('background', 'black').width()); //200console.log($box.css('background', 'black').width().position()); //Uncaught TypeError: $box.css(...).width(...).position is not a function 文档处理 append: 向指定来容器的末尾位置追加一个新元素。格式：容器.append(新元素)1234var $box = $('#box');var oDiv = document.createElement('div');oDiv.id = 'div6';$box.append(oDiv); appendTo:将新元素添加到指定容器末尾。格式：新元素.append(容器)1$(oDiv).appendTo($box); prepend/prependTo: 向指定来容器的开头位置追加一个新元素after/before: 在当前元素的后面/前面追加新的元素insertAfter/insertBefore: 把选择器获取到的元素追加到指定元素的前面或者后面12345678$(oDiv).insertBefore($box);$(oDiv).insertAfter($box); //把创建的oDiv追加到$box的后面（和$box是同级）replaceAll(selector):用匹配的结果替换所有的selector匹配的元素var $box = $('#box');var oDiv = document.createElement('div');oDiv.id = 'div6';$(oDiv).replaceAll('ul'); //将页面中的所有的ul元素都用oDiv给替换了 replaceWith:将所有匹配的元素替换成指定的HTML或DOM元素。remove:把匹配的结果在页面中移除掉， 这个方法不会把匹配的元素从jQuery对象中删除123var $box = $('#box');$box.remove(); //将$box在页面中移除掉$('ul').remove('#ul2'); //将id为ul2的元素删除 detach([expr])：从DOM中删除所有匹配的元素，这个方法不会把匹配的元素从jQuery对象中删除clone([Even[,deepEven]])：克隆匹配的DOM元素。参数：一个布尔值（true 或者 false）指示事件处理函数是否会被复制。 筛选 eq(index|-index):取当前链式操作中第N个jQuery对象，返回jQuery对象, 当参数大于等于0时为正向选取，比如0代表第一个，1代表第二个。当参数为负数时为反向选取，比如-1为倒数第一个first: 获取第一个元素last: 获取最后个元素hasClass(class):检查当前的元素是否含有某个特定的类，如果有，则返回true。filter / children /find: 常用的三个筛选方法filter: 同级过滤首先通过选择器获取一个集合，在获取的内容中再进行二次筛选12console.log($('#box *').filter('div')); //m.fn.init(4) [div#div2, div#div3, div#div4, div#div5]console.log($('#box *').filter('ul')); //m.fn.init(4) [ul, ul#ul1, ul#ul2.w100, ul#ul3] children: 子级过滤123456var $box = $('#box');console.log($box.children()); //m.fn.init(7) [div#div2, div#div3, ul#ul1, div#div4, div#div5, ul#ul2.w100, ul#ul3]console.log($box.children('div')); //m.fn.init(4) [div#div2, div#div3, div#div4, div#div5]console.log($box.children('.w100')); //m.fn.init [ul#ul2.w100]console.log($box.children('#div2')); //mm.fn.init [div#div2]console.log($box.children('#div3,.w100')); //m.fn.init(2) [div#div3, ul#ul2.w100] find: 后代过滤12345var $box = $('#box');console.log($box.find()); //m.fn.init [0]console.log($box.find('div')); //m.fn.init(4) [div#div2, div#div3, div#div4, div#div5]console.log($box.find('li')); //m.fn.init(12) [li, li, li, li, li, li, li, li, li, li, li, li]$box.find('li') -&gt; selector: "#box li" jQuery这个元素对象的私有属性中有selector这个属性，其存储的值是本次查找的选择器的内容；context是当前查找的的上下文12console.log($('*', $('#box'))); //context: document, selector: '#box *'console.log($('*', document.getElementById('box'))); //context: div#box selector: "*" map: 遍历jQuery集合中的每一项，并且可以支持返回值把每一项进行修改，类似于数组中的map方法1234var $ary = $('div').map(function()&#123; return $(this).attr('id');&#125;).get().join(', ');console.log($ary); //'box, div2, div3, div4, div5']]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery选择器]]></title>
    <url>%2F2019%2F02%2F16%2FjQuery%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[基本选择器| 表示方式 | 解释 ||:——– | :—— ||#id | 通过id进行选择||element | 通过标签名进行选择||.class | 通过类名进行选择||* | 匹配当前上下中文所有的标签元素||selector1,selector2,selectorN|群组选择器，将其中每个选择器匹配的结果合并在一起| 12345console.log($('#div1')); //m.fn.init [div#div1]console.log($('div')); //m.fn.init(5) [div#div1, div#div2, div#div3, div#div4, div#div5]console.log($('.w100')); //m.fn.init [ul#ul2.w100]console.log($('*')); //m.fn.init(24)console.log($('#div1, div, .w100')); //m.fn.init(6)[div#div1, div#div2, div#div3, div#div4, div#div5, ul#ul2.w100] 层次选择器| 表示方式 | 解释 ||:——– | :—— ||ancestor descendant | 后代选择器||parent &gt; child| 子代选择器||prev + next| 下一个弟弟选择器||prev ~ siblings| 所有的弟弟选择器|1234567console.log($('#div1 li')); //m.fn.init(9) 在子子孙孙级查找console.log($('#div1 &gt; li')); //m.fn.init(0) 在子集中查找console.log($('#div3 +')); //m.fn.init [[ul#ul1] 获取它的下一个弟弟元素节点console.log($('#div3 + div')); //m.fn.init[0] 获取它的下一个弟弟元素节点，并且标签名是div的console.log($('#div3 + ul')); //m.fn.init[ul#ul1]console.log($('#div3 ~')); //m.fn.init(5)[ul#ul1, div#div4, div#div5, ul#ul2.w100, ul#ul3] 获取它的所有弟弟元素节点console.log($('#div3 ~ ul')); //m.fn.init(3)[ul#ul1, ul#ul2.w100, ul#ul3]在所有的弟弟元素节点中，查找标签名为ul的 基本过滤选择器| 表示方式 | 解释 ||:——– | :—— ||:first | 匹配到的集合中第一个元素||:last| 匹配到的集合中最后一个元素||:not(selector)| 匹配到的集合中除了not后面括号里匹配到的元素之外的其它元素 ||:even| 匹配到的集合中的偶数||:odd| 匹配到的集合中的奇数||:eq(n)| 获取集合中索引为n的元素，返回值是jQuery对象类型||:gt(n)| 获取集合中索引大于n的元素集合（不包括索引为n的这一项）||:lt(n)| 获取集合中索引小于n的元素集合（不包括索引为n的这一项||:header| 匹配如 h1, h2, h3之类的标题元素||:animated| 匹配所有正在执行动画效果的元素|1234567891011121314151617console.log($('#div1 &gt; div:first'));//m.fn.init[div#div2]console.log($('#div1 &gt; div:last'));//m.fn.init[div#div5]console.log($('#div1:first'));//m.fn.init[div#div1]console.log($('#div1:first'));//m.fn.init[div#div1]//获取当前匹配到的集合中的第一个/最后一个元素，如果集合中只有一个元素，则得到的值是其本身console.log($('#div1 &gt; div:not(#div3)'));//m.fn.init(3) [div#div2, div#div4, div#div5]console.log($('#div1 &gt; ul:not(.w100)'));//m.fn.init(2) [ul#ul1, ul#ul3]//#div1下所有子集div中除了id为div3的元素console.log($('#div1 &gt; div:eq(0)')); //m.fn.init [div#div2]console.log($('#div1 &gt; div:eq(1)')); //m.fn.init [div#div3]//通过索引获取集合中的某一个，但是获取的结果依然是一个jQuery对象（而之前的get方法，虽然也是通过索引来获取，但是获取到的结果是一个JS原生对象）console.log($('#div1 &gt; div:gt(1)')); //m.fn.init(2) [div#div4, div#div5]//集合中索引大于1的元素集合（不包含索引1这一项）console.log($('#div1 &gt; div:lt(1)')); //m.fn.init [div#div2]//集合中索引小于1的元素集合（不包含索引1这一项） 内容过滤选择器| 表示方式 | 解释 ||:——– | :—— ||:contains(text)| 匹配包含给定文本的元素||:empty| 匹配所有不包含子元素或者文本的空元素||:has(selector)| 匹配含有选择器所匹配的元素的元素||:parent| 匹配含有子元素或者文本的元素|12345678console.log($("#div1 &gt; div:contains('zhuxiaolu')")); //m.fn.init [div#div4]//获取集合中文本内容包含zhuxiaolu元素集合console.log($("div:empty")); //m.fn.init(2) [div#div2, div#div5]//查找所有不包含子元素或者文本的div元素console.log($("#div1 &gt; div:has('ul')")); //m.fn.init [div#div3//获取集合中包含选择器匹配到的内容的元素集合console.log($("div:parent")); //m.fn.init(3) [div#div1, div#div3, div#div4]//查找所有含有子元素或者文本的 div 元素 可见性过滤选择器| 表示方式 | 解释 ||:——– | :—— ||:hidden| 匹配所有不可见元素，或者type为hidden的元素||:visible| 匹配所有的可见元素|1234&lt;table&gt; &lt;tr style="display:none"&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Value 2&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 1234$("tr:hidden")结果：[ &lt;tr style="display:none"&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt; ]$("tr:visible")//结果：[ &lt;tr&gt;&lt;td&gt;Value 2&lt;/td&gt;&lt;/tr&gt; ] 属性过滤选择器| 表示方式 | 解释 ||:——– | :—— ||attribute| 匹配包含给定属性的元素||attribute = value| 匹配给定的属性是某个特定值的元素||attribute != value| 匹配所有的可见元素|匹配所有不含有指定的属性，或者属性不等于特定值的元素。||attribute ^= value| 匹配给定的属性是以某些值开始的元素||attribute $= value| 匹配给定的属性是以某些值结尾的元素||attribute *= value| 匹配给定的属性是以包含某些值的元素||[selector1][selector2][selectorN]| 复合属性选择器，需要同时满足多个条件时使用。|12345678910console.log($("#div1&gt;*[id]")); //m.fn.init(7)[div#div2, div#div3, ul#ul1, div#div4, div#div5, ul#ul2.w100, ul#ul3]//#div1所有的子集中，包含属性名为id的元素集合console.log($("#div1&gt;*[id^=d]")); //m.fn.init(4) [div#div2, div#div3, div#div4, div#div5]//#div1所有的子集中，包含属性名为id，属性值以d开头的元素集合console.log($("#div1&gt;*[id$=1]")); //m.fn.init [ul#ul1]//#div1所有的子集中，包含属性名为id，属性值以1结尾的元素集合console.log($("#div1&gt;*[id*=3]")); //m.fn.init(2) [div#div3, ul#ul3]//#div1所有的子集中，包含属性名为id，属性值中包含3的元素集合console.log($("#div1&gt;*[id][class]")); //m.fn.init [ul#ul2.w100]#div1所有的子集中，包含属性名为id，同时也包含属性名为class的元素集合 子元素过滤选择器| 表示方式 | 解释 ||:——– | :—— ||:nth-child(N)| 匹配其父元素下的第N个子或奇偶元素||:first-child| 匹配所给选择器( :之前的选择器)的第一个子元素||:last-child| 匹配最后一个子元素||:only-child| 如果某个元素是父元素中唯一的子元素，那将会被匹配|12345678console.log($("#div1&gt;*:nth-child(1)")); //m.fn.init [div#div2]//在#div1的所有子集中，获取第一个元素（不是索引为1，而是第一个）console.log($("#div1&gt;*:eq(0)")); //m.fn.init [div#div2]//在#div1的所有子集中，获取索引为0的元素（不是第0个，而是索引为0）console.log($("#div1&gt;*:first-child")); //m.fn.init [div#div2]//在#div1的所有子集中，获取第一个元素console.log($("#div1&gt;*:last-child")); //m.fn.init [ul#ul3]//在#div1的所有子集中，获取最后一个元素 12345678&lt;ul&gt; &lt;li&gt;John&lt;/li&gt; &lt;li&gt;Karl&lt;/li&gt; &lt;li&gt;Brandon&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt; &lt;li&gt;Glen&lt;/li&gt;&lt;/ul&gt; 12$("ul li:only-child")//结果为：[ &lt;li&gt;Glen&lt;/li&gt; ] 表单选择器| 表示方式 | 解释 ||:——– | :—— ||:input| 匹配所有 input, textarea, select 和 button 元素||:text| 匹配所有的单行文本框||:password| 匹配所有密码框||:redio| 匹配所有单选按钮||:checkbox| 匹配所有复选框||:submit| 匹配所有提交按钮||:image| 匹配所有图像域||:reset| 匹配所有重置按钮||:button| 匹配所有按钮||:file| 匹配所有文件域|表单过滤选择器| 表示方式 | 解释 ||:——– | :—— ||:enabled| 匹配所有可用元素||:disabled| 匹配所有不可用元素||:checked| 匹配所有选中的被选中元素(复选框、单选框等，select中的option),对于select元素来说，获取选中推荐使用 :selected||:selected| 匹配所有选中的option元素||:enabled| 匹配所有可用元素|]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP报文]]></title>
    <url>%2F2019%2F02%2F16%2FHTTP%E6%8A%A5%E6%96%87%2F</url>
    <content type="text"><![CDATA[[Request Headers] view source1234567891011GET /index.html HTTP/1.1 请求起始行 HTTP method(请求方式)、请求地址、使用的HTTP传输协议版本号请求首部：客户端会把一些信息放在请求首部中传递给服务器端，服务器端就可以在请求首部中获取到相关内容【客户端设置 服务器端获取】Host: localhost:1000Connection: keep-aliveCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en;q=0.8 [Response Headers] view source1234567HTTP/1.1 200 OK 响应起始行：传输协议版本号、响应的状态码、状态码的说明响应首部：服务器端传递给客户端一些信息可以放在响应首部中，客户端可以在响应首部中获取到服务器的相关信息【服务器端设置 客户端获取】content-type: text/html;charset=utf-8 响应内容的格式和编码Date: Fri, 18 Jan 2019 12:30:12 GMT 服务器当前本次响应的时间（服务器时间是格林尼治时间，对应的北京时间需要在此基础上加上8个小时）Connection: keep-aliveTransfer-Encoding: chunked [Response] 响应主体，服务器端传递给客户端的数据内容都在响应主体中，客户端可以在响应的主体中获取到这些内容【服务端设置 客户端获取】 [Request Payload] 请求主体，客户端传递给服务器端的内容可以放在请求主体中传递给服务器端，服务器端可以再请求主体中获取到传递进来的内容 客户端传递给服务器端数据 请求URL后面问号传参的方式传递给服务器：/getList?name=zhuxiaolu&amp;age=21设置请求的首部（设置请求头信息）设置请求主体，把传递给服务器的内容放在请求主体中传递给服务器 服务器端传递给客户端数据 设置响应头信息设置响应主体内容]]></content>
      <categories>
        <category>网络知识</category>
      </categories>
      <tags>
        <tag>网络，基础，HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数据绑定以及应用]]></title>
    <url>%2F2019%2F02%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[数据绑定的几种方式，以及优缺点 利用动态创建元素节点和把它追加到页面中的方式实现页面绑定12345678function Data()&#123; for (var i = 0; i &lt; ary.length; i++) &#123; var oLi = document.createElement('li'); oLi.innerHTML = '&lt;span class="number"&gt;' + ((i + 4) &gt;= 10? (i + 4): '0' + (i + 4)) +'&lt;/span&gt;'+ ary[i].title; oUl.appendChild(oLi); &#125; OButton.innerHTML = "已加载完毕！";&#125; 优势：把需要绑定的内容一个一个的追加到页面中，对原来的元素没有任何的影响弊端：每当创建一个li，我们就添加到页面中，引发一DOM回流，最后引发回流的次数过多，影响我们的性能 字符串拼接的方式 首先循环遍历需要绑定的数据，然后把需要动态绑定的标签以字符串的方式拼接在一起，拼接完成之后，最后统一的添加到页面中字符串拼接绑定数据的方式是我们以后工作中最常用的一种绑定数据的方式，模板引擎数据绑定（jade, KTemplate, angular.js,backbone.js） 123456789101112function Data()&#123; var str = ''; for (var i = 0; i &lt; ary.length; i++) &#123; str += '&lt;li&gt;'; str += '&lt;span class="number"&gt;' + ((i + 4) &gt;= 10? (i + 4): '0' + (i + 4)) + '&lt;/span&gt;'; str += ary[i].title; str += '&lt;/li&gt;'; &#125; oUl.innerHTML += str; //oUl.innerHTML = oUl.innerHTML(把之前的三个li一字符串的方式获取到) + str; //拼接完成的整体还是字符串，最后把字符串统一的添加到页面中，浏览器需要把字符串渲染成为对应的标签 OButton.innerHTML = "已加载完毕！";&#125; 优势：是先把内容拼接好，最后统一添加到页面中，值引发一次回流弊端: 我们把新拼接的字符串添加到oUl中，原有的三个li的鼠标滑动效果消失了（原来标签绑定的事件都消失了） 文档碎片 1234567891011function Data() &#123; var frg = document.createDocumentFragment(); //创建一个文档碎片相当于临时创建了一个容器 for (var i = 0; i &lt; ary.length; i++) &#123; var oLi = document.createElement('li'); oLi.innerHTML = '&lt;span class="number"&gt;' + ((i + 4) &gt;= 10? (i + 4): '0' + (i + 4)) +'&lt;/span&gt;'+ ary[i].title; frg.appendChild(oLi); &#125; oUl.appendChild(frg); frg = null; OButton.innerHTML = "已加载完毕！";&#125; 利用到的知识：JSDOM深入知识回流：（重排reflow）,当页面中的HTML结构发生改变时，比如删除元素，增加元素，元素改变位置等。浏览器都需要从新的计算一遍最新的DOM结构，从新的对当前的页面进行渲染重绘：某一个元素的部分样式发生了改变了（背景颜色），浏览器只需要重新的渲染当前元素即可 绑定事件监听函数addEventListener() 或 attachEvent()addEventListener()函数语法： 1elementObject.addEventListener(eventName,handle,useCapture); 参数 说明 elementObject DOM对象（即DOM元素） elementName 事件名称。注意，这里的事件名称没有“ on ”，如鼠标单击事件 click ，鼠标双击事件 doubleclick ，鼠标移入事件 mouseover，鼠标移出事件 mouseout 等。 handle 事件句柄函数，即用来处理事件的函数 useCapture Boolean类型，是否使用捕获，一般用false attachEvent()函数语法： 1elementObject.attachEvent(eventName,handle); 参数 说明 elementObject DOM对象（即DOM元素） elementName 事件名称。注意，与addEventListener()不同，这里的事件名称有“ on ”，如鼠标单击事件 onclick ，鼠标双击事件 ondoubleclick ，鼠标移入事件 onmouseover，鼠标移出事件 onmouseout 等。 handle 事件句柄函数，即用来处理事件的函数 注意：事件句柄函数是指“ 函数名 ”，不能带小括号。 addEventListener()是标准的绑定事件监听函数的方法，是W3C所支持的，Chrome、FireFox、Opera、Safari、IE9.0及其以上版本都支持该函数；但是，IE8.0及其以下版本不支持该方法，它使用attachEvent()来绑定事件监听函数。所以，这种绑定事件的方法必须要处理浏览器兼容问题。下面绑定事件的代码，进行了兼容性处理，能够被所有浏览器支持： 12345678910function addEvent(obj,type,handle)&#123; try&#123; // Chrome、FireFox、Opera、Safari、IE9.0及其以上版本 obj.addEventListener(type,handle,false); &#125;catch(e)&#123; try&#123; // IE8.0及其以下版本 obj.attachEvent('on' + type,handle); &#125;catch(e)&#123; // 早期浏览器 obj['on' + type] = handle; &#125; &#125; 123&lt;span style="color: rgb(178, 34, 34); font-family: 'Microsoft Yahei', Arial, Helvetica, sans-serif; font-size: 14px; line-height: 22.4px; background-color: rgb(252, 252, 252);"&gt; 这里使用 try&#123; ... &#125; catch(e)&#123; ... &#125; 代替 if ... else... 语句，避免浏览器出现错误提示。&lt;/span&gt; 例如，为一个 id=”demo” 的按钮绑定事件，鼠标单击时弹出警告框： 123addEvent(document.getElementById("demo"),"click",myAlert);function myAlert()&#123; alert("又是一个警告框"); 取消函数绑定12345var x = document.getElementById(&apos;b1&apos;);x.addEventListener(&apos;click&apos;,aaa,false);//取消事件用x.removeEventListener(&apos;click&apos;,aaa,false); // // Chrome、FireFox、Opera、Safari、IE9.0及其以上版本x.detachEvent(&apos;click&apos;,aaa); // IE8.0及其以下版本 应用 实现新闻列表，新闻中的数据利用数据绑定实现，效果图如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//1. 获取我们要操作的元素var oUl = document.getElementById('news');var oLis = oUl.getElementsByTagName('li');//var OButton = document.getElementById('more');//绑定事件，鼠标放上，背景颜色改变,鼠标离开，背景颜色还原for (var i = 0; i &lt; oLis.length; i++) &#123; oLis[i].onmouseover = function()&#123; this.className = 'bg'; &#125; oLis[i].onmouseout = function()&#123; this.className = ''; &#125;&#125;var OButton = document.getElementById('more');function DateBind()&#123; alert('点击'); Data(); refresh(); OButton.removeEventListener("click",DateBind,false);&#125;OButton.addEventListener("click",DateBind, false); //这里利用动态绑定事件，可以方便执行一次之后移除（取消事件）//2. 数据绑定//（1）. 利用动态创建元素节点和把它追加到页面中的方式实现页面绑定//function Data()&#123;// for (var i = 0; i &lt; ary.length; i++) &#123;// var oLi = document.createElement('li');// oLi.innerHTML = '&lt;span class="number"&gt;' + ((i + 4) &gt;= 10? (i + 4): '0' + (i + 4)) +'&lt;/span&gt;'+ ary[i].title;// oUl.appendChild(oLi);// &#125;// OButton.innerHTML = "已加载完毕！";//&#125;//优势：把需要绑定的内容一个一个的追加到页面中，对原来的元素没有任何的影响//弊端：每当创建一个li，我们就添加到页面中，引发一DOM回流，最后引发回流的次数过多，影响我们的性能//(2).字符串拼接的方式//首先循环遍历需要绑定的数据，然后把需要动态绑定的标签以字符串的方式拼接在一起，拼接完成之后，//最后统一的添加到页面中//字符串拼接绑定数据的方式是我们以后工作中最常用的一种绑定数据的方式，//模板引擎数据绑定（jade, KTemplate, angular.js,backbone.js）//function Data()&#123;// var str = '';// for (var i = 0; i &lt; ary.length; i++) &#123;// str += '&lt;li&gt;';// str += '&lt;span class="number"&gt;' + ((i + 4) &gt;= 10? (i + 4): '0' + (i + 4)) + '&lt;/span&gt;';// str += ary[i].title;// str += '&lt;/li&gt;';// &#125;// oUl.innerHTML += str; //oUl.innerHTML = oUl.innerHTML(把之前的三个li一字符串的方式获取到) + str;// //拼接完成的整体还是字符串，最后把字符串统一的添加到页面中，浏览器需要把字符串渲染成为对应的标签// OButton.innerHTML = "已加载完毕！";//&#125;//优势：是先把内容拼接好，最后统一添加到页面中，值引发一次回流//弊端:我们把新拼接的字符串添加到oUl中，原有的三个li的鼠标滑动效果消失了（原来标签绑定的事件都消失了）//JSDOM深入知识//回流：（重排reflow）,当页面中的HTML结构发生改变时，比如删除元素，增加元素，元素改变位置等。浏览器都需要//从新的计算一遍最新的DOM结构，从新的对当前的页面进行渲染//重绘：某一个元素的部分样式发生了改变了（背景颜色），浏览器只需要重新的渲染当前元素即可//3.文档碎片function Data() &#123; var frg = document.createDocumentFragment(); //创建一个文档碎片相当于临时创建了一个容器 for (var i = 0; i &lt; ary.length; i++) &#123; var oLi = document.createElement('li'); oLi.innerHTML = '&lt;span class="number"&gt;' + ((i + 4) &gt;= 10? (i + 4): '0' + (i + 4)) +'&lt;/span&gt;'+ ary[i].title; frg.appendChild(oLi); &#125; oUl.appendChild(frg); frg = null; OButton.innerHTML = "已加载完毕！";&#125;function refresh()&#123; oLis = oUl.getElementsByTagName('li');//绑定事件，鼠标放上，背景颜色改变,鼠标离开，背景颜色还原 for (var i = 3; i &lt; oLis.length; i++) &#123; oLis[i].onmouseover = function()&#123; this.className = 'bg'; &#125; oLis[i].onmouseout = function()&#123; this.className = ''; &#125; &#125;&#125;]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中call和apply的应用]]></title>
    <url>%2F2019%2F02%2F16%2FJS%E4%B8%ADcall%E5%92%8Capply%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[求数组中的最大值和最小值 方案一：首先给数组进行从小到大排序，第一个就是最小值，最后一个就是最大值1234567var ary = [23, 34, 24, 12, 35, 36, 14, 25];ary.sort(function(a,b)&#123; return a-b;&#125;);var min = ary[0];var max = ary[ary.length - 1];console.log('min: ' + min + ', max:' + max); 方案二：假设法：假设当前的数组中的第一个值是最大值，然后拿这个值和后面的每一项逐一进行比较，如果后面的某一个值比假设的值还要大，说明假设的值并不是最大的，这就需要把假设的值与当前值进行替换和自定义属性一样，它们都是JS中最常用的编程思想12345678var ary = [23, 34, 24, 12, 35, 36, 14, 25];var min = max = ary[0];for(var i = 0; i &lt; ary.length; i++)&#123; var cur = ary[i]; cur &lt; min ? min = cur : null; cur &gt; max ? max = cur : null;&#125;console.log('min: ' + min + ', max:' + max); 方案三：利用Math中的max / min方法实现 以下代码实现不了需求：1234var ary = [23, 34, 24, 12, 35, 36, 14, 25];var min = Math.min(ary);console.log(min); //NaNconsole.log([23, 34, 24, 12, 35, 36, 14, 25]); // =&gt; 12 Math.min()在执行的时候，把需要比较的那一堆数一个个的传递进来，这样才可以得到最后的结果，一下放一个ary数组是不可以的 尝试解决问题 先通过jion / toString方法将其变成字符串eval(&#39;23, 34, 24, 12, 35, 36, 14, 25&#39;)只能得到最后一项的值 =》 25 解释如下: eval 把一个字符串变为JS表达式执行例如：eval(&#39;1+2+3+4&#39;) =》 10 括号表达式 （x1, x2, x3, x4, ...）括号表达式，一个括号中出现多个内容，中间用，隔开，但是我们最后获取到的只有最后一项123456function fn1()&#123; console.log(1);&#125;function fn2()&#123; console.log(2);&#125; ；(fn1, fn2)(); =&gt; 2 只有fn2执行了1234function fn2()&#123; console.log(this);&#125;var obj = &#123;name: '朱小露', fn: fn2&#125;; (fn2, obj.fn)();最后执行 的是obj.fn,也就是fn2，但是执行的时候里面的this变成了window，而不是obj相当于(fn2, function fn2(){ console.log(this); })(); 正确解决方式1： &#39;Math.max(&#39; + ary.toString() + &#39;)&#39; =&gt; &#39;Math.max(23, 34, 24, 12, 35, 36, 14, 25)&#39;首先不要管其他 的，先把我们最后要执行的代码都变成字符串，然后把数组中的每一项的值分别拼接到这个字符串中1234var ary = [23, 34, 24, 12, 35, 36, 14, 25];var min = eval('Math.min(' + ary.toString() + ')');var max = eval('Math.max(' + ary.toString() + ')');console.log('min: ' + min + ', max:' + max); 正确解决方式2： 利用apply方法，利用apply给方法用数组传参的方式，将需要求值的数组传递过去，此时需要用到null进行占位，因为第一个参数是更改this的值，由于这里没有实际作用，因此用null做占位符即可。1234var ary = [23, 34, 24, 12, 35, 36, 14, 25];var min = Math.min.apply(null, ary); var max = Math.max.apply(null, ary);console.log('min: ' + min + ', max:' + max); 求平均数123456789101112131415function avgFn()&#123; //1. 将类数组转换为数组 var ary = []; for(var i = 0; i &lt; arguments.length; i++)&#123; ary[ary.length] = arguments[i]; &#125; //2.给数组进行排序，去掉开头最小值和结尾最大值，剩下的求平均数 ary.sort(function(a, b)&#123; return a-b; &#125;); ary.shift(); ary.pop(); return (eval(ary.join('+')) / ary.length ).toFixed(2);&#125;console.log(avgFn(9.8, 9.7, 10, 9.9, 9.0, 9.8, 3.0)); 如果直接使用arguments.sort()，则会报错因为arguments是一个类数组集合，它不是数组，不能直接使用数组的方法 优化方法 借用数组原型上的slice方法，当slice执行的时候，让方法中的this变成我们需要处理的arguments，实现将类数组arguments转换为数组12345678910111213function avgFn()&#123; //1. 将类数组转换为数组:把arguments克隆一份一模一样的数组 var ary = Array.prototype.slice.call(arguments); //2.给数组进行排序，去掉开头最小值和结尾最大值，剩下的求平均数 ary.sort(function(a, b)&#123; return a-b; &#125;); ary.shift(); ary.pop(); return (eval(ary.join('+')) / ary.length ).toFixed(2);&#125;console.log(avgFn(9.8, 9.7, 10, 9.9, 9.0, 9.8, 3.0)); var ary = Array.prototype.slice.call(arguments); 与 var ary = [].slice.call(arguments);等价 不用将arguments转换为数组，借用数组的方法123456789function avgFn()&#123; [].sort.call(arguments,function(a, b)&#123; return a-b; &#125;); [].shift.call(arguments); [].pop.call(arguments); return (eval([].join.call(arguments,'+')) / arguments.length ).toFixed(2);&#125;console.log(avgFn(9.8, 9.7, 10, 9.9, 9.0, 9.8, 3.0));]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数据绑定之DOM映射]]></title>
    <url>%2F2019%2F02%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E4%B9%8BDOM%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[DOM映射机制页面中的标签和JS中获取到的元素对象（元素集合）是紧紧绑定在一起的，页面中的HTML结构改变了，JS中不需要重新获取，集合里面的内容也会跟着自动改变12345678910111213//html代码&lt;div class="box"&gt; &lt;ul id="ul1"&gt; &lt;li&gt;98&lt;/li&gt; &lt;li&gt;99&lt;/li&gt; &lt;li&gt;96&lt;/li&gt; &lt;li&gt;95&lt;/li&gt; &lt;li&gt;90&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;//JS代码var oUl = document.getElementById('ul1');var oLis = oUl.getElementsByTagName('li'); console.log(oLis.length); =&gt; 5 var oLi = document.createElement(&#39;li&#39;); oUl.appendChild(oLi); console.log(oLis.length); //=&gt;6 没有重新的获取，但是oLis这个集合的长度和内容会自动跟着发生改变 应用示例简单表格排序 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;数据绑定之简单表格排序&lt;/title&gt; &lt;link rel="stylesheet" href="数据绑定之简单表格排序.css"/&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box"&gt; &lt;ul id="ul1"&gt; &lt;li&gt;98&lt;/li&gt; &lt;li&gt;99&lt;/li&gt; &lt;li&gt;96&lt;/li&gt; &lt;li&gt;95&lt;/li&gt; &lt;li&gt;90&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src="../utils/utils.js"&gt;&lt;/script&gt;&lt;script src="数据绑定之简单表格排序.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617*&#123; margin:0; padding:0;&#125;.box&#123; width:200px; height:300px; margin: 10px auto;&#125;.box #ul1&#123; list-style: none;&#125;.box #ul1 li&#123; height:30px; line-height: 30px; border-bottom: 2px dotted green;&#125; 12345678910111213141516171819202122232425262728293031323334353637///获取我们需要操作的元素var oUl = document.getElementById('ul1');var oLis = oUl.getElementsByTagName('li');//鼠标滑过变色for(var i=0; i&lt;oLis.length; i++)&#123; var cur = oLis[i]; cur.onmouseover = function()&#123; this.style.backgroundColor = '#86f00cab'; &#125; cur.onmouseout = function()&#123; this.style.backgroundColor = ''; &#125;&#125;sort();//为表格元素进行排序function sort()&#123; //1.先把表格排序类数组转换为数组 ary = utils.listToArray(oLis); //2.给数组进行排序 ary.sort(function(a,b)&#123; return parseFloat(a.innerHTML) - parseFloat(b.innerHTML); &#125;); //3.按照ary中存储的最新顺序依次把对应的li添加到页面中 var frg = document.createDocumentFragment(); for (var i = 0; i &lt; ary.length; i++) &#123; var cur = ary[i]; frg.appendChild(ary[i]); &#125; oUl.appendChild(frg); frg = null;&#125; 应用示例复杂表格排序 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;数据绑定之复杂表格排序&lt;/title&gt; &lt;link rel="stylesheet" href="数据绑定之复杂表格排序.css"/&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box"&gt; &lt;h1&gt;笑傲江湖排行榜&lt;/h1&gt; &lt;table class="tab" id="tab" cellpadding="0" cellspacing="0"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th class="cursor"&gt; 年龄 &lt;/th&gt; &lt;th class="cursor"&gt; 武力 &lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;!--引入JS是有顺序限制的，根据JS之间的依赖关系，我们按照顺序依次引入，顺序一旦出现问题，就会发生错误--&gt;&lt;script src="../utils/utils.js"&gt;&lt;/script&gt;&lt;script src="数据绑定之复杂表格排序.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061*&#123; margin: 0; padding: 0; font-size: 16px; -webkit-user-select:none;&#125;.box&#123; margin: 10px auto; width: 400px; border: 1px solid #abc7eb; border-radius:10px; /*x轴偏移3像素，y轴偏移3像素，阴影的模糊半径是10像素，阴影的扩展半径是0， 颜色是#4ea1ef */ box-shadow: 3px 3px 10px 0 #4ea1ef;&#125;.box h1&#123; width: 180px; margin: 15px auto 0 auto; color: #1388ef; font-size: 1.5em;&#125;.box .tab&#123; margin: 20px; width:360px;&#125;.box .tab thead&#123; background-color: #1388ef; color:white;&#125;.box .tab thead th&#123; width:160px; color:white; text-align: center; position: relative;&#125;.box .tab thead th span&#123; color:white; line-height: 40px; text-align: center;&#125;.box .tab thead th .image&#123; width: 16px; height: 32px; position: absolute; right: 5px; top:0;&#125;.box .tab thead th .image img&#123; width: 16px; height: 16px;&#125;.box .tab thead th.cursor&#123; cursor: pointer;&#125;.box .tab tbody tr.bg&#123; background-color: #9ed0ff;&#125;.box .tab tbody tr td&#123; font-size: 14px; padding:4px; text-align: center;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/*想要操作谁就获取谁*/var oTab = document.getElementById('tab');var tHead = oTab.tHead; //获取表格中的thead元素，只有表格才有的方法,注意是大写的Hvar oThs = tHead.rows[0].cells; //获取thead中的所有行中的第一行中的所有列var tBody = oTab.tBodies[0]; //获取thead中的第一个tbody，因为tbody可以不止一个var oRows = tBody.rows; //获取tbody中的所有行var data = null;//首先获取后台（data.txt）中的数据：JSON格式的字符串 -&gt; AJAX(async javascript and xml)//(1)首先创建一个AJAX对象var xhr = new XMLHttpRequest;//(2)打开我们需要请求数据的那个文件地址xhr.open("get", "JSON/data.txt", false);//参数一是请求方式， 参数二是JSON 数据文件的相对地址， 参数三：true是异步。false是同步//(3)监听请求的状态xhr.onreadystatechange = function ()&#123; if(xhr.readyState === 4 &amp;&amp; /^2\d&#123;2&#125;$/.test(xhr.status))&#123; var val = xhr.responseText; data = utils.jsonParse(val); &#125;&#125;//(4)发送请求xhr.send();//2. 实现数据绑定function dataBind()&#123; var frg = document.createDocumentFragment(); for(var i = 0; i &lt; data.length; i ++)&#123; var curr = data[i]; var otr = document.createElement('tr'); //每一次循环创建一个TR //每次循环中还需要创建4个TD，因为每一个对象中有四组键值对 for (var key in curr) &#123; //创建TD var oTd = document.createElement('td'); //对性别进行特殊处理 if(key === "sex")&#123; oTd.innerHTML = curr[key] == 1 ? '女' : '男'; &#125;else&#123; oTd.innerHTML = curr[key]; &#125; otr.appendChild(oTd); &#125; frg.appendChild(otr); &#125; tBody.appendChild(frg); frg = null;&#125;dataBind();//3. 实现隔行变色function changeBg()&#123; for (var i = 0; i &lt; oRows.length; i++) &#123; oRows[i].className = i % 2 == 1 ? "bg" : null; &#125;&#125;changeBg();//4. 编写表格排序的方法: 按照年龄这一列进行排序function sort(n)&#123; //n 是当前点击列的索引 //this -&gt; oThs[1] var _this = this; //1.把存储所有行的类数组转换为类数组 var ary = utils.listToArray(oRows); //点击当前列，需要让其他的列的flag存储的值回归到初始值-1， //这样返回头点击其他的列，才是按照升序排列的 for (var i = 0; i &lt; oThs.length; i++) &#123; if(oThs[i] != this)&#123; oThs[i].flag = -1; &#125; &#125; //2. 给数组进行排序：按照每一行的第二列中的内容从小到大进行排序 _this.flag *= -1; //每一次执行sort,进来的每一步就是让flag先乘以 -1 ary.sort(function(a, b)&#123; //this -&gt; window return (parseFloat(a.cells[n].innerHTML) - parseFloat(b.cells[n].innerHTML)) * _this.flag; &#125;); //按照ary中的最新数据，把每一行重新添加到tBody中 var frg = document.createDocumentFragment(); for (var i = 0; i &lt; ary.length; i++) &#123; var curr = ary[i]; frg.appendChild(curr); &#125; tBody.appendChild(frg); frg = null; changeBg();&#125;for (var i = 0; i &lt; oThs.length; i++) &#123; var curr = oThs[i]; if(curr.className === 'cursor')&#123; curr.index = i; curr.flag = -1; //给当前点击的这一列增加一个自定义属性flag，存储的值的是-1 curr.onclick = function()&#123; //this -&gt; curr //sort(); //sort中的this -&gt; window sort.call(this, this.index); //这里的this.index千万不能换成i,因为当函数执行的时候，i会等于oThs.length,不再是calssName = cursor的i了 //当然也不能是curr.index,只能是this.index &#125; &#125;&#125;]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则的详解]]></title>
    <url>%2F2019%2F02%2F16%2F%E6%AD%A3%E5%88%99%E7%9A%84%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[正则的作用 正则：就是一个规则，用来处理字符串的一个规则（正则就是用来处理字符串的）处理： 匹配：判断一个字符串是否符符合我们制定的规则test:reg.test(str)1234var reg = /\d/; //包含一个0-9之间的数字console.log(reg.test('朱')); //falseconsole.log(reg.test('1')); //trueconsole.log(reg.test('朱小露2018')); //true 捕获：把字符串中符合我们正则规则的内容捕获到exec:reg.exec(str)123var reg = /\d/; //包含一个0-9之间的数字console.log(reg.exec('朱')); //nullconsole.log(reg.exec('1')); //["1", index: 0, input: "1", groups: undefined] 如何创建一个正则 字面量方式var reg = /\d/;实例创建方式var reg = new RegExp(&quot;&quot;);正则的两种创建方式是有区别的如何学习正则console.dir(RegExp.prototype); ###元字符 每一个正则表达式都是由元字符和修饰符组成在//之间具有意义的一些字符1. 具有特殊意义的元字符\：转义字符，转译后面字符所代表的含义^：以某一个元字符开始$：以某一个元字符结尾\n：换行符.：除了\n以外的任意字符()：分组，把一个大正则本身划分成几个小正则x|y：x或者y中的一个[xyz]：x或者y或者z中的一个[^xyz]：除了xyz三个以外的任意字符[a-z]：a-z之间的任意一个字符[^a-z]：除了a-z之间的任意一个字符\d：0-9之间的数字\D：除了0-9之间的数字以外的任何字符\b：匹配一个边界符\w：数字、字母、下划线中的任意一个字符 = [0-9a-zA-Z_]\s：匹配一个空白字符：空格、一个制表符、换页符…1234567891011121314151617181920212223242526272829303132333435363738394041424344//\var reg = /\d/; //包含一个0-9之间的数字console.log(reg.exec('朱小露2018')); //true//^，$reg = /^\d$/; //只能是一个0-9之间的数字console.log(reg.test('9')); //trueconsole.log(reg.test('012')); //false//.var reg = /^0.2$/; //表示只能是以0开头，以2结尾的，中间是一个除\n之外的任意字符console.log(reg.test('0.2')); //trueconsole.log(reg.test('0-2')); //trueconsole.log(reg.test('0\n2')); //falsereg = /^0\.2$/; //这里用\对.进行转义，此时.表示的一个普通小数点，没有特殊含义，表示只能是小数0.2console.log(reg.test('0.2')); //trueconsole.log(reg.test('0-2')); //false//()reg = /^(\d+)zhuxiaolu(\d+)/;``` &gt;`reg = /^\d$/`：`^`和`$`都不占位置，只有`\d`才占一个位置**`2. 代表出现次数的量词元字符`**&gt;`*`：出现0到多次&gt;`+`：出现1到多次&gt;`?`：出现0到1次&gt;`&#123;n&#125;`：出现n次&gt;`&#123;n,&#125;`：出现n到多次&gt;`&#123;n,m&#125;`：出现n到m次```javascriptvar reg = /^\d+&amp;/; //只能是1到多个0-9之间的数字console.log(reg.exec('2018')); //true``` ----------### 元字符应用以及一些知识点&gt;`[]`1. 在中括号中出现的所有的字符都是代表本身意思的字符（没有特殊含义）```javascriptvar reg = /^[.]&amp;/; //只能是一个小数点console.log(reg.exec('1')); //falseconsole.log(reg.exec('.')); //true 中括号中不识别两位数1234var reg = /^[12]&amp;/; //[xy]1或2中的其中一个var reg = /^[12-68]&amp;/; //1或者2-6中的一个、8 三个中的任何一个var reg = /^[\w-]&amp;/; //数字、字母、下划线、-三个中的任何一个console.log(reg.test('-')); //true () 分组的作用一：改变x|y的默认优先级123456789101112131415161718192021222324252627282930313233343536373839404142434445var reg = /^18|19&amp;/;//可以识别 18、19、189、119、1819、819、181...var reg = /^(18|19)&amp;/;//可以识别 18、19``` **`一个简单的验证手机号的正则`**&gt;总共11位，以1开始即可&gt;`var reg = /^1\d&#123;10&#125;$/`**`有效数字的正则`**&gt;"."可以出现也可以不出现，但是一旦出现，后面必须跟着一位或者多位数字&gt;最开始可以有+ / -出现，也可以没有&gt;整数部分，可以是一位数（0-9之间的任何一个），也可以是多位数（不能以0开头）&gt;`var reg = /^[+-]?(\d|([1-9]\d+))(\.\d+)?$/;`**`年龄介于18~65的正则`**&gt;将18~65拆分成3段 ：18~19 20~59 60~65&gt;`var reg = /^(1[8-9])|([2-5]\d)|(6[0-5])$/;`**`验证邮箱的正则(简版)`**&gt;左边：数字、字母、下划线、. 、-&gt;1586752553@qq.com&gt;1586752553@qq.com.cn&gt;baidu@baidu.cn&gt;zhu_xiao_lu@163.com&gt;`var reg = /^[\w.-]+@[0-9a-zA-Z]+(\.[a-zA-Z]&#123;2,4&#125;)&#123;1,2&#125;$/;`**`中国标准真实姓名的正则`**&gt;2~4位汉字&gt;`var reg = /^[\u4e00-\u9fa5]&#123;2,4&#125;$/;`**`身份证号码的正则`**&gt;18位数字，最后一位可以是数字，也可以是X&gt;`var reg = /^\d&#123;17&#125;(\d|X)$/;`----------### 正则的创建方式&gt;`字面量`&gt;在字面量方式中，`//`之间包起来的所有的内容都是元字符，有的具有特殊意义，大部分都是代表本身含义的普通字符```javascriptvar name = 'zhuxiaolu';var reg = /^\d+"+name+"\d+$/;console.log(reg.test('2015zhuxiaolu2016')); //falseconsole.log(reg.test('2015""namee"016')); //true 对于上述需求，我们只能使用实例创建的方式了var reg = new RegExp(&quot;^\\d+&quot; + name + &quot;\\d+$&quot;)1234567var name = 'zhuxiaolu';var reg = new RegExp("^\d+" + name + "\d+$"); //字符串里面的\d不能识别console.log(reg.test('2015zhuxiaolu2016')); //falseconsole.log(reg.test('2015""namee"016')); //falsereg = new RegExp("^\\d+" + name + "\\d+$");console.log(reg.test('2015zhuxiaolu2016')); //true 字面量方式和实例创建的方式在正则中的区别？ 字面量方式中出现的一切都是元字符，所以不能进行变量值的拼接，而实例创建的方式是可以的 字面量方式中直接写入\d就可以，而在实例中需要把它转义 \\d 正则的捕获 exec：正则的捕获 1. 捕获到的内容是一个大数组 数组中的第一项是当前大正则捕获的内容 index：捕获的内容在字符串中开始的索引位置 input：捕获的原始字符串1234var reg = /\d+/;var str = "zhuxiaolu2018";var res = reg.exec(str);console.log(res); 输出结果：[&quot;2018&quot;, index: 9, input: &quot;zhuxiaolu2018&quot;, groups: undefined] 2. 正则捕获的特点 懒惰性：每一次执行exec，只捕获第一个匹配的内容，在不进行任何处理的情况下，再执行多次捕获，捕获的还是第一个匹配的内容 lastIndex：是正则每一次捕获在字符串中开始查找的位置，默认值是012345678910var reg = /\d+/;var str = "zhuxiaolu2018xiaonuan2017";console.log(reg.lastIndex); //0var res = reg.exec(str);console.log(res); //["2018", index: 9, input: "zhuxiaolu2018", groups: undefined]//第二次通过exec捕获的内容还是第一个'2018'console.log(reg.lastIndex); //0 说明我们第二次捕获的时候，也是要从字符串索引出为0开始查找res = reg.exec(str);console.log(res); //["2018", index: 9, input: "zhuxiaolu2018", groups: undefined] 3. 如何解决懒惰性 在正则的末尾加上一个修饰符”g”（/../g）global(g)：全局匹配ignoreCase(i)：忽略大小写multiline(m)：多行匹配原理：加了全局修饰符g，正则每一次捕获结束之后，我们的lastIndex的值都变成了最新的值，下次捕获从最新的位置开始查找，这样就可以把所有需要捕获的内容全捕获到了123456789var reg = /\d+/g;var str = "zhuxiaolu2018xiaonuan2017";console.log(reg.lastIndex); //0var res = reg.exec(str);console.log(res); //["2018", index: 9, input: "zhuxiaolu2018xiaonuan2017", groups: undefined]console.log(reg.lastIndex); //13res = reg.exec(str);console.log(res); //["2017", index: 21, input: "zhuxiaolu2018xiaonuan2017", groups: undefined] 自己编写程序，获取正则捕获的所有内容（一定不要忘记加g）123456789var reg = /\d+/g;var str = "zhuxiaolu2018xiaonuan2017";var res = reg.exec(str);var ary = [];while(res != null)&#123; ary.push(res[0]); res = reg.exec(str);&#125;console.log(ary); 4. 正则的贪婪性 正则每一次捕获的都是按照匹配最长的结果捕获的，例如：2符合正则，2018也符合正则，我们默认捕获的是20181234var reg = /\d+/g;var str = "zhuxiaolu2018xiaonuan2017";var res = reg.exec(str);console.log(res); //["2018", index: 9, input: "zhuxiaolu2018xiaonuan2017", groups: undefined] 5. 如何解决正则的贪婪性 在量词元字符后面添加一个?即可?在正则中有很多的作用： 放在一个普通元字符的后面，代表出现0-1次 /\d?/ =&gt; 数字可能出现也可能不出现 放在一个量词的元字符后面是取消捕获时候的贪婪性1234var reg = /\d+?/g;var str = "zhuxiaolu2018xiaonuan2017";var res = reg.exec(str);console.log(res); //["2", index: 9, input: "zhuxiaolu2018xiaonuan2017", groups: undefined] 自己编写程序，获取正则捕获的内容(解决贪婪性后的内容)（一定不要忘记加?）123456789var reg = /\d+?/g;var str = "zhuxiaolu2018xiaonuan2017";var res = reg.exec(str);var ary = [];while(res != null)&#123; ary.push(res[0]); res = reg.exec(str);&#125;console.log(ary); 6. 字符串中的match方法，把所有和正则匹配的字符都获取到1234var reg = /\d+/g;var str = "zhuxiaolu2018xiaonuan2017";var res = str.match(reg);console.log(res); 虽然在当前的情况下match下比我们的exec更加的简便一些，但是match中存在一些自己处理不了的问题： 在分组捕获的情况下，match只能获取到大正则匹配的内容，而对于小正则则捕获的内容是无法获取的 正则分组 改变优先级 分组引用 var reg = /^(\w)\1(\w)\2/ \2代表和第二个分组出现一模一样的内容；\1和第一个分组出现一模一样的内容一模一样：和对应的分组中内容的值都要一模一样 1234var reg = /^(\w)\1(\w)\2$/;console.log(reg.test('aaff')); //trueconsole.log(reg.test('affa')); //falseconsole.log(reg.test('a0f_')); //false 分组捕获 正则在捕获的时候，不仅仅是把大正则匹配的内容捕获到，而且还可以把小分组匹配的内容捕获到1234var reg = /^(\d&#123;2&#125;)(\d&#123;4&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d)(\d|X)$/;var str = '500235199809036527';console.log(reg.exec(str)); // ["500235199809036527", "50", "0235", "1998", "09", "03", "2", index: 0, input: "500235199809036527", groups: undefined]console.log(str.match(reg)); //和exec获取的结果是一样的 var ary = [&quot;500235199809036527&quot;, &quot;50&quot;, &quot;0235&quot;, &quot;1998&quot;, &quot;09&quot;, &quot;03&quot;, &quot;65&quot;, &quot;2&quot;, &quot;7&quot;, index: 0, input: &quot;500235199809036527&quot;, groups: undefined]ary[0]： 大正则匹配的内容ary[1]： 第一个分组捕获的内容ary[2]： 第二个分组捕获的内容 ?:：在分组中?:的意思是只匹配不捕获1234var reg = /^(\d&#123;2&#125;)(\d&#123;4&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(?:\d&#123;2&#125;)(\d)(?:\d|X)$/;var str = '500235199809036527';console.log(reg.exec(str)); // ["500235199809036527", "50", "0235", "1998", "09", "03", "2", index: 0, input: "500235199809036527", groups: undefined]console.log(str.match(reg)); //和exec获取的结果是一样的 match与exec不相同的情况123456var reg = /zhuxiaolu(\d+)/g;var str = 'zhuxiaolu2016zhuxiaolu2017zhuxiaolu2018';console.log(reg.exec(str));console.log(reg.exec(str));console.log(reg.exec(str));console.log(str.match(reg)); 用exec执行三次，每一次不仅仅是把大正则捕获到，而且还可以获取第一个分组匹配的内容，而match只能捕获大正则匹配的内容 replace以及应用案例 replace：将原有字符替换成新的字符 在不使用正则的情况下，执行一次replace只能替换字符串中的一个，再次执行，依然是从字符串第一个位置开始 在repalce中，我们可以一次批量的把所有正则匹配的内容都替换掉，repalce是支持正则的123var str = "zhuxiaolu2017zhuxiaolu2018";str = str.replace("zhuxiaolu", "朱小露");console.log(str); //朱小露2017zhuxiaolu2018 123var str = "zhuxiaolu2017zhuxiaolu2018";str = str.replace(/zhuxiaolu/g, "朱小露");console.log(str); //朱小露2017朱小露2018 原理：先按照正则指定的规则，到字符串中把正则匹配的内容捕获到，然后再每一次捕获到之后，都把捕获的内容替换成新的内容 正则表达式捕获几次，对应的后面的function就要执行几次 每一次执行function的时候，我们都可以获取到我们捕获的内容，和我们单独执行exec捕获的内容非常相似123arguments[0] = exec捕获数组的第一项 = 大正则捕获的内容arguments[1] = exec捕获数组的index = 开始捕获的索引arguments[2] = exec捕获数组的input = 捕获的原始字符串 不仅如此，我们小分组捕获的内容，在这里同样可以获取到 在function中，通过return来返回我们要替换的内容，return是啥就把大正则捕获的内容进行替换成啥 如果不写return，则默认返回的是undefined，即用undefined进行替换 如果不想实现替换的话，捕获的内容是啥，我们就返回啥 return arguments[0] replace应用案例 将小写的数字替换成大写的中文数字 123456var str = "5201314";var ary = ['零','壹','贰','叁','肆','伍','陆','柒','捌','玖'];str = str.replace(/\d/g, function()&#123; return ary[arguments[0]];&#125;);console.log(str); 获取一个字符串中出现次数最多的字符，并且获取出现的次数 12345678910111213141516var str = "xiaonuanshizhichouzhuzhu";var obj = &#123;&#125;;str.replace(/[a-z]/g, function()&#123; if(obj[arguments[0]] &gt;= 1)&#123; obj[arguments[0]] += 1; &#125;else&#123; obj[arguments[0]] = 1; &#125;&#125;);console.log(obj);var max = obj['x'];var temp = 'x';for(key in obj)&#123; obj[key] &gt; max ? (max = obj[key],temp = '' + key) : null;&#125;console.log("出现最多的字符是：" + temp + "，出现的次数是：" + max); 模板引擎实现的初步原理 12345678910var str = "my name &#123;0&#125;, my age is &#123;1&#125;, i come from &#123;2&#125;, i love &#123;3&#125;";var ary = ['朱小露', '20', 'china', '肖暖'];var reg = /&#123;(\d+)&#125;/g;str = str.replace(/&#123;(\d+)&#125;/g, function()&#123; return ary[arguments[1]]; //console.log(arguments); //console.log(RegExp.$1); //return ary[RegExp.$1]; //在IE下不兼容&#125;);console.log(str); 时间字符串格式化 2018/9/25 23:17:03 -&gt; 2018年09月25日 23时17分03秒 1234567891011121314//在String的原型上，添加一个时间字符串格式化的方法String.prototype.myFormatTime = function()&#123; var reg = /^(\d&#123;4&#125;)(?:-|\/|\.|:)(\d&#123;1,2&#125;)(?:-|\/|\.|:)(\d&#123;1,2&#125;)(?:\s+)(\d&#123;1,2&#125;)(?:-|\/|\.|:)(\d&#123;1,2&#125;)(?:-|\/|\.|:)(\d&#123;1,2&#125;)$/; var ary = []; this.replace(reg, function()&#123; ary = ([].slice.call(arguments,1,7)); &#125;); var format = arguments[0] || "&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒"; return format.replace(/&#123;(\d+)&#125;/g, function()&#123; var temp = ary[arguments[1]]; return temp.length === 1? ("0" + temp) : temp; &#125;);&#125;console.log("2018/9/25 23:17:03".myFormatTime ()); //2018年09月25日 23时17分03秒 把一个字符串中的所有单词的首字母大写 “ming dei bo xue qiu shi zhi yuan” -&gt; “Ming Dei Bo Xue Qiu Shi Zhi Yuan” 1234567891011var str = "ming dei bo xue qiu shi zhi yuan";var ary1 = [];var ary2 = [];var reg = /((\w)\w+)\s/g;str.replace(reg, function()&#123; ary1.push(arguments[1]); ary2.push(arguments[2].toUpperCase());&#125;);for(var key in ary1)&#123; ary1[key].shift&#125; URL地址解析 要求将https://search.bilibili.com/all?keyword=&#39;JS珠峰&#39;&amp;from_source=banner_search，改写成obj ={ keyword: &#39;JS珠峰&#39;, from_source:banner_search } 12345678910String.prototype.myQueryURLParameter = function()&#123; var reg = /([^?=&amp;]+)=([^?=&amp;]+)/g; var obj = &#123;&#125;; this.replace(reg, function()&#123; obj[arguments[1]] = arguments[2]; &#125;); return obj;&#125;var str = "https://search.bilibili.com/all?keyword='JS珠峰'&amp;from_source=banner_search";console.log(str.myQueryURLParameter());]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中深入原型链模式之常用的六种继承方法]]></title>
    <url>%2F2019%2F02%2F16%2FJS%E4%B8%AD%E6%B7%B1%E5%85%A5%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%85%AD%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[原型继承 原型继承是我们JS中最常用的一种继承方式子类B想要继承父类A中的属性和方法（私有+ 公有），只需要让B.prototype = new A ;即可。原型的特点：它是把父类中私有的 + 公有的都继承到了子类原型上（子类公有的 ） 核心：原型继承并不是把父类中的属性和方法克隆一份一模一样的给B，而是让B和A之间增加了原型链的连接，以后B 的实例n想要A中的getX方法，需要一级一级的向上进行查找来使用。父类：function A() { this.x = 100; } A.prototype.getX = function(){ console.log(this.x); }子类：function B(){ this.y = 200; }子类继承父类B.prototype = new A;最后修改Constructor的指向B.prototype.constructor = B ;12345678910111213141516171819//#div1.__proto__ -&gt; HTMLDivElement.prototype -&gt; HTMLElement.prototype-&gt;Element.prototype -&gt; Node.prototye -&gt; EventTarget.prototype -&gt; Object.prototypefunction myObject()&#123;&#125;myObject.prototype = &#123; constructor: Object, hasOwnProperty: function()&#123;&#125;&#125;function myEventTarget()&#123;&#125;myEventTarget.prototype = new myObject;myEventTarget.prototype.addEventListener = function()&#123;&#125;;function myNode()&#123;&#125;myNode.prototype = new myEventTarget;myNode.prototype.createElement = function()&#123;&#125;;myNode.prototype.constructor = myNode;var n = new myNode;console.dir(n); call继承 把父类私有的属性和方法克隆一份一模一样的，作为子类私有的属性1234567891011function A()&#123; this.x = 100;&#125;A.prototype.getX = function()&#123; console.log(this.x);&#125;function B()&#123; A.call(this); //-&gt;A.call(n) 把A执行，并让A中私有的属性和方法中的this变成n&#125; var n = new B;console.log(n.x); //-&gt; 100 冒充对象继承 把父类私有的 + 公有的（这里是可控制的，用hasOwnProperty()或propertyIsEnumberable()做筛选即可)，克隆一份一模一样的的给子类私有的。123456789101112131415function A()&#123; this.x = 100;&#125;A.prototype.getX = function()&#123; console.log(this.x);&#125;function B()&#123; var temp = new A; for(var key in temp)&#123; this[key] = temp[key]; &#125; temp = null;&#125; var n = new B;console.log(n.x); //-&gt; 100 混合模式继承 原型继承 + call继承特点： 原型继承，可以继承父类私有的 + 公有的属性和方法； call继承：只能继承父类私有的属性和方法；缺点：父类私有的属性和方法即存在于子类的私有中，又存在于子类的公有中。12345678910111213function A()&#123; this.x = 100;&#125;A.prototype.getX = function()&#123; console.log(this.x);&#125;function B()&#123; A.call(this); //-&gt;n.x = 100&#125; B.prototype = new A; //-&gt; B.prototype : x = 100, getX: function....B.prototype.constructor = B;var n = new B;console.log(n.x); //-&gt; 100 寄生组合式继承 call继承 + Object.create(proObject)特点： call继承：只能继承父类私有的属性和方法； Object.create(proObject)：将父类的原型作为子类的原型，即继承父类公有的属性和方法缺点： A的原型改变，B的原型也会跟着改变，反之亦如此。12345678910111213function A()&#123; this.x = 100;&#125;A.prototype.getX = function()&#123; console.log(this.x);&#125;function B()&#123; A.call(this); //-&gt;n.x = 100&#125; B.prototype = Object.create(A.prototype);B.prototype.constructor = B;var n = new B;console.log(n.x); //-&gt; 100 中间类继承法 将数组原型作为一个类数组实例的原型arguments.__proto__ = Array.prototype;，则arguments可以直接使用Array中的内置方法。12345678//求平均数的方法function avgFn()&#123; Array.prototype.sort.call(arguments, function(a, b)&#123;return a-b&#125;); Array.prototype.pop.call(arguments); Array.prototype.shift.call(arguments); return (eval(Array.prototype.join.call(arguments, '+')) / arguments.length).toFixed(2);&#125; 1234567function avgFn2()&#123; arguments.__proto__ = Array.prototype; arguments.sort(function(a, b)&#123;return a-b&#125;).pop(); arguments.shift(); return (eval(arguments.join('+')) / arguments.length).toFixed(2);&#125;console.log(avgFn2(10, 20, 30, 10, 30, 40, 40));]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的this总结]]></title>
    <url>%2F2019%2F02%2F16%2FJS%E4%B8%AD%E7%9A%84this%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[函数中的this指向和当前函数在哪定义的或者在哪执行的都没有任何关系分析this指向的规律如下： [非严格模式下] 自执行函数中的this永远是window[案例1]123456789101112var obj = &#123; fn: (function(i)&#123; //this -&gt; window console.log(this); return function()&#123; //this -&gt; obj console.log(this); &#125; &#125;)(0)&#125;;obj.fn();console.log(obj); 给元素的某个行为绑定一个方法，当行为触发的时候，执行绑定的方法，此时方法中的this是当前元素[案例1]123oDiv.onCilck = function()&#123; //this -&gt; oDiv&#125; [案例2]1234567function fn()&#123; //this -&gt; window&#125;oDiv.onClick = function()&#123; //this -&gt; oDiv; fn();&#125; 方法执行，看方法名前面是否有’.‘，有的话，’.‘前面的是谁this就是谁，没有的话，this就是window[案例1]123456789101112var obj = &#123; fn: fn&#125;;function fn()&#123;&#125;fn.prototype.aa = function()&#123;&#125;;var f = new fn();fn(); // this -&gt; windowobj.fn(); //this -&gt; objfn.prototype.aa(); //this -&gt; fn.prototypef.aa(); // this -&gt; ff.__proto__.aa(); //this -&gt; f.__proto__ -&gt; fn.prototype 在构造函数模式中，函数体中的this.xxx = xxx中的this是当前类的一个实例[案例1]12345678function Fn()&#123; this.x = 100; this.getX = function ()&#123; console.log(this.x); //this -&gt; f 因为getX方法执行的时候，'.'前面是f, 所以this是f &#125; &#125;var f = new Fn();f.getX(); 使用call / apply / bind来改变this的指向（一旦遇到了call / play / bind上述四条都没用了） [严格模式下] use strict 告诉浏览器我们接下来的JS代码采用严格模式 自执行函数中的this永远是undefined[案例1]123456789var obj = &#123; fn: (function(i)&#123; //this -&gt; undefined return function()&#123; //this -&gt; obj &#125; &#125;)(0)&#125;;obj.fn(); 方法执行，看方法名前面是否有’.‘，有的话，’.‘前面的是谁this就是谁，没有的话，this就是undefined[案例1]123456789var obj = &#123; fn: fn&#125;;function fn()&#123;&#125;fn.prototype.aa = function()&#123;&#125;;var f = new fn();fn(); // this -&gt; undefinedobj.fn(); //this -&gt; obj 我们发现严格模式下的this相对于非严格模式下的this的主要区别在于：对于JS代码中没有写执行主体的情况下，非严格模式下，默认都是window执行的，所以this指向的是window;但是在严格的模式下，没有写就是没有执行主体，this指向的是undefined]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区分JS中的undefined,null,"",0和false]]></title>
    <url>%2F2019%2F02%2F16%2F%E5%8C%BA%E5%88%86JS%E4%B8%AD%E7%9A%84undefined%2Cnull%2C%E2%80%9D%E2%80%9C%2C0%E5%92%8Cfalse%2F</url>
    <content type="text"><![CDATA[在程序语言中定义的各种各样的数据类型中，我们都会为其定义一个”空值”或”假值”，比如对象类型的空值null，.NET Framework中数据库字段的空值DBNull，boolean类型的假值false等等。在JavaScript中也有很多种的”空值”和”假值”，那么它们都有什么共同点和不同点呢？ 其实标题里面我已经列出了JavaScript中所有的&quot;空值&quot;和&quot;假值&quot;，除了boolean值本身就是true和false这两种情况外，其它数据类型的&quot;空值&quot;主要是undefined和defined这两大类。这些空值的类型分别是： 12345typeof(undefined) == &apos;undefined&apos;typeof(null) == &apos;object&apos;typeof(&quot;&quot;) == &apos;string&apos;typeof(0) == &apos;number&apos;typeof(false) == &apos;boolean&apos; 这五个值的共同点是，在if语句中做判断，都会执行false分支。当然从广义上来看，是说明这些数值都是其对应数据类型上的无效值或空值。还有这五个值作!运算，结果全为：true。 这几个值中也有不同，其中undefined和null比较特殊，虽然null的类型是object，但是null不具有任何对象的特性，就是说我们并不能执行null.toString()、null.constructor等对象实例的默认调用。所以从这个意义上来说，null和undefined有最大的相似性。看看null == undefined的结果(true)也就更加能说明这点。不过相似归相似，还是有区别的，就是和数字运算时，10 + null结果为：10；10 + undefined结果为：NaN。 另外””、0和false虽然在if语句表现为”假值”，可它们都是有意义数据，只是被作为了”空值”或”假值”，因为：””.toString()，(0).toString()和false.toString()都是合法的可执行表达式。 其实这5个值在上面所说的这些差异里，并不太会给程流程控制带来太大的问题，那么要区分它们什么呢？需要注意区分的是这些值在转换为String时的差异是比较大的，它们到String的转换关系是： 12345String(undefined) -&gt; &quot;undefined&quot;String(null) -&gt; &quot;null&quot;String(&quot;&quot;) -&gt; &quot;&quot;String(0) -&gt; &quot;0&quot;String(false) -&gt; &quot;false&quot; 这个转换关系在做字符串累加时需要特别的注意，否这会出些意想不到的问题，今天就遇到一个null被默认转为”null”给弄得迷糊了好一阵子。123456789101112131415161718192021&lt;script&gt;alert(0 == ''); //truealert(0 == false); //truealert(false == ''); //truealert(null == undefined); //truealert(!0); //truealert(!false); //truealert(!undefined); //truealert(!null); //truealert(!''); //truealert(0 == undefined); //falsealert(0 == null); //falsealert(false == null); //falsealert(false == undefined);//falsealert('' == null); //falsealert('' == undefined); //false&lt;/script&gt; 对于 = = 与 === 的区别，点击查看详情]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS语法</tag>
        <tag>JS基础</tag>
      </tags>
  </entry>
</search>
